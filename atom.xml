<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lizhen&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/fad0a72a117d3a0a737be35e0a93c727</icon>
  <subtitle>人生苦短，我再睡会</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lz5z.com/"/>
  <updated>2018-05-21T15:12:03.124Z</updated>
  <id>https://lz5z.com/</id>
  
  <author>
    <name>lizhen</name>
    <email>lizhen55521@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web 性能优化-首屏和白屏时间</title>
    <link href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/"/>
    <id>https://lz5z.com/Web性能优化-首屏和白屏时间/</id>
    <published>2018-05-17T19:24:09.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>什么是首屏和白屏时间？</h2><p>白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。<br>首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。</p><p>白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素<br>首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成</p><p>影响白屏时间的因素：网络，服务端性能，前端页面结构设计。<br>影响首屏时间的因素：白屏时间，资源下载执行时间。</p><p>以百度为例，将 chrome 网速调为 Fast 3G，然后打开 Performance 工具，点击 “Start profiling and reload page” 按钮，查看 Screenshots 如下图：</p><a id="more"></a> <img src="/assets/img/first_and_write_screen.png" alt="first_and_write_screen"><h2>白屏时间</h2><p>通常认为浏览器开始渲染 <code>&lt;body&gt;</code> 或者解析完 <code>&lt;head&gt;</code> 的时间是白屏结束的时间点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>白屏<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 不兼容 performance.timing 的浏览器</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.pageStartTime = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 页面 CSS 资源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"xx.css"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"zz.css"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 白屏结束时间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.firstPaint = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 白屏时间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(firstPaint - performance.timing.navigationStart)</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>白屏时间 = firstPaint - performance.timing.navigationStart || pageStartTime</p><h2>首屏时间</h2><p>关于首屏时间是否包含图片加载网上有不同的说法，个人认为，只要首屏中的图片加载完成，即是首屏完成，不在首屏中的图片可以不考虑。</p><p>计算首屏时间常用的方法有：</p><p>(1) 首屏模块标签标记法</p><p>由于浏览器解析 HTML 是按照顺序解析的，当解析到某个元素的时候，你觉得首屏完成了，就在此元素后面加入 <code>script</code> 计算首屏完成时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首屏<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 不兼容 performance.timing 的浏览器</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.pageStartTime = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首屏可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首屏可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 首屏屏结束时间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.firstPaint = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 首屏时间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(firstPaint - performance.timing.navigationStart)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首屏不可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首屏不可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2) 统计首屏内加载最慢的图片/iframe</p><p>通常首屏内容中加载最慢的就是图片或者 iframe 资源，因此可以理解为当图片或者 iframe 都加载出来了，首屏肯定已经完成了。</p><p>由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。我们只需要监听首屏内所有的图片的 onload 事件，获取图片 onload 时间最大值，并用这个最大值减去 navigationStart 即可获得近似的首屏时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首屏<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 不兼容 performance.timing 的浏览器</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.pageStartTime = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://lz5z.com/assets/img/google_atf.png"</span> <span class="attr">alt</span>=<span class="string">"img"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://lz5z.com/assets/img/css3_gpu_speedup.png"</span> <span class="attr">alt</span>=<span class="string">"img"</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">load</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.firstScreen = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 首屏时间</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">window</span>.firstScreen - performance.timing.navigationStart)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance API</a></h3><p>Performance 接口可以获取到当前页面与性能相关的信息。</p><p>(1) Performance.timing</p><p>在 chrome 中查看 performance.timing 对象：</p><img src="/assets/img/performance-timing.png" alt="performance"><p>与浏览器对应的状态如下图：</p><img src="/assets/img/performance.png" alt="performance"><p>左边红线代表的是网络传输层面的过程，右边红线代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析，DOM 树构建，布局，绘制等等。</p><ul><li>navigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。</li><li>unloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。</li><li>unloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。</li><li>redirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。</li><li>redirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。</li><li>fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。</li><li>domainLookupStart/domainLookupEnd: DNS 域名查询开始/结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</li><li>connectStart: HTTP（TCP）开始/重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。</li><li>connectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。</li><li>secureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。</li><li>requestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。</li><li>responseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。</li><li>responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。</li><li>domLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。</li><li>domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。</li><li>domContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。</li><li>domContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。</li><li>domComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。</li><li>loadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。</li><li>loadEventEnd: load 事件的回调函数执行完毕的时间。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算加载时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerformanceTiming</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> t = performance.timing</span><br><span class="line">  <span class="keyword">var</span> times = &#123;&#125;</span><br><span class="line">  <span class="comment">// 页面加载完成的时间，用户等待页面可用的时间</span></span><br><span class="line">  times.loadPage = t.loadEventEnd - t.navigationStart</span><br><span class="line">  <span class="comment">// 解析 DOM 树结构的时间</span></span><br><span class="line">  times.domReady = t.domComplete - t.responseEnd</span><br><span class="line">  <span class="comment">// 重定向的时间</span></span><br><span class="line">  times.redirect = t.redirectEnd - t.redirectStart</span><br><span class="line">  <span class="comment">// DNS 查询时间</span></span><br><span class="line">  times.lookupDomain = t.domainLookupEnd - t.domainLookupStart</span><br><span class="line">  <span class="comment">// 读取页面第一个字节的时间</span></span><br><span class="line">  times.ttfb = t.responseStart - t.navigationStart</span><br><span class="line">  <span class="comment">// 资源请求加载完成的时间</span></span><br><span class="line">  times.request = t.responseEnd - t.requestStart</span><br><span class="line">  <span class="comment">// 执行 onload 回调函数的时间</span></span><br><span class="line">  times.loadEvent = t.loadEventEnd - t.loadEventStart</span><br><span class="line">  <span class="comment">// DNS 缓存时间</span></span><br><span class="line">  times.appcache = t.domainLookupStart - t.fetchStart</span><br><span class="line">  <span class="comment">// 卸载页面的时间</span></span><br><span class="line">  times.unloadEvent = t.unloadEventEnd - t.unloadEventStart</span><br><span class="line">  <span class="comment">// TCP 建立连接完成握手的时间</span></span><br><span class="line">  times.connect = t.connectEnd - t.connectStart</span><br><span class="line">  <span class="keyword">return</span> times</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) Performance.navigation</p><ul><li>redirectCount: 0 // 页面经过了多少次重定向</li><li>type: 0<ul><li>0 表示正常进入页面；</li><li>1 表示通过 <code>window.location.reload()</code> 刷新页面；</li><li>2 表示通过浏览器前进后退进入页面；</li><li>255 表示其它方式</li></ul></li></ul><p>(3) Performance.memory</p><ul><li>jsHeapSizeLimit: 内存大小限制</li><li>totalJSHeapSize: 可使用的内存</li><li>usedJSHeapSize: JS 对象占用的内存</li></ul><h3>DOMContentLoaded vs load</h3><p>(1) DOMContentLoaded 是指页面元素加载完毕，但是一些资源比如图片还无法看到，但是这个时候页面是可以正常交互的，比如滚动，输入字符等。 jQuery 中经常使用的 <code>$(document).ready()</code> 其实监听的就是 DOMContentLoaded 事件。</p><p>(2) load 是指页面上所有的资源（图片，音频，视频等）加载完成。jQuery 中 <code>$(document).load()</code> 监听的是 load 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOMContentLoaded</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ready</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.removeEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="built_in">arguments</span>.callee, <span class="literal">false</span>)</span><br><span class="line">            fn()</span><br><span class="line">        &#125;, <span class="literal">false</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果 IE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;</span><br><span class="line">        <span class="comment">// 确保当页面是在iframe中加载时，事件依旧会被安全触发</span></span><br><span class="line">        <span class="built_in">document</span>.attachEvent(<span class="string">'onreadystatechange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line">                <span class="built_in">document</span>.detachEvent(<span class="string">'onreadystatechange'</span>, <span class="built_in">arguments</span>.callee)</span><br><span class="line">                fn()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 如果是 IE 且页面不在 iframe 中时，轮询调用 doScroll 方法检测DOM是否加载完毕</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement.doScroll &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>.frameElement === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">document</span>.documentElement.doScroll(<span class="string">'left'</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">                <span class="keyword">return</span> setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">20</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            fn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>参考资料</h2><ul><li><a href="http://www.cnblogs.com/longm/p/7382163.html" target="_blank" rel="noopener">前端优化-如何计算白屏和首屏时间</a></li><li><a href="https://segmentfault.com/a/1190000005784687" target="_blank" rel="noopener">前端性能的几个基础指标</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance - MDN</a></li><li><a href="http://www.alloyteam.com/2015/09/explore-performance/" target="_blank" rel="noopener">初探 performance – 监控网页与程序性能</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;什么是首屏和白屏时间？&lt;/h2&gt;&lt;p&gt;白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。&lt;br&gt;首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。&lt;/p&gt;&lt;p&gt;白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素&lt;br&gt;首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成&lt;/p&gt;&lt;p&gt;影响白屏时间的因素：网络，服务端性能，前端页面结构设计。&lt;br&gt;影响首屏时间的因素：白屏时间，资源下载执行时间。&lt;/p&gt;&lt;p&gt;以百度为例，将 chrome 网速调为 Fast 3G，然后打开 Performance 工具，点击 “Start profiling and reload page” 按钮，查看 Screenshots 如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="https://lz5z.com/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="首屏" scheme="https://lz5z.com/tags/%E9%A6%96%E5%B1%8F/"/>
    
      <category term="白屏" scheme="https://lz5z.com/tags/%E7%99%BD%E5%B1%8F/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能优化-缓存-HTTP 缓存</title>
    <link href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-HTTP%E7%BC%93%E5%AD%98/"/>
    <id>https://lz5z.com/Web性能优化-HTTP缓存/</id>
    <published>2018-05-16T16:39:55.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>浏览器缓存</h2><p>HTTP 缓存通常要配合客户端（浏览器）使用才能发挥效果，所以又被称之为浏览器缓存，是 Web 性能优化的一大利器。这里有一个 <a href="https://github.com/Leo555/http-cache-demo" target="_blank" rel="noopener">demo</a> 展现 HTTP 缓存的效果，你可以 clone 到本地，通过 <code>npm run dev</code> 来查看效果。</p><h3>缓存类型</h3><p>浏览器缓存分为强缓存和协商缓存。</p><p>(1) 强缓存：浏览器在加载资源的时候，根据资源的 HTTP Header 判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。</p><p>(2) 协商缓存：当强缓存没有命中的时候，浏览器向服务器发送请求，服务器端依据资源的另外一些 HTTP Header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 304，浏览器从缓存中加载这个资源；若未命中请求，服务端返回 200 并将资源返回客户端，浏览器更新本地缓存数据。</p><a id="more"></a><p>另外一种分类方式，可以将浏览器缓存分成 HTTP 协议缓存和非 HTTP 协议缓存。</p><p>(1) 非 HTTP 协议缓存：使用 HTML Meta 标签，开发者可以告诉浏览器是否缓存当前页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Expires"</span> <span class="attr">CONTENT</span>=<span class="string">"0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码告诉浏览器当前页面不能被缓存，每次访问都要去服务端拉取。只有部分浏览器支持，缓存代理服务器不支持。</p><p>(2) HTTP 协议缓存：通过在 HTTP 协议头里面定义一些字段来告诉浏览器当前资源是否缓存，比如 Cache-Control, Expires, Last-Modified, Etag 等。</p><h2>HTTP 缓存</h2><h3>HTTP/1.0 缓存字段</h3><p>(1) <strong>Pragma</strong>：设置资源是否缓存，no-cache 表示不缓存。在 HTTP/1.1 中被 Cache-Control 替代，所以优先级低于 Cache-Control。</p><p>(2) <strong>Expires</strong>：设置资源过期时间，Expires 的值对应一个 GMT(格林尼治时间) 来告诉浏览器资源什么时间过期。缺点是如果客户端与服务端时间相差很大，会导致时间计算不精确，在 HTTP/1.1 中被 max-age 取代。</p><h3>HTTP/1.1 相关字段</h3><p>(1) <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a></strong>：设置一个相对的时间，在缓存判定的时候，由浏览器进行判断。Cache-Control 的值可以是 public, private, no-cache, no-store, no-transform 等。</p><ul><li><p>max-age(单位为 s) 设定缓存最大的有效时间，<code>Cache-Control: max-age=3600</code> 表示该资源在浏览器端一个小时内均有效。</p></li><li><p>s-maxage(单位是 s) 设定共享缓存时间，比如 CDN 或者代理。</p></li><li><p>no-store 网络资源不缓存，每次都到服务器上拉取。</p></li><li><p>no-cache 表示网络资源可以缓存一份，但使用前必须询问服务器此资源是不是最新的。</p></li><li><p>public 表明响应可以被任何对象（客户端，代理服务器等）缓存。</p></li><li><p>private 表明响应只能被单个用户缓存，其它用户或者代理服务器不能缓存这些数据。</p></li></ul><p>(2) <strong>Last-Modified/If-Modified-Since:</strong>：</p><ul><li><p>Last-Modified 表示响应资源最后修改时间，需要与 Cache-Control 共同使用，是检查服务端资源更新的一种方式。</p></li><li><p>If-Modified-Since 表示资源过期时（超过 max-age），发现资源具有 Last-Modified 声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web 服务器收到请求后发现 Header 中有 If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p></li></ul><p>(3) <strong>Etag/If-None-Match</strong>：</p><ul><li><p>Etag 是根据资源内容生成的一段 hash 字符串，标识资源的状态，由服务端产生。浏览器将这串字符串传回服务器，验证资源是否发生修改。</p></li><li><p>If-None-Match 表示当资源过期时（超过 max-age），发现资源有 Etag 声明，向 web 服务器发送请求时带上 If-None-Match （Etag 值）。web 服务器收到请求后发现 Header 中带有 If-None-Match 则与被请求资源的相应校验串进行对比，决定返回 200 或者 304。</p></li></ul><h3>Last-Modified vs Etag</h3><p>Etag 可以解决 Last-Modified 存在的一些问题：</p><ul><li>某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新。</li><li>如果资源修改非常频繁，而 Last-modified 只能精确到秒。</li><li>一些资源的最后修改时间改变了，但是内容没改变，使用 ETag 就认为资源还是没有修改的。</li></ul><h2>浏览器行为</h2><p>(1) F5 刷新页面时，会跳过强缓存，检查协商缓存。<br>(2) ctrl + F5 强制刷新页面时，之间从服务端加载数据，跳过强缓存和协商缓存。</p><h2>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noopener">HTTP Headers</a></li><li><a href="https://www.cnblogs.com/vajoy/p/5341664.html" target="_blank" rel="noopener">浅谈浏览器http的缓存机制</a></li><li><a href="https://segmentfault.com/a/1190000009638800" target="_blank" rel="noopener">Web缓存相关知识整理</a></li><li><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/" target="_blank" rel="noopener">浅谈Web缓存</a></li><li><a href="https://segmentfault.com/a/1190000006741200" target="_blank" rel="noopener">详谈Web缓存</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;浏览器缓存&lt;/h2&gt;&lt;p&gt;HTTP 缓存通常要配合客户端（浏览器）使用才能发挥效果，所以又被称之为浏览器缓存，是 Web 性能优化的一大利器。这里有一个 &lt;a href=&quot;https://github.com/Leo555/http-cache-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo&lt;/a&gt; 展现 HTTP 缓存的效果，你可以 clone 到本地，通过 &lt;code&gt;npm run dev&lt;/code&gt; 来查看效果。&lt;/p&gt;&lt;h3&gt;缓存类型&lt;/h3&gt;&lt;p&gt;浏览器缓存分为强缓存和协商缓存。&lt;/p&gt;&lt;p&gt;(1) 强缓存：浏览器在加载资源的时候，根据资源的 HTTP Header 判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。&lt;/p&gt;&lt;p&gt;(2) 协商缓存：当强缓存没有命中的时候，浏览器向服务器发送请求，服务器端依据资源的另外一些 HTTP Header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 304，浏览器从缓存中加载这个资源；若未命中请求，服务端返回 200 并将资源返回客户端，浏览器更新本地缓存数据。&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="https://lz5z.com/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="HTTP" scheme="https://lz5z.com/tags/HTTP/"/>
    
      <category term="Cache" scheme="https://lz5z.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能优化-缓存-DNS 缓存</title>
    <link href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-DNS%E7%BC%93%E5%AD%98/"/>
    <id>https://lz5z.com/Web性能优化-DNS缓存/</id>
    <published>2018-05-16T13:32:17.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>缓存梗概</h2><p>缓存技术几乎存在于网络技术发展的各个角落，从数据库到服务器，从服务器到网络，再从网络到客户端，缓存随处可见。跟前端有关的缓存技术主要有：DNS 缓存，HTTP 缓存，浏览器缓存，HTML5 缓存（localhost/manifest）和 service worker 中的 cache api。</p><h2>DNS 缓存</h2><p>当用户在浏览器中输入网址的地址后，浏览器要做的第一件事就是解析 DNS：</p><p>(1) 浏览器检查缓存中是否有域名对应的 IP，如果有就结束 DNS 解析过程。浏览器中的 DNS 缓存有时间和大小双重限制，时间一般为几分钟到几个小时不等。DNS 缓存时间过长会导致如果 IP 地址发生变化，无法解析到正确的 IP 地址；时间过短会导致浏览器重复解析域名。</p><p>(2) 如果浏览器缓存中没有对应的 IP 地址，浏览器会继续查找操作系统缓存中是否有域名对应的 DNS 解析结果。我们可以通过在操作系统中设置 hosts 文件来设置 IP 与域名的关系。</p><a id="more"></a><p>(3) 如果还没有拿到解析结果，操作系统就会把域名发送给本地区的域名服务器（LDNS），LDNS 通常由互联网服务提供商（ISP）提供，比如电信或者联通。这个域名服务器一般在城市某个角落，并且性能较好，当拿到域名后，首先也是从缓存中查找，看是否有匹配的结果。一般来说，大多数的 DNS 解析到这里就结束了，所以 LDNS/ISP DNS 承担了大部分的域名解析工作。如果缓存中有 IP 地址，就直接返回，并且会被标记为<strong>非权威服务器应答</strong>。</p><blockquote><p>第三步有一点需要注意的是，如果用户在自己电脑里设置了 DNS，比如 Google 的 <code>8.8.8.8</code> 或者 CloudFlare 新出的 <a href="https://blog.cloudflare.com/announcing-1111/" target="_blank" rel="noopener"><code>1.1.1.1</code></a>，将不会通过 ISP DNS 服务器解析。</p></blockquote><p>(4) 如果前面三步还没有命中 DNS 缓存，那只能到 Root Server 域名服务器中请求解析了。根域名服务器拿到请求后，首先判断域名是哪个顶级域名下的，比如 <code>.com</code>, <code>.cn</code>, <code>.org</code> 等，全球一共 13 台顶级域名服务器。根域名服务器返回对应的顶级域名服务器（gTLD Server）地址。</p><p>(5) 本地域名服务器（LDNS）拿到地址后，向 gTLD Server 发送请求，gTLD 服务器查找并且返回此域名对应的 Name Server 域名服务器地址。这个 Name Server 通常就是用户注册的域名服务器，例如用户在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成。</p><blockquote><p>这个过程的解析方式为递归搜索。比如：<code>https://movie.lz5z.com</code>，本地域名服务器首先向顶级域名服务器（com 域）发送请求，com 域名服务器将域名中的二级域 <code>lz5z</code> 的 IP 地址返回给 LDNS，LDNS 再向二级域名服务器发送请求进行查询，之后不断重复直到 LDNS 得到最终的查询结果。</p></blockquote><p>(6) Name Server 域名服务器会查询存储的域名和 IP 的映射关系表，在正常情况下都根据域名得到目标 IP 地址，连同一个 TTL 值返回给 LDNS。LDNS 会缓存这个域名和 IP 的对应关系，缓存时间由 TTL 值控制。LDNS 会把解析结果返回给用户，DNS 解析结束。</p><h3>清除 DNS 缓存</h3><p>(1) chrome: <code>chrome://net-internals/#dns</code><br>(2) 本地 DNS ：Windows: <code>ipconfig /flushdns</code>; Linux 和 mac 根据不同的版本有不同的方式</p><h3>减少 DNS 解析我们能做什么？</h3><p>(1) 减少 DNS 查询，避免重定向。<br>(2) DNS 预解析：</p><ul><li>可以通过 meta 信息告诉浏览器，页面需要做 DNS 预解析。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过 link 标签强制 DNS 预解析</li></ul><pre><code class="language-html">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://lz5z.com&quot; /&gt;</code></pre><p>(3) 域名发散/域名收敛</p><ul><li>域名发散</li></ul><p>PC 端因为浏览器有域名并发请求限制（chrome 为 6 个），也就是同一时间，浏览器最多向同一个域名发送 6 个请求，因此 PC 端使用域名发散策略，将 http 静态资源放入多个域名/子域名中，以保证资源更快加载。常见的办法为使用 cdn。</p><ul><li>域名收敛</li></ul><p>将静态资源放在同一个域名下，减少 DNS 解析的开销。域名收敛是移动互联网时代的产物，在 LDNS 没有缓存的情况下，DNS 解析占据一个请求的大多数时间，因此，采用尽可能少的域名对整个页面加载速度有显著的提高。</p><p>(4) HttpDNS</p><p>DNS 请求使用的是 UDP 协议，虽然没有 TCP 三次握手的开销，但是可能导致弱网环境下（2G，3G）数据丢失的问题。还记得之前<a href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/">Web 性能优化-页面重绘和回流（重排）</a>中提到的 Google 1s 终端首屏渲染标准，假如 DNS 解析出现问题，那可能几秒甚至几十秒都首屏不了了。而且国内牛 X 的运营商的品质你也是知道的，随便劫持一下 DNS 就让你的 web 应用不见天日。</p><p>为了应对以上两个问题，HttpDNS 应运而生，原理也非常简单，将 DNS 这种容易被劫持的协议，转而使用 HTTP 协议请求 Domain 与 IP 地址之间的映射。获得正确的 IP 地址后，就不用担心 ISP 篡改数据了。</p><p>国内腾讯云和阿里云都有相应的解决方案</p><ul><li><a href="https://cloud.tencent.com/product/hd" target="_blank" rel="noopener">移动解析HttpDNS</a></li><li><a href="https://cn.aliyun.com/product/httpdns" target="_blank" rel="noopener">HTTPDNS</a></li></ul><p>Google 的方案则更近一步，使用 https 协议。</p><ul><li><a href="https://developers.google.com/speed/public-dns/docs/dns-over-https" target="_blank" rel="noopener">DNS-over-HTTPS</a></li></ul><h2>参考资料</h2><ul><li><a href="http://www.cnblogs.com/xrq730/p/4931418.html" target="_blank" rel="noopener">DNS域名解析过程</a></li><li><a href="http://taobaofed.org/blog/2015/12/16/h5-performance-optimization-and-domain-convergence/" target="_blank" rel="noopener">无线性能优化：域名收敛</a></li><li><a href="https://www.cloudxns.net/Support/detail/id/1273.html" target="_blank" rel="noopener">提升页面访问速度的前端优化大法：DNS预解析</a></li><li><a href="https://www.jianshu.com/p/6c790b9652a2" target="_blank" rel="noopener">也谈 HTTPS - HTTPDNS + HTTPS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;缓存梗概&lt;/h2&gt;&lt;p&gt;缓存技术几乎存在于网络技术发展的各个角落，从数据库到服务器，从服务器到网络，再从网络到客户端，缓存随处可见。跟前端有关的缓存技术主要有：DNS 缓存，HTTP 缓存，浏览器缓存，HTML5 缓存（localhost/manifest）和 service worker 中的 cache api。&lt;/p&gt;&lt;h2&gt;DNS 缓存&lt;/h2&gt;&lt;p&gt;当用户在浏览器中输入网址的地址后，浏览器要做的第一件事就是解析 DNS：&lt;/p&gt;&lt;p&gt;(1) 浏览器检查缓存中是否有域名对应的 IP，如果有就结束 DNS 解析过程。浏览器中的 DNS 缓存有时间和大小双重限制，时间一般为几分钟到几个小时不等。DNS 缓存时间过长会导致如果 IP 地址发生变化，无法解析到正确的 IP 地址；时间过短会导致浏览器重复解析域名。&lt;/p&gt;&lt;p&gt;(2) 如果浏览器缓存中没有对应的 IP 地址，浏览器会继续查找操作系统缓存中是否有域名对应的 DNS 解析结果。我们可以通过在操作系统中设置 hosts 文件来设置 IP 与域名的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="https://lz5z.com/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="DNS" scheme="https://lz5z.com/tags/DNS/"/>
    
      <category term="HttpDNS" scheme="https://lz5z.com/tags/HttpDNS/"/>
    
      <category term="LDNS" scheme="https://lz5z.com/tags/LDNS/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化-CommonJS,AMD,CMD,ES6</title>
    <link href="https://lz5z.com/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96-CommonJS-AMD-CMD-ES6/"/>
    <id>https://lz5z.com/JavaScript模块化-CommonJS-AMD-CMD-ES6/</id>
    <published>2018-05-06T23:03:17.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>模块化解决什么问题</h2><p>随着 JavaScript 工程越来越大，团队协作不可避免，为了更好地对代码进行管理和测试，模块化的概念逐渐引入前端。模块化可以降低协同开发的成本，减少代码量，同时也是“高内聚，低耦合”的基础。</p><p>模块化主要解决两个问题：</p><ol><li>命名冲突</li><li>文件依赖：比如 bootstrap 需要引入 jquery，jquery 文件的位置必须要 bootstrap.js 之前引入。</li></ol><a id="more"></a><h3>远古时代的人们是怎样解决模块化的</h3><p>在各种模块化规范出来之前，人们使用匿名闭包函数解决模块化的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num0 = <span class="number">2</span>; <span class="comment">// 注意这里的分号</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> num2 = <span class="number">5</span> </span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num0 + num1 + num2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(add()) <span class="comment">// 10</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(num1) // num1 is not defined</span></span><br></pre></td></tr></table></figure><p>这样做的好处是，你可以在函数内部使用全局变量和局部变量，并且不用担心局部变量污染全局变量。这种用括号把匿名函数包起来的方式，也叫做立即执行函数（IIFE）。所有函数内部代码都在闭包(closure)内。它提供了整个应用生命周期的私有和状态。</p><h3>CommonJS 规范</h3><p>CommonJS 将每个文件都视为一个模块，在每个模块中变量默认都是私有变量，通过 module.exports 定义当前模块对外输出的接口，通过 require 加载模块。</p><p>(1) 使用方法：</p><p>circle.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line"></span><br><span class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br></pre></td></tr></table></figure><p>app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(circle.area(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>(2) 原理：node 在编译 js 文件的过程中，会使用一个如下的函数包装器将其包装<a href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper" target="_blank" rel="noopener">模块包装器</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(circle.area(<span class="number">4</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这也是为什么在 node 环境中可以使用这几个没有显式定义的变量的原因。其中 <code>__filename</code> 和 <code>__dirname</code> 在查找文件路径的过程中分析得到后传入的。module 变量是这个模块对象自身，exports 是在 module 的构造函数中初始化的一个空对象。</p><p>更详细的内容可以参考 <a href="http://nodejs.cn/api/modules.html" target="_blank" rel="noopener">node modules</a></p><p>关于什么时候使用 exports、什么时候使用 module.exports，可以参考 <a href="http://nodejs.cn/api/modules.html#modules_exports_shortcut" target="_blank" rel="noopener">exports shutcut</a></p><p>(3) 优点 vs 缺点</p><p>CommonJS 能够避免全局命名空间污染，并且明确代码之间的依赖关系。但是 CommonJS 的模块加载是同步的，假如一个模块引用三个其它模块，那么这三个模块需要被完全加载后这个模块才能运行。这在服务端不是什么问题（node），但是在浏览器端就不是那么高效了，毕竟读取网络文件比本地文件要耗时的多。</p><h3>AMD</h3><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 全称异步模块化定义规范（Asynchronous Module Definition），采用异步加载模块的方式，模块的加载不影响后面语句的执行，并且使用 callback 回调函数的方式来运行模块加载完成后的代码。</p><p>(1) 使用方式</p><p>定义一个 myModule 的模块，它依赖 jQuery 模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'myModule'</span>, [<span class="string">'jQuery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $ 是 jQuery 的输出模块</span></span><br><span class="line">  $(<span class="string">'#app'</span>).text(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一个参数表示模块 id，为可选参数，第二个参数表示模块依赖，也是可选参数。</p><p>使用 myModule 模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'myModule'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">myModule</span>) </span>&#123;&#125;])</span><br></pre></td></tr></table></figure><p><a href="http://requirejs.org/" target="_blank" rel="noopener">requirejs</a> 是 AMD 规范的一个实现，详细的使用方法可以查看官方文档。</p><h3>CMD</h3><p>CMD 规范来源于 <a href="https://seajs.github.io/seajs/docs/" target="_blank" rel="noopener">seajs</a>，CMD 总体于 AMD 使用起来非常接近，AMD 与 CMD 的区别，可以查看 与 RequireJS 的异同](<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a>)</p><p>(1) 使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line">  <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CMD 推崇依赖就近，可以把依赖写进你的代码中的任意一行，AMD 是依赖前置的，在解析和执行当前模块之前，模块必须指明当前模块所依赖的模块。</p><h3>UMD</h3><p>UMD（Universal Module Definition）并不是一种规范，而是结合 AMD 和 CommonJS 的一种更为通用的 JS 模块解决方案。</p><p>在打包模块的时候经常会见到这样的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">  filename: <span class="string">'vue.js'</span>,</span><br><span class="line">  library: <span class="string">'Vue'</span>,</span><br><span class="line">  libraryTarget: <span class="string">'umd'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>表示打包出来的模块为 umd 模块，既能在服务端（node）运行，又能在浏览器端运行。我们来看 vue 打包后的源码 <a href="https://github.com/vuejs/vue/blob/master/dist/vue.js" target="_blank" rel="noopener">vue.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line"><span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? <span class="built_in">module</span>.exports = factory() :</span><br><span class="line"><span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define(factory) :</span><br><span class="line">(global.Vue = factory());</span><br><span class="line">&#125;(<span class="keyword">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="string">'use strict'</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)))</span><br></pre></td></tr></table></figure><p>代码翻译过来就是：</p><ol><li>首先判断是否为 node 环境：exports 为一个对象，并且 module 存在。</li><li>如果是 node 环境就用 <code>module.exports = factory()</code> 把 vue 导出 （通过 require(‘vue’) 进行引用）。</li><li>如果不是 node 环境判断是否支持 AMD：define 为 function 并且 define.amd 存在。</li><li>如果支持 AMD 就使用 define 定义模块，（通过 require([‘vue’]) 引用）。</li><li>否则的话直接将 vue 绑定在全局变量上（通过 window.vue 引用）。</li></ol><h3>ES6</h3><p>终于到了 ES6 的时代，JS 开始从语言层面支持模块化，从 node8.5 版本开始支持原生 ES 模块。不过有两点限制：</p><ol><li>模块名（文件名）必须为 mjs</li><li>启动参数要加上 <code>--experimental-modules</code></li></ol><p>假如有 a.mjs 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 b.mjs 中可以引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'./a.mjs'</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// &#123; name: 'Jack' &#125;</span></span><br></pre></td></tr></table></figure><p>chrome61 开始也支持 JS module，只需要在 script 属性中添加 <code>type=&quot;module&quot;</code> 即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"module.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; sayHello &#125; <span class="keyword">from</span> <span class="string">'./main.js'</span></span></span><br><span class="line"><span class="undefined">  sayHello()</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line"></span><br><span class="line">export function sayHello () &#123;</span><br><span class="line">  console.info('Hello World')</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>ES6 module 详解</h3><p>ES6 module 主要由两个命令组成：export 和 import。</p><p>(1) export 命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> num = <span class="number">123</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'Leo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一组变量</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Leo'</span></span><br><span class="line"><span class="keyword">export</span> &#123; num, name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x ** y &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用别名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  a <span class="keyword">as</span> name,</span><br><span class="line">  b <span class="keyword">as</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用的时候按照别名引用</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, value &#125; <span class="keyword">from</span> <span class="string">'..'</span></span><br></pre></td></tr></table></figure><p>需要注意的是，export 命令只能对外输出接口，以下的输出方式均为错误的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> m</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> &#123; m &#125;</span><br><span class="line"><span class="keyword">export</span> &#123; m <span class="keyword">as</span> n&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; f &#125;</span><br></pre></td></tr></table></figure><p>export 输出的值是动态绑定的，这点与 CommonJS 不同，CommonJS 输出的是值的缓存，不存在动态更新。</p><p>如何删除 node 缓存？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">require</span>.cache[<span class="built_in">require</span>.resolve(<span class="string">'./config'</span>)]</span><br><span class="line">  config = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(config)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>export 命令必须处于模块顶层，如果处于块级作用域内，就会报错。</p><p>(2) import 命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 的变量是只读的</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line">a = <span class="number">33</span> <span class="comment">// Syntax Error : 'a' is read-only</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是可以修改其属性值</span></span><br><span class="line">a.name = <span class="string">'Jack'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import 命令可以提升变量</span></span><br><span class="line">foo()</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import 是静态执行，不能使用表达式和变量</span></span><br><span class="line"><span class="keyword">import</span> &#123; a + b &#125; <span class="keyword">from</span> <span class="string">'./a.ls'</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载整个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br></pre></td></tr></table></figure><p>(3) export default</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用 a</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'a.js'</span></span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> funtion foo () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用 b</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'b.js'</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>export default 与 export 输出的模块在引用的时候，差别仅仅是是否用 <code>{}</code> 将变量包起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; add <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'a.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>(4) export 与 import 复合写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'a.js'</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'a.js'</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;</span><br></pre></td></tr></table></figure><h2>参考资料</h2><ul><li><a href="http://www.cnblogs.com/imwtr/p/4666181.html" target="_blank" rel="noopener">关于 CommonJS AMD CMD UMD 规范的差异总结</a></li><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;模块化解决什么问题&lt;/h2&gt;&lt;p&gt;随着 JavaScript 工程越来越大，团队协作不可避免，为了更好地对代码进行管理和测试，模块化的概念逐渐引入前端。模块化可以降低协同开发的成本，减少代码量，同时也是“高内聚，低耦合”的基础。&lt;/p&gt;&lt;p&gt;模块化主要解决两个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;命名冲突&lt;/li&gt;&lt;li&gt;文件依赖：比如 bootstrap 需要引入 jquery，jquery 文件的位置必须要 bootstrap.js 之前引入。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://lz5z.com/tags/ES6/"/>
    
      <category term="CommonJS" scheme="https://lz5z.com/tags/CommonJS/"/>
    
      <category term="AMD" scheme="https://lz5z.com/tags/AMD/"/>
    
      <category term="CMD" scheme="https://lz5z.com/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能优化-CSS3 硬件加速(GPU 加速)</title>
    <link href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CSS3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    <id>https://lz5z.com/Web性能优化-CSS3硬件加速/</id>
    <published>2018-05-03T20:10:40.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>CSS3 硬件加速简介</h2><p>上一篇文章学习了重绘和回流对页面性能的影响，是从比较宏观的角度去优化 Web 性能，本篇文章从每一帧的微观角度进行分析，来学习 CSS3 硬件加速的知识。</p><p>CSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。由于 GPU 中的 transform 等 CSS 属性不会触发 repaint，所以能大大提高网页的性能。</p><p>我做了一个页面，左边元素的动画通过 left/top 操作位置实现，右边元素的动画通过 <code>transform: translate</code> 实现，你可以打开 chrome 的 “Paint flashing” 查看，绿色部分是正在 repaint 的内容。</p><p><a href="https://lz5z.com/css3_hardware_speedup/">查看地址</a></p><p>从 demo 中可以看到左边的图形在运动时外层有一圈绿色的边框，表示元素不停地 repaint，并且可以看到其运动过程中有丢帧现象，具体表现为运动不连贯，有轻微闪动。</p><a id="more"></a><h3>动画与帧</h3><p>之前学习 flash 的时候，就知道动画是由一帧一帧的图片组成，在浏览器中也是如此。我们首先看一下，浏览器每一帧都做了什么。</p><img src="/assets/img/css3_gpu_speedup.png" alt="css3_gpu_speedup" style="max-height:: 66px"><blockquote><ol><li>JavaScript：JavaScript 实现动画效果，DOM 元素操作等。</li><li>Style（计算样式）：确定每个 DOM 元素应该应用什么 CSS 规则。</li><li>Layout（布局）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow。</li><li>Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。</li><li>Composite（渲染层合并）：按照合理的顺序合并图层然后显示到屏幕上。</li></ol></blockquote><h3>动画与图层</h3><p>浏览器在获取 render tree（详细知识可以查看<a href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/">Web性能优化-页面重绘和回流（重排）</a>）后，渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到 GPU 形成渲染纹理。GPU 中 transform 是不会触发 repaint 的，这一点非常类似 3D 绘图功能，最终这些使用 transform 的图层都会由独立的合成器进程进行处理。</p><p>过程如下：</p><p>render tree -&gt; 渲染元素 -&gt; 图层 -&gt; GPU 渲染 -&gt; 浏览器复合图层 -&gt; 生成最终的屏幕图像。</p><blockquote><p>TIPS: chrome devtools 中可以开启 Rendering 中的 Layer borders 查看图层纹理。<br>其中黄色边框表示该元素有 3d 变换，表示放到一个新的复合层（composited layer）中渲染，蓝色栅格表示正常的 render layer。</p></blockquote><p>在文章开始给出的<a href="https://lz5z.com/css3_hardware_speedup/">例子</a>中，我们也可以开启 Layer borders，可以观察到，使用 <code>transform: translate</code> 动画的元素，外围有一个黄色的边框，可知其为复合层。</p><img src="/assets/img/css3_gpu_lauer_borders.png" alt="css3_gpu_lauer_borders"><p>在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层（黄色边框部分），一旦独立出来，就不会影响其它 DOM 的布局，所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了。</p><h3>创建独立图层</h3><p>哪些规则能让浏览器主动帮我们创建独立的层呢？</p><ol><li>3D 或者透视变换（perspective，transform） 的 CSS 属性。</li><li>使用加速视频解码的 video 元素。</li><li>拥有 3D（WebGL） 上下文或者加速 2D 上下文的 canvas 元素。</li><li>混合插件（Flash)。</li><li>对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素。</li><li>拥有加速 CSS 过滤器的元素。</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)。</li><li>元素有一个兄弟元素在复合图层渲染，并且该兄弟元素的 z-index 较小，那这个元素也会被应用到复合图层。</li></ol><p>关于 z-index 导致的硬件加速的问题，可以查看这篇文章 <a href="http://div.io/topic/1348" target="_blank" rel="noopener">CSS3硬件加速也有坑！！</a></p><h3>开启 GPU 加速</h3><p>CSS 中的以下几个属性能触发硬件加速：</p><ol><li>transform</li><li>opacity</li><li>filter</li><li>will-change</li></ol><p>如果有一些元素不需要用到上述属性，但是需要触发硬件加速效果，可以使用一些小技巧来诱导浏览器开启硬件加速。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0); </span><br><span class="line">    <span class="comment">/**或者**/</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(360deg);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我在不同的资料中查到的 transform 是否能触发硬件加速的结果不同，自己测试后，发现结果是可以。</p><h3>要注意的问题</h3><p>（1）过多地开启硬件加速可能会耗费较多的内存，因此什么时候开启硬件加速，给多少元素开启硬件加速，需要用测试结果说话。<br>（2）GPU 渲染会影响字体的抗锯齿效果。这是因为 GPU 和 CPU 具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。</p><h2>参考文章</h2><ul><li><a href="http://blog.teamtreehouse.com/increase-your-sites-performance-with-hardware-accelerated-css" target="_blank" rel="noopener">Increase Your Site’s Performance with Hardware-Accelerated CSS</a></li><li><a href="http://www.cnblogs.com/rubylouvre/p/3471490.html" target="_blank" rel="noopener">用CSS开启硬件加速来提高网站性能</a></li><li><a href="https://www.jianshu.com/p/f8b1d6e598db" target="_blank" rel="noopener">css3硬件加速</a></li><li><a href="http://div.io/topic/1348" target="_blank" rel="noopener">CSS3硬件加速也有坑！！</a></li><li><a href="https://aotu.io/notes/2017/04/11/GPU/index.html" target="_blank" rel="noopener">GPU加速是什么</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/" target="_blank" rel="noopener">使用CSS3 will-change提高页面滚动、动画等渲染性能</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;CSS3 硬件加速简介&lt;/h2&gt;&lt;p&gt;上一篇文章学习了重绘和回流对页面性能的影响，是从比较宏观的角度去优化 Web 性能，本篇文章从每一帧的微观角度进行分析，来学习 CSS3 硬件加速的知识。&lt;/p&gt;&lt;p&gt;CSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。由于 GPU 中的 transform 等 CSS 属性不会触发 repaint，所以能大大提高网页的性能。&lt;/p&gt;&lt;p&gt;我做了一个页面，左边元素的动画通过 left/top 操作位置实现，右边元素的动画通过 &lt;code&gt;transform: translate&lt;/code&gt; 实现，你可以打开 chrome 的 “Paint flashing” 查看，绿色部分是正在 repaint 的内容。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://lz5z.com/css3_hardware_speedup/&quot;&gt;查看地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;从 demo 中可以看到左边的图形在运动时外层有一圈绿色的边框，表示元素不停地 repaint，并且可以看到其运动过程中有丢帧现象，具体表现为运动不连贯，有轻微闪动。&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="https://lz5z.com/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="动画" scheme="https://lz5z.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="CSS" scheme="https://lz5z.com/tags/CSS/"/>
    
      <category term="GPU" scheme="https://lz5z.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Web 性能优化-页面重绘和回流（重排）</title>
    <link href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%A1%B5%E9%9D%A2%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"/>
    <id>https://lz5z.com/Web性能优化-页面重绘和回流/</id>
    <published>2018-05-02T21:46:24.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>前言</h2><p>早在五年前，Google 就提出了 1s 完成终端页面的首屏渲染的标准。</p><img src="/assets/img/google_atf.png" alt="google_atf"><p>常见的优化网络请求的方法有：DNS Lookup，减少重定向，避免 JS、CSS 阻塞，并行请求，代码压缩，缓存，按需加载，前端模块化…</p><a id="more"></a><p>虽然相较于网络方面的优化，前端渲染的优化显得杯水车薪，而且随着浏览器和硬件性能的增长，再加上主流前端框架（react、vue、angular）的已经帮我们解决了大多数的性能问题，但是前端渲染性能优化依然值得学习，除去网络方面的消耗，留给前端渲染的时间已经不多了。本文主要学习前端渲染相关的问题。</p><h2>浏览器是如何渲染一个页面的</h2><blockquote><ol><li>浏览器把获取到的 HTML 代码解析成1个 DOM 树，HTML 中的每个 tag 都是 DOM 树中的1个节点，根节点是 document 对象。DOM 树里包含了所有 HTML 标签，包括 <code>display:none</code> 隐藏的标签，还有用 JS 动态添加的元素等。</li><li>浏览器把所有样式解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如 IE 会去掉 -moz 开头的样式。</li><li>DOM Tree 和样式结构体组合后构建 render tree, render tree 类似于 DOM tree，但区别很大，render tree 能识别样式，render tree 中每个 NODE 都有自己的 style，而且 render tree 不包含隐藏的节点 (比如 <code>display:none</code> 的节点，还有 head 节点)，因为这些节点不会用于呈现，而且不会影响呈现的节点，所以就不会包含到 render tree 中。注意 <code>visibility:hidden</code> 隐藏的元素还是会包含到 render tree 中的，因为 <code>visibility:hidden</code> 会影响布局(layout)，会占有空间。根据 CSS2 的标准，render tree 中的每个节点都称为 Box (Box dimensions)，理解页面元素为一个具有填充、边距、边框和位置的盒子。</li><li>一旦 render tree 构建完毕后，浏览器就可以根据 render tree 来绘制页面了。</li></ol></blockquote><p>总结为下图：</p><img src="/assets/img/web_repaint_reflow.png" alt="web_repaint_reflow"><p>图片来自 <a href="https://segmentfault.com/a/1190000010298038" target="_blank" rel="noopener">浏览器渲染页面过程与页面优化</a></p><p>在此过程中，前端工程师主要的敌人为：</p><ol><li>重新计算样式（Recalculate Style）、计算布局（Layout）=&gt; Rendering/Reflow。</li><li>绘制 =&gt; Painting/Repaint。</li></ol><h3>重绘与回流</h3><ol><li>当 render tree 中的一部分（或全部）因为元素的规模尺寸、布局、显示/隐藏等改变而需要重新构建，这个过程称作回流（reflow）。页面第一次加载的时候，至少发生一次回流。</li><li>当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color，这个过程叫做重绘（repaint）</li></ol><p>在回流的时候，浏览器会使 render tree 中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。因此<strong>回流必将引起重绘，而重绘不一定会引起回流。</strong></p><p>Reflow 的成本比 Repaint 高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。</p><h3>在 chrome 中查看 repaint</h3><p>F12 打开控制台 -&gt; DevTools -&gt; Show console drawer -&gt; Rendering -&gt; 勾选 Paint flashing。</p><h3>重绘何时发生</h3><p>当一个元素的外观的可见性 visibility 发生改变的时候，但是不影响布局。类似的例子包括：outline, visibility, background color。</p><h3>回流何时发生</h3><ol start="0"><li>页面渲染初始化。</li><li>调整窗口大小。</li><li>改变字体，比如修改网页默认字体。</li><li>增加或者移除样式表。</li><li>内容变化，比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。</li><li>激活 CSS 伪类，比如 :hover</li><li>操作 class 属性。</li><li>脚本操作 DOM，增加删除或者修改 DOM 节点，元素尺寸改变——边距、填充、边框、宽度和高度。</li><li>计算 offsetWidth 和 offsetHeight 属性。</li><li>设置 style 属性的值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style</span><br><span class="line">s.padding = <span class="string">"2px"</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span> <span class="comment">// 重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span> <span class="comment">// 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>)) <span class="comment">// 回流+重绘</span></span><br></pre></td></tr></table></figure><h3>浏览器</h3><p>如果向上述代码中那样，浏览器不停地回流+重绘，很可能性能开销非常大，实际上浏览器会优化这些操作，将所有引起回流和重绘的操作放入一个队列中，等待队列达到一定的数量或者时间间隔，就 flush 这个队列，一次性处理所有的回流和重绘。</p><p>虽然有浏览器优化，但是当我们向浏览器请求一些 style 信息的时候，浏览器为了确保我们能拿到精确的值，就会提前 flush 队列。</p><ol><li>offsetTop/Left/Width/Height</li><li>scrollTop/Left/Width/Height</li><li>clientTop/Left/Width/Height</li><li>width,height</li><li>getComputedStyle(), 或者 IE的 currentStyle</li></ol><h3>减少回流重绘</h3><ul><li><p>requestAnimationFrame：能保证浏览器在正确的时间进行渲染。</p></li><li><p>保持 DOM 操作“原子性”：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> newWidth = ele.offsetWidth + <span class="number">10</span></span><br><span class="line">ele.style.width = newWidth + <span class="string">'px'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newHeight = ele.offsetHeight + <span class="number">10</span></span><br><span class="line">ele.style.height = newHeight + <span class="string">'px'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good 读写分离，批量操作</span></span><br><span class="line"><span class="keyword">var</span> newWidth = ele.offsetWidth + <span class="number">10</span> <span class="comment">// read</span></span><br><span class="line"><span class="keyword">var</span> newHeight = ele.offsetHeight + <span class="number">10</span> <span class="comment">// read</span></span><br><span class="line">ele.style.width = newWidth + <span class="string">'px'</span> <span class="comment">// write</span></span><br><span class="line">ele.style.height = newHeight + <span class="string">'px'</span> <span class="comment">// write</span></span><br></pre></td></tr></table></figure><ul><li>使用 classList 代替 className：</li></ul><p>className 只要赋值，就一定出现一次 rendering 计算；classList 的 add 和 remove，浏览器会进行样式名是否存在的判断，以减少重复的 rendering。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ele.className += <span class="string">'something'</span></span><br><span class="line">ele.classList.add(<span class="string">'something'</span>)</span><br><span class="line">ele.classList.remove(<span class="string">'something'</span>)</span><br></pre></td></tr></table></figure><ul><li>批量操作借助临时变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  el.style.left = el.offsetLeft + <span class="number">5</span> + <span class="string">'px'</span></span><br><span class="line">  el.style.top = el.offsetTop + <span class="number">5</span> + <span class="string">'px'</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> left = el.offsetLeft</span><br><span class="line"><span class="keyword">let</span> top = el.offsetTop</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  left += <span class="number">5</span></span><br><span class="line">  top += <span class="number">5</span> </span><br><span class="line">&#125;</span><br><span class="line">el.style.left = left + <span class="string">'px'</span></span><br><span class="line">el.style.top = left + <span class="string">'px'</span></span><br></pre></td></tr></table></figure><ul><li>对元素进行“离线操作”，完成后再一起更新：</li></ul><ol><li>使用 DocumentFragment 进行缓存操作,引发一次回流和重绘 <a href="http://www.cnblogs.com/blueSkys/p/3685740.html" target="_blank" rel="noopener">了解DocumentFragment 给我们带来的性能优化</a></li><li>元素操作前使用 <code>display: none</code>，完成后再将其显示出来，这样只会触发一次回流和重绘。</li><li>使用 cloneNode + replaceChild 技术，引发一次回流和重绘。</li></ol><p>假如需要在下面的 html 中添加两个 li 节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.getElementByTagName(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">let</span> man = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">man.innerHTML = <span class="string">'man'</span></span><br><span class="line">ul.appendChild(li)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> woman = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">woman.innerHTML = <span class="string">'woman'</span></span><br><span class="line">ul.appendChild(woman)</span><br></pre></td></tr></table></figure><p>上述代码会发生两次回流，假如使用 <code>display: none</code> 的方案，虽然能够减少回流次数，但是会发生一次闪烁，这时候使用 DocumentFragment 的优势就体现出来了。</p><p>DocumentFragment 有两大特点：</p><ol><li>DocumentFragment 节点不属于文档树，继承的 parentNode 属性总是 null。</li><li>当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。这使得 DocumentFragment 成了有用的占位符，暂时存放那些一次插入文档的节点。它还有利于实现文档的剪切、复制和粘贴操作。、</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">let</span> woman = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">man.innerHTML = <span class="string">'man'</span></span><br><span class="line">woman.innerHTML = <span class="string">'woman'</span></span><br><span class="line">fragment.appendChild(man)</span><br><span class="line">fragment.appendChild(woman)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(spanNode)</span><br></pre></td></tr></table></figure><p>可见 DocumentFragment 是一个孤儿节点，没爹就能出生，但是在需要它的时候，它又无私地把孩子奉献给文档树，然后自己默默离开。是不是有点像《银翼杀手2049》？</p><h2>参考资料</h2><ul><li><a href="http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf" target="_blank" rel="noopener">16毫秒的优化<br></a></li><li><a href="https://segmentfault.com/a/1190000010298038" target="_blank" rel="noopener">浏览器渲染页面过程与页面优化</a></li><li><a href="http://www.css88.com/archives/4996" target="_blank" rel="noopener">页面重绘和回流以及优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;前言&lt;/h2&gt;&lt;p&gt;早在五年前，Google 就提出了 1s 完成终端页面的首屏渲染的标准。&lt;/p&gt;&lt;img src=&quot;/assets/img/google_atf.png&quot; alt=&quot;google_atf&quot;&gt;&lt;p&gt;常见的优化网络请求的方法有：DNS Lookup，减少重定向，避免 JS、CSS 阻塞，并行请求，代码压缩，缓存，按需加载，前端模块化…&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="https://lz5z.com/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="CSS" scheme="https://lz5z.com/tags/CSS/"/>
    
      <category term="重绘" scheme="https://lz5z.com/tags/%E9%87%8D%E7%BB%98/"/>
    
      <category term="回流" scheme="https://lz5z.com/tags/%E5%9B%9E%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 垃圾回收</title>
    <link href="https://lz5z.com/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://lz5z.com/JavaScript垃圾回收/</id>
    <published>2018-04-25T18:01:21.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>垃圾回收</h2><p>JavaScript 具有自动垃圾回收机制，这种垃圾回收机制原理其实很简单：找出那些不再继续使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时间间隔周期性地执行这一操作。局部变量只有在函数执行的过程中存在，在这个过程中，会为局部变量在栈（或者堆）内存上分配空间，然后在函数中使用这些变量，直至函数执行结束。垃圾回收器必须追踪哪个变量有用哪个没用，对于不再有用的变量打上标记，以备将来回收其占用的内存，用于标识无用变量的策略主要有标记清除法和引用计数法。</p><a id="more"></a><h3>JavaScript 内存分配</h3><p>JavaScript 在定义变量时就完成了内存分配，还可以通过函数调用分配内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 值的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span> <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span></span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数调用分配内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>) <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p><h3>mark and sweep</h3><p>JavaScript 中最常用的垃圾回收方式就是标记清除（mark-and-sweep），当变量进入环境时，就将这个变量标记“进入环境”，当变量离开环境时，就将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等。</p><img src="/assets/img/gc_mark_sweep.gif" alt="gc_mark_sweep"><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后它会去掉环境中的变量已经被环境中变量被标记为引用的变量，在此之后再被标记的变量将被视为准备删除的变量。最后垃圾回收器清除标记的变量，回收它们所占用的内存空间。</p><p>目前主流浏览器都是使用标记清除式的垃圾回收策略，只不过收集的间隔有所不同。</p><h3>引用计数（refefence counting）</h3><p>引用计数跟踪几个每个值被引用的次数，当声明一个引用类型值赋给该变量时，则这个值的引用次数就是 1，如果同一个值被赋给另外一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，就可以将其内存空间回收。当垃圾回收器再次运行时，它就会释放哪些引用次数为 0 的值所占用的内存。</p><p>Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，它很快就遇到一个严重的问题：循环引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">  obj1.someOtherObj = obj2</span><br><span class="line">  obj2.anotherObj = obj1    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，obj1 和 obj2 通过各自的属性相互引用，也就是说，这两个对象的引用次数都是 2。在采用标记清除策略的现实中，由于函数执行后，两个对象都离开了作用域，因此相互引用不存在问题。</p><p>但是在引用计数策略中，当函数执行完毕后，obj1 和 obj2 还得继续存在，因为它们的引用次数永远不会是 0，导致内存无法回收。</p><p>Netscape Navigator 4.0 中放弃了引用计数，转而使用标记清除来实现垃圾回收。</p><p>IE 存在的问题：</p><p>在 IE9 之前，IE 中有一部分对象并不是原生 JavaScript 对象。例如，BOM 和 DOM 中的对象就是 C++ 实现的 COM 对象，而 COM 对象的垃圾收集机制采用的是引用计数策略。因此，即使 IE 中的 JavaScript 引擎使用标记清除策略实现，但是 JS 访问的 COM 对象依然是基于引用计数策略的。可以在 IE 中涉及到 COM 对象，就会存在循环引用的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'some_element'</span>)</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.ele = ele</span><br><span class="line">ele.someObj = obj</span><br></pre></td></tr></table></figure><p>在这个例子中一个 DOM 元素与一个原生 JS 对象之间创建了循环引用，由于 COM 的引用计数的垃圾回收策略，导致例子中的 DOM 从页面删除，也不会被垃圾回收。</p><p>解决办法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.ele = <span class="literal">null</span></span><br><span class="line">ele.someObj = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>将变量设置为 null 意味着切断变量和它此前引用值之间的连接。当垃圾回收器下次运行时，就能删除这些值并回收它们占用的内存。</p><p>IE9 之后，DOM 和 BOM 对象都被转换成立真正的 JS 对象，这样就避免了两种垃圾回收算法并存导致的问题。</p><h3>性能问题</h3><p>垃圾收集器是周期性运行，因此其运行时间间隔是一个非常重要的问题。IE7 之前的垃圾收集器是根据内存分配量运行的，达到某一个临界值（256 个变量，4096 个对象、或者 64 KB 字符串）就是启动垃圾回收器，这导致了一个问题：如果该脚本在其生命周期需要一直保持这么多变量，垃圾回收器就不得不频繁运行。</p><p>事实上，浏览器中一般可以主动触发垃圾收集过程。在 IE 中，调用 <code>window.CollectGarbage()</code> 方法会立即执行垃圾收集，在 Opera7 之后的版本中，调用 <code>window.opera.collect()</code> 也会启动垃圾收集。</p><h3>优化内存</h3><p>比较好的办法就是执行代码中只保留必要的数据，一旦数据不再有用，通过设置为 null 来释放其引用（dereferencing），适用于大多数全局变量和全局对象的属性。</p><h2>V8 内存机制</h2><p>V8 引擎会限制 JavaScript 所能使用的内存大小，64 位系统是 1.4GB，32 位系统是 0.7GB。在 Node 环境中使用下面两个参数可以调整启动时内存限制的大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --max-nex-space-size=1024 app.js // 单位为KB</span><br><span class="line">node --max-old-space-size=2000 app.js // 单位为MB</span><br></pre></td></tr></table></figure><p>这两条命令分别对应 Node 内存堆中的「新生代」和「老生代」</p><h3>V8 的堆构成</h3><p>V8 将堆分为了几个不同的区域：</p><ul><li>新生区：大多数对象被分配在这里。新生区是一个很小的区域，垃圾回收在这个区域非常频繁，与其他区域相独立。</li><li>老生指针区：这里包含大多数可能存在指向其他对象的指针的对象。大多数在新生区存活一段时间之后的对象都会被挪到这里。<br>老生数据区：这里存放只包含原始数据的对象（这些对象没有指向其他对象的指针）。字符串、封箱的数字以及未封箱的双精度数字数组，在新生区存活一段时间后会被移动到这里。</li><li>大对象区：这里存放体积超越其他区大小的对象。每个对象有自己 mmap 产生的内存。垃圾回收器从不移动大对象。<br>-代码区：代码对象，也就是包含 JIT 之后指令的对象，会被分配到这里。这是唯一拥有执行权限的内存区（不过如果代码对象因过大而放在大对象区，则该大对象所对应的内存也是可执行的。译注：但是大对象内存区本身不是可执行的内存区）。<br>-Cell 区、属性 Cell 区、Map 区：这些区域存放 Cell、属性 Cell 和 Map，每个区域因为都是存放相同大小的元素，因此内存结构很简单。</li></ul><h3>分代回收</h3><p>脚本中，绝大多数对象的生存期很短，只有某些对象的生存期较长。为利用这一特点，V8将堆进行了分代。对象起初会被分配在新生区（通常很小，只有 1-8 MB，具体根据行为来进行启发）。在新生区的内存分配非常容易：我们只需保有一个指向内存区的指针，不断根据新对象的大小对其进行递增即可。当该指针达到了新生区的末尾，就会有一次清理（小周期），清理掉新生区中不活跃的死对象。对于活跃超过 2 个小周期的对象，则需将其移动至老生区。老生区在标记－清除或标记－紧缩（大周期）的过程中进行回收。大周期进行的并不频繁。一次大周期通常是在移动足够多的对象至老生区后才会发生。至于足够多到底是多少，则根据老生区自身的大小和程序的动向来定。</p><h2>参考资料</h2><ul><li>《JavaScript 高级程序设计》</li><li><a href="http://newhtml.net/v8-garbage-collection/" target="_blank" rel="noopener">V8 之旅： 垃圾回收器</a></li><li><a href="https://segmentfault.com/a/1190000004934938" target="_blank" rel="noopener">NodeJS中被忽略的内存</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;垃圾回收&lt;/h2&gt;&lt;p&gt;JavaScript 具有自动垃圾回收机制，这种垃圾回收机制原理其实很简单：找出那些不再继续使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时间间隔周期性地执行这一操作。局部变量只有在函数执行的过程中存在，在这个过程中，会为局部变量在栈（或者堆）内存上分配空间，然后在函数中使用这些变量，直至函数执行结束。垃圾回收器必须追踪哪个变量有用哪个没用，对于不再有用的变量打上标记，以备将来回收其占用的内存，用于标识无用变量的策略主要有标记清除法和引用计数法。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="GC" scheme="https://lz5z.com/tags/GC/"/>
    
      <category term="V8" scheme="https://lz5z.com/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 常见的内存泄漏</title>
    <link href="https://lz5z.com/JavaScript-Memory-Leaks/"/>
    <id>https://lz5z.com/JavaScript-Memory-Leaks/</id>
    <published>2018-04-23T22:07:24.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>什么是内存泄漏</h2><p>JavaScript 是一种垃圾回收语言，垃圾回收语言通过周期性地检查之前被分配的内存是否可以从应用的其它部分访问来帮助开发者管理内存。内存泄露是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。</p><a id="more"></a><h3>查看内存泄漏</h3><p>在 chrome 中可以通过 performance 中的 Memory record 来查看，选中 Memory 后点击左边的 Record，然后模拟用户的操作，一段时间后点击 stop，在面板上查看这段时间的内存占用情况。如果内存基本平稳，则无内存泄漏情况；如果内存占用不断飙升，内可能出现内存泄漏的情况。</p><p>在 Node 环境中，可以输入 <code>process.memoryUsage()</code> 查看 Node 进程的内存占用情况。</p><ul><li>rss（resident set size）：进程的常驻内存部分。</li><li>heapTotal：&quot;堆&quot;占用的内存，包括用到的和没用到的。</li><li>heapUsed：用到的堆的部分。</li><li>external： V8 引擎内部的 C++ 对象占用的内存。</li></ul><p>判断内存泄漏，以 heapUsed 字段为准。</p><h2>常见的内存泄漏</h2><p>《JavaScript高级程序设计》中提到了一种内存泄漏：由于 IE9 之前的版本对 JS 对象和 DOM 对象中使用的垃圾回收机制，会导致如果闭包的作用域链中保存着一个 HTML 元素，那该元素将无法销毁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>)</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(element.id)</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用，匿名函数中保存了一个对 element 对象的引用，因此无法减少 element 的引用数。只要匿名函数在，element 的引用数至少是 1，因此它所占用的内存就永远无法回收。</p><p>解决办法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>)</span><br><span class="line">  <span class="keyword">var</span> id = element.id</span><br><span class="line">  element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(id)</span><br><span class="line">  &#125;</span><br><span class="line">  element = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 上述问题在现代浏览器上并不会出现</p></blockquote><h3>意外的全局变量</h3><p>在 JavaScript 非<a href="https://lz5z.com/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">严格模式</a>中，未定义的变量会自动绑定在全局对象上（window/global），比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar = <span class="string">'something'</span>    </span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>foo 执行的时候，由于内部变量没有定义，所以相当于 <code>window.bar = 'something'</code>，函数执行完毕，本应该被销毁的变量 bar 却永久的保留在内存中了。</p><p>解决办法，使用<a href="https://lz5z.com/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">严格模式</a>。</p><p>虽然全局变量上绑定的变量无法被垃圾回收，但是有时需要使用全局变量去存储临时信息，这个时候要格外小心，并在变量使用完毕后设置为 null，以回收内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.bar = <span class="literal">null</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.bar</span><br></pre></td></tr></table></figure><p>下面写一个 demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">    <span class="built_in">window</span>[<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>`</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  test()</span><br><span class="line">  setTimeout(grow, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onload = grow()</span><br></pre></td></tr></table></figure><p>将这段脚本放置于浏览器中，打开 chrome performance，记录一段时间后，发现内存线条如下：</p><img src="/assets/img/js-memory-leak.png" alt="js-memory-leak"><p>同时打开 chrome 任务管理器，会看到代表当前页面的标签页所占用的内存不断飙升。</p><h3>JS 错误引用 DOM 元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodes = <span class="string">''</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> item = &#123;</span><br><span class="line">    name: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  nodes = <span class="built_in">document</span>.getElementById(<span class="string">'nodes'</span>)</span><br><span class="line">  nodes.item = item</span><br><span class="line">  nodes.parentElement.removeChild(nodes)</span><br><span class="line"> &#125;)()</span><br></pre></td></tr></table></figure><p>这里的 dom 元素虽然已经从页面上移除了，但是 js 中仍然保存这对该 dom 元素的引用，导致内存不能释放。</p><p>打开 chrome 控制台 Memory，点击 <code>Take snapshot</code>：</p><img src="/assets/img/js-memory-leak-profile.png" alt="js-memory-leak-profile"><p>点击生成的 Snapshot，通过关键字 <code>str</code> 进行 filter：</p><img src="/assets/img/js-memory-leak-snapshot.png" alt="js-memory-leak-snapshot"><p>从上图可知，代码运行结束后，内存中的长字符串依然没有被垃圾回收。</p><h3>闭包循环引用</h3><p><a href="https://lz5z.com/JavaScript%E9%97%AD%E5%8C%85/">闭包</a>是指函数能够访问父环境中定义的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> originalBar = bar</span><br><span class="line">    <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> originalBar</span><br><span class="line">    &#125;</span><br><span class="line">    bar = &#123;</span><br><span class="line">      longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>),</span><br><span class="line">      someMethod() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setInterval(foo, <span class="number">100</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上面代码中的 unused 是一个闭包，因为其内部引用了父环境中的变量 originalBar，虽然它被没有使用，但 v8 引擎并不会把它优化掉，因为 JavaScript 里存在 eval 函数，所以 v8 引擎并不会随便优化掉暂时没有使用的函数。</p><p>需要注意的一点是： <strong>闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的</strong>。</p><p>bar 引用了someMethod，someMethod 这个函数与 unused 这个闭包共享一个闭包上下文。所以 someMethod 也引用了 originalBar 这个变量。</p><p>因此引用链如下：</p><p>GCHandler -&gt; foo -&gt; bar -&gt; someMethod -&gt; originalBar -&gt; someMethod(old) -&gt; originalBar(older)-&gt; someMethod(older)</p><p>造成了闭包的循环引用。</p><img src="/assets/img/js-memory-leak-clouser.png" alt="js-memory-leak-clouser"><h2>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000008901861" target="_blank" rel="noopener">javascript典型内存泄漏及chrome的排查方法</a></li><li>《JavaScript高级程序设计》</li><li><a href="https://github.com/wengjq/Blog/issues/1" target="_blank" rel="noopener">4种JavaScript内存泄漏浅析及如何用谷歌工具查内存泄露</a></li><li><a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" target="_blank" rel="noopener">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;什么是内存泄漏&lt;/h2&gt;&lt;p&gt;JavaScript 是一种垃圾回收语言，垃圾回收语言通过周期性地检查之前被分配的内存是否可以从应用的其它部分访问来帮助开发者管理内存。内存泄露是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="内存泄漏" scheme="https://lz5z.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="Memory Leaks" scheme="https://lz5z.com/tags/Memory-Leaks/"/>
    
  </entry>
  
  <entry>
    <title>Vim 学习</title>
    <link href="https://lz5z.com/vim-study/"/>
    <id>https://lz5z.com/vim-study/</id>
    <published>2018-04-19T13:09:32.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容来自 vimtutor(v1.7)，在 Unix 系统下输入 “vimtutor” 即可进入教学模型。这里记录下来学习点滴，方便以后查看。</p><h2>Vim 简介</h2><p>Vim 是一款由 Vi 派生出来的命令行编辑器，具有语法高亮、代码折叠、多语言支持、多视图等强大的功能，并且支持插件扩展和调用脚本语言。Vim 有多种模式，其中最常用的为插入和执行模式，仅仅通过键盘来在这些模式之中切换，大大提高了程序开发效率。</p><h2>Vim 使用</h2><h3>移动光标</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要移动光标使用 h、j、k、l 键</span><br><span class="line">     ^</span><br><span class="line">     k        </span><br><span class="line">&lt; h       l &gt;</span><br><span class="line">     j</span><br><span class="line">     v</span><br></pre></td></tr></table></figure><a id="more"></a><h3>Vim 进入和退出</h3><p>通过 Vim + 文件名进去文件后，默认为普通模式。注意进入普通模式后请勿开启 Shift-Lock(大小写锁定键)。</p><p>退出 Vim，按<esc>键，然后输入 <code>:q!</code> &lt;回车&gt;。 这种方式退出编辑器会丢弃进入编辑器以来所做的改动。</esc></p><h3>文本编辑-删除</h3><p>在普通模式下，按 x 键来删除光标所在位置的字符。</p><h3>文本编辑-插入</h3><p>在普通模式下，按 i 键来插入文本。</p><h3>文本编辑-添加</h3><p>按 a 键来添加文本。</p><p>插入与添加直接的区别：</p><p>插入是在光标前插入文本，添加光标字母后面添加。</p><h3>编辑文件</h3><p>使用 <code>:wq</code> 以保存文件并退出</p><h3>删除类命令</h3><p>输入 <code>dw</code> 可以从光标处删除至一个单词的末。</p><p>输入 <code>d$</code> 从当前光标删除到行末。</p><p>输入 <code>de</code> 从当前光标当前位置直到单词末尾，包括最后一个字符。</p><p>输入 <code>dd</code> 删除整行。</p><p>输入 <code>2dd</code> 删除两行。</p><h3>移动光标</h3><p>输入 <code>2w</code> 使光标向后移动两个单词。</p><p>输入 <code>3e</code> 使光标向后移动到第三个单词的末尾。</p><p>比如之前的光标位置为：</p><p>—&gt; |this is a demo.</p><p>输入 <code>2w</code>:</p><p>—&gt; this is |a demo.</p><p>输入 <code>2e</code>:</p><p>—&gt; this i|s a demo.</p><h3>计数删除</h3><p>—&gt; |this is a demo</p><p><code>d2w</code>: —&gt; |a demo.</p><p><code>d2e</code>: —&gt; | a demo.</p><h3>撤销</h3><p>输入 <code>u</code> 来撤消最后执行的命令。</p><p>输入 <code>U</code> 来撤消对整行的修改。</p><p>使用 <code>CTRL-R</code> （先按 CTRL 再按 R）撤销撤销命令。</p><h2>删除与粘贴</h2><p>删除操作后，输入 <code>p</code> 将最后一次删除的内容置入光标之后。</p><h2>替换</h2><p>输入 <code>r</code> 加字符替换光标后一个字符。</p><h2>更改</h2><p>要改变文本直到一个单词的末尾，请输入 <code>ce</code>。</p><p><code>ce</code> 命令相当于删除一个单词的同时，进入插入模式。</p><p>使用 <code>c2w</code> 删除两个单词并且进入插入模式。</p><p>使用 <code>c$</code> 删除光标后所有内容并且进入插入模式。</p><h3>文件定位</h3><p>输入 <code>CTRL-G</code> 显示当前编辑文件中当前光标所在行位置以及文件状态信息。</p><p>输入行号 + G (注意是大写) 可以直接将光标定位于行数。</p><h3>文件搜索</h3><p>输入 <code>/</code> 加上字符串，可以在当前文件中查找该字符串。</p><p>要查找同上一次的字符串，只需要按 <code>n</code> 键。要向相反方向查找同上一次的字符串，请输入大写 <code>N</code> 即可。</p><p>回到之前的位置按 <code>CTRL-O</code>，重复按可以回退更多步。CTRL-I 会跳转到较新的位置。</p><p>提示：如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非 ‘wrapscan’ 选项被复位。</p><h3>配对括号的查找</h3><p>把光标置于有括号（ (、[ 或 { ）的地方，按下 <code>%</code> 光标会自动定位到与其配对的括号处。</p><h3>替换命令</h3><p>在一行内替换头一个字符串 old 为新的字符串 new，输入 <code>:s/old/new</code>。</p><p>在一行内替换所有的字符串 old 为新的字符串 new，输入 <code>:s/old/new/g</code>。</p><p>在两行内替换所有的字符串 old 为新的字符串 new，输入 <code>:#,#s/old/new/g</code>，其中 #, # 代表的是替换操作的若干行中首尾两行的行号。</p><p>在文件内替换所有的字符串 old 为新的字符串 new，输入 <code>:%s/old/new/g</code></p><p>进行全文替换时询问用户确认每个替换需添加 c 标志 <code>:%s/old/new/gc</code></p><h3>Vim 中执行外部命令</h3><p>输入 <code>:!</code> 然后紧接着输入一个外部命令可以执行该外部命令，比如 <code>:!ls</code> 可以在 Vim 中查看当前目录。</p><h3>文件保存</h3><p>要将对文件的改动保存到文件中，请输入 <code>:w FILENAME</code>。 该命令会以 FILENAME 为文件名保存整个文件。</p><h3>选择性保存</h3><p>移动光标至某一行，按下 <code>v</code> 键进入可视模式，移动光标选中内容，然后按 <code>:</code>，屏幕底部会出现 <code>:'&lt;,'&gt;</code>，再输入 <code>w FILENAME</code> 可将选中的内容报错到 FILENAME 中。</p><p>提示：按 v 键使 Vim 进入可视模式进行选取。可以四处移动光标使选取区域变大或变小。接着可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除选中的文本内容。</p><h3>提取和合并文件</h3><p>要向当前文件中插入另外的文件的内容，请输入 <code>:r FILENAME</code>。</p><p><code>:r FILENAME</code> 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的内容来自 vimtutor(v1.7)，在 Unix 系统下输入 “vimtutor” 即可进入教学模型。这里记录下来学习点滴，方便以后查看。&lt;/p&gt;&lt;h2&gt;Vim 简介&lt;/h2&gt;&lt;p&gt;Vim 是一款由 Vi 派生出来的命令行编辑器，具有语法高亮、代码折叠、多语言支持、多视图等强大的功能，并且支持插件扩展和调用脚本语言。Vim 有多种模式，其中最常用的为插入和执行模式，仅仅通过键盘来在这些模式之中切换，大大提高了程序开发效率。&lt;/p&gt;&lt;h2&gt;Vim 使用&lt;/h2&gt;&lt;h3&gt;移动光标&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;要移动光标使用 h、j、k、l 键&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     k        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt; h       l &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     j&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     v&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://lz5z.com/categories/Tools/"/>
    
    
      <category term="Vim" scheme="https://lz5z.com/tags/Vim/"/>
    
      <category term="vimtutor" scheme="https://lz5z.com/tags/vimtutor/"/>
    
  </entry>
  
  <entry>
    <title>使用 requestAnimationFrame 实现动画</title>
    <link href="https://lz5z.com/requestAnimationFrame/"/>
    <id>https://lz5z.com/requestAnimationFrame/</id>
    <published>2018-04-14T18:24:28.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>如何实现一个动画</h2><p>我们来实现一个最简单的需求，将一个元素从屏幕左边均匀地移动到屏幕右边。</p><p>下面是效果:</p><!DOCTYPE html><html lang="en"><head><style>.animate-warpper{width:100%;height:70px}@keyframes move_animation{0%{left:0}100%{left:calc(100% - 60px)}}.animate-div{width:60px;height:40px;position:absolute;left:0;border-radius:5px;background:#92B901;transform:translateZ(0);-webkit-transform:translateZ(0);animation:move_animation 5s linear 2s infinite alternate}</style></head><body><section class="animate-warpper"><div class="animate-div"></div></section></body></html><a id="more"></a><p>（1）css animation</p><p>用 css 实现是最合理也是最高效的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> move_animation1 &#123;</span><br><span class="line">  0% &#123; <span class="attribute">left</span>: <span class="number">0px</span>; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">left</span>: <span class="built_in">calc</span>(100% - 60px); &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> move_animation &#123;</span><br><span class="line">  0% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(0); &#125;</span><br><span class="line">  50% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(250px); &#125;</span><br><span class="line">  100% &#123; <span class="attribute">transform</span>: <span class="built_in">translateX</span>(500px)); &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.animate-div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#92B901</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  <span class="attribute">animation</span>: move_animation <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>transform:translateZ(0);</code> 用来开启 chrome GPU 加速，解决动画”卡顿”。<br>在动画中使用 transform 比 left/top 性能更好，能减少浏览器 repaint。</p></blockquote><p>（2）假如用 JS 实现呢</p><p>首先想到的是 setInterval/setTimeout，原理就是利用人眼的视觉残留和电脑屏幕的刷新，让元素以连贯平滑的方式逐步改变位置，最终实现动画的效果。</p><p>常用的屏幕刷新频率为 60Hz，一些电竞屏幕则为 144Hz。我们以常用的刷新频率为例，60Hz 意味着屏幕每 1000 / 60 ≈ 16.7ms 刷新一次，所以我们设置 setInterval 的间隔为 16.7ms：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animateDiv = <span class="built_in">document</span>.querySelector(<span class="string">'.animate-div'</span>)</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> inter = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  animateDiv.style.left = <span class="number">1</span>/<span class="number">3</span> * (++i) + <span class="string">'%'</span></span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">300</span>) clearInterval(inter)</span><br><span class="line">&#125;, <span class="number">16.7</span>)</span><br></pre></td></tr></table></figure><p>setInterval/setTimeout 存在两个问题：</p><blockquote><ul><li>setTimeout 的执行时间并不是确定的。在 Javascript 中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。</li><li>刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li></ul></blockquote><p>以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 虽然在上述代码中我们将时间间隔设置为 16.7ms，但是还是不能完全避免丢帧的现象。</p><p>（3）requestAnimationFrame</p><p>requestAnimationFrame 与 setTimeout/setInterval 最大的区别是由系统自己的刷新机制来决定什么时候调用动画函数，开发者只需要定义好动画函数，这个函数会在浏览器重绘之前调用。</p><h2>requestAnimationFrame 简介</h2><p>requestAnimationFrame 接收一个回调函数作为参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp" target="_blank" rel="noopener">DOMHighResTimeStamp</a>，指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。回调函数中传入时间戳作为参数，该时间戳是一个十进制数，单位毫秒，最小精度为 1ms。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animateDiv = <span class="built_in">document</span>.querySelector(<span class="string">'.animate-div'</span>)</span><br><span class="line"><span class="keyword">let</span> start = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!start) start = timestamp</span><br><span class="line">    <span class="keyword">let</span> progress = timestamp - start</span><br><span class="line">    animateDiv.style.left = progress + <span class="string">'px'</span></span><br><span class="line">    <span class="keyword">if</span> (progress &lt; <span class="number">350</span>) &#123;</span><br><span class="line">        <span class="comment">// 在动画没有结束前，递归渲染</span></span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(step)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一帧渲染</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(step)</span><br></pre></td></tr></table></figure><h3>requestAnimationFrame 优势</h3><p>除了精准控制调用时机以外，requestAnimationFrame 还有两大优点：</p><ul><li>运行在后台标签页或者隐藏的 iframe 里时，requestAnimationFrame() 暂停调用以提升性能和电池寿命。</li><li>函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 requestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次。</li></ul><h3>cancelAnimationFrame</h3><p>取消一个先前通过调用 window.requestAnimationFrame()方法返回的动画帧请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animateDiv = <span class="built_in">document</span>.querySelector(<span class="string">'.animate-div'</span>)</span><br><span class="line"><span class="keyword">const</span> requestAnimationFrame = <span class="built_in">window</span>.requestAnimationFrame || <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">  <span class="built_in">window</span>.webkitRequestAnimationFrame || <span class="built_in">window</span>.msRequestAnimationFrame</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cancelAnimationFrame = <span class="built_in">window</span>.cancelAnimationFrame || <span class="built_in">window</span>.mozCancelAnimationFrame</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> myReq = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> progress = timestamp - start</span><br><span class="line">  animateDiv.style.left = progress + <span class="string">'px'</span></span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    myReq = requestAnimationFrame(step)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myReq = requestAnimationFrame(step)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.cancelAnimationFrame(myReq)</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><h3>优雅降级</h3><p>requestAnimationFrame 目前还存在兼容性问题，使用 <a href="https://github.com/darius/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame polyfill</a> 来进行优雅降级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Date</span>.now)</span><br><span class="line">    <span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); &#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; ++i) &#123;</span><br><span class="line">        <span class="keyword">let</span> vp = vendors[i];</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vp+<span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = (<span class="built_in">window</span>[vp+<span class="string">'CancelAnimationFrame'</span>]</span><br><span class="line">                                   || <span class="built_in">window</span>[vp+<span class="string">'CancelRequestAnimationFrame'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/iP(ad|hone|od).*OS 6/</span>.test(<span class="built_in">window</span>.navigator.userAgent) <span class="comment">// iOS6 is buggy</span></span><br><span class="line">        || !<span class="built_in">window</span>.requestAnimationFrame || !<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">        <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">            <span class="keyword">let</span> nextTime = <span class="built_in">Math</span>.max(lastTime + <span class="number">16</span>, now);</span><br><span class="line">            <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; callback(lastTime = nextTime); &#125;,</span><br><span class="line">                              nextTime - now);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">window</span>.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN-CSS requestAnimationFrame</a></li><li><a href="http://mp.weixin.qq.com/s/_m1flYySn6sgAROYbXqltg" target="_blank" rel="noopener">深入理解 requestAnimationFrame</a></li><li><a href="https://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html" target="_blank" rel="noopener">CSS动画之硬件加速</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;如何实现一个动画&lt;/h2&gt;&lt;p&gt;我们来实现一个最简单的需求，将一个元素从屏幕左边均匀地移动到屏幕右边。&lt;/p&gt;&lt;p&gt;下面是效果:&lt;/p&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;style&gt;.animate-warpper{width:100%;height:70px}@keyframes move_animation{0%{left:0}100%{left:calc(100% - 60px)}}.animate-div{width:60px;height:40px;position:absolute;left:0;border-radius:5px;background:#92B901;transform:translateZ(0);-webkit-transform:translateZ(0);animation:move_animation 5s linear 2s infinite alternate}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;animate-warpper&quot;&gt;&lt;div class=&quot;animate-div&quot;&gt;&lt;/div&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="requestAnimationFrame" scheme="https://lz5z.com/tags/requestAnimationFrame/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 循环与异步</title>
    <link href="https://lz5z.com/JavaScript-Loop-Async/"/>
    <id>https://lz5z.com/JavaScript-Loop-Async/</id>
    <published>2018-04-11T14:03:53.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>JS 中的循环与异步</h2><p>JS 中有多种方式实现循环：<code>for; for in; for of; while; do while; forEach; map</code> 等等。假如循环里面的内容是异步并且 await 的，那异步代码究竟是像 <code>Promise.all</code>一样将循环中的代码一起执行，还是每次等待上一次循环执行完毕再执行呢？</p><h2>首先看结论</h2><p>forEach 和 map, some, every 循环是并行执行的，相当于 Promise.all，其它 for, for in, for of, while, do while 都是串行执行的。</p><p>先定义异步函数 foo 和可遍历数组 arr：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">5</span> &#125;, (v, k) =&gt; k)</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      resolve(<span class="string">''</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>并行执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forEach</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  arr.forEach(<span class="keyword">async</span> a =&gt; <span class="keyword">await</span> foo(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  arr.map(<span class="keyword">async</span> a =&gt; <span class="keyword">await</span> foo(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * every</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  arr.every(<span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params"><span class="keyword">async</span>(</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> foo(a)</span><br><span class="line">    &#125;)()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>串行执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> foo(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> foo(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for of</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">await</span> foo(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * for in</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">await</span> foo(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * while</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> foo(i++)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * do while</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> foo(i++)</span><br><span class="line">  &#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>如何让 forEach 或者 map 也能串行执行</h2><p>首先查看 forEach 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">polyfill</a>，简化后可以理解为以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length</span><br><span class="line">  <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">var</span> kValue</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">      kValue = <span class="keyword">this</span>[k]</span><br><span class="line">      callback.call(thisArg, kValue, k, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到本质上 forEach 还是通过 while 循环来实现的，假如我们想要一个异步的 forEach 的话，只需要将 callback 的调用改成 await 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEachAsync = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length</span><br><span class="line">  <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">var</span> kValue</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">      kValue = <span class="keyword">this</span>[k]</span><br><span class="line">      <span class="keyword">await</span> callback.call(thisArg, kValue, k, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm 上有一个更为完备的解决方案：<a href="https://github.com/FuturesJS/forEachAsync/blob/master/forEachAsync.js" target="_blank" rel="noopener">forEachAsync</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forEachAsync = <span class="built_in">require</span>(<span class="string">'forEachAsync'</span>).forEachAsync</span><br><span class="line"></span><br><span class="line">forEachAsync(arr, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(a)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就这么多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;JS 中的循环与异步&lt;/h2&gt;&lt;p&gt;JS 中有多种方式实现循环：&lt;code&gt;for; for in; for of; while; do while; forEach; map&lt;/code&gt; 等等。假如循环里面的内容是异步并且 await 的，那异步代码究竟是像 &lt;code&gt;Promise.all&lt;/code&gt;一样将循环中的代码一起执行，还是每次等待上一次循环执行完毕再执行呢？&lt;/p&gt;&lt;h2&gt;首先看结论&lt;/h2&gt;&lt;p&gt;forEach 和 map, some, every 循环是并行执行的，相当于 Promise.all，其它 for, for in, for of, while, do while 都是串行执行的。&lt;/p&gt;&lt;p&gt;先定义异步函数 foo 和可遍历数组 arr：&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; arr = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.from(&amp;#123; &lt;span class=&quot;attr&quot;&gt;length&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &amp;#125;, (v, k) =&amp;gt; k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;i&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resolve(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Loop" scheme="https://lz5z.com/tags/Loop/"/>
    
      <category term="async/await" scheme="https://lz5z.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式格式化查询参数</title>
    <link href="https://lz5z.com/QueryStringFormat-RegExp/"/>
    <id>https://lz5z.com/QueryStringFormat-RegExp/</id>
    <published>2018-03-26T23:05:05.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下，通过一行正则表达式和 replace 方法简单实现正则表达式格式化查询参数。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">url</span> = <span class="string">'https://lz5z.com/000/?a=123&amp;b=456&amp;c=%E4%B8%AD%E6%96%87'</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 格式化查询字符串(正则实现) </span></span><br><span class="line"><span class="comment"> * @param url url地址 </span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125; 格式化的json对象 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/(?:[?&amp;]+)([^&amp;]+)=([^&amp;]+)/g</span></span><br><span class="line">    <span class="keyword">let</span> data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str, key, value</span>) </span>&#123;</span><br><span class="line">        data[<span class="built_in">decodeURIComponent</span>(key)] = <span class="built_in">decodeURIComponent</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">url</span>.replace(reg, fn)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(formatUrl(<span class="built_in">url</span>)) <span class="comment">// &#123; a: '123', b: '456', c: '中文' &#125;</span></span><br></pre></td></tr></table></figure><p>下次面试官问你的时候，你能答上来吗？😉😉😉</p><a id="more"></a><p>下面是 《JavaScript高级程序设计》 中给出的方案:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取得查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">''</span>)</span><br><span class="line">    <span class="comment">// 保存数据的对象</span></span><br><span class="line">    <span class="keyword">var</span> args = &#123;&#125;</span><br><span class="line">    <span class="comment">// 取得每一项</span></span><br><span class="line">    <span class="keyword">var</span> items = qs.length ? qs.split(<span class="string">'&amp;'</span>) : []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = items[i].split(<span class="string">'='</span>)</span><br><span class="line">        <span class="keyword">var</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> (name.length) args[name] = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下，通过一行正则表达式和 replace 方法简单实现正则表达式格式化查询参数。&lt;/p&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;https://lz5z.com/000/?a=123&amp;amp;b=456&amp;amp;c=%E4%B8%AD%E6%96%87&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 格式化查询字符串(正则实现) &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @param url url地址 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @return &amp;#123;Object&amp;#125; 格式化的json对象 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;formatUrl&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;url&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; reg = &lt;span class=&quot;regexp&quot;&gt;/(?:[?&amp;amp;]+)([^&amp;amp;]+)=([^&amp;amp;]+)/g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; data = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;str, key, value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        data[&lt;span class=&quot;built_in&quot;&gt;decodeURIComponent&lt;/span&gt;(key)] = &lt;span class=&quot;built_in&quot;&gt;decodeURIComponent&lt;/span&gt;(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;.replace(reg, fn)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(formatUrl(&lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;// &amp;#123; a: &#39;123&#39;, b: &#39;456&#39;, c: &#39;中文&#39; &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;下次面试官问你的时候，你能答上来吗？😉😉😉&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="RegExp" scheme="https://lz5z.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 深拷贝和浅拷贝</title>
    <link href="https://lz5z.com/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://lz5z.com/JavaScript深拷贝和浅拷贝/</id>
    <published>2018-03-10T22:02:49.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 引用数据类型中，变量保存的是一个指向堆内存的指针，当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1</span><br><span class="line">obj2.x = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">// &#123; x: 2, y: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123; x: 2, y: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>以上的拷贝方式就是浅拷贝，当 obj2 的值改变时，obj1 的值也随之发生改变。</p><a id="more"></a><h3>浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.concat()</span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.slice()</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">Array</span>.from(arr3)</span><br><span class="line"></span><br><span class="line">arr2 === arr1 <span class="comment">// false 看起来像深拷贝</span></span><br><span class="line">arr3 === arr1 <span class="comment">// false 看起来像深拷贝</span></span><br><span class="line">arr4 === arr3 <span class="comment">// false 看起来像深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然鹅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr5 = [&#123;<span class="attr">name</span>: <span class="string">'Leo'</span>&#125;]</span><br><span class="line"><span class="keyword">let</span> arr6 = arr4.slice()</span><br><span class="line"><span class="keyword">let</span> arr7 = arr4.concat()</span><br><span class="line"><span class="keyword">let</span> arr8 = <span class="built_in">Array</span>.from(arr4)</span><br><span class="line"></span><br><span class="line">arr5[<span class="number">0</span>].name = <span class="string">'Jack'</span></span><br><span class="line">arr6[<span class="number">0</span>].name === <span class="string">'Jack'</span> <span class="comment">// 其实还是浅拷贝</span></span><br><span class="line">arr7[<span class="number">0</span>].name === <span class="string">'Jack'</span> <span class="comment">// 其实还是浅拷贝</span></span><br><span class="line">arr8[<span class="number">0</span>].name === <span class="string">'Jack'</span> <span class="comment">// 其实还是浅拷贝</span></span><br></pre></td></tr></table></figure><p>Array.prototype.concat(), Array.prototype.slice(), Array.from() 只能实现对一维数组的深拷贝。</p><h3>Object.assign()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1)</span><br><span class="line">obj1 === obj2 <span class="comment">// false</span></span><br><span class="line">obj1.x = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">// &#123; x: 2, y: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123; x: 1, y: 2 &#125; // 一维对象可以进行深拷贝</span></span><br><span class="line"><span class="comment">// 然鹅</span></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123; <span class="attr">x</span>: &#123;<span class="attr">name</span>: <span class="string">'Leo'</span>&#125; &#125;</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj3)</span><br><span class="line">obj3 === obj4 <span class="comment">// false</span></span><br><span class="line">obj3.x.name = <span class="string">'Jack'</span></span><br><span class="line">obj4.x.name === <span class="string">'Jack'</span> <span class="comment">// true // 其实还是浅拷贝</span></span><br></pre></td></tr></table></figure><h3>深拷贝</h3><p>使用 JSON.parse() + JSON.stringify() 实现深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: &#123;</span><br><span class="line">    name: <span class="string">'Leo'</span>,</span><br><span class="line">    friends: [<span class="string">'Lily'</span>, <span class="string">'Elsa'</span>]</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line"></span><br><span class="line">obj1 === obj2 <span class="comment">// false</span></span><br><span class="line">obj1.y.name = <span class="string">'Jack'</span></span><br><span class="line">obj1.y.friends.push(<span class="string">'Tim'</span>)</span><br><span class="line">obj2.y.name === <span class="string">'Leo'</span> <span class="comment">// 深拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.y.friends) <span class="comment">// ["Lily", "Elsa"] // 深拷贝</span></span><br></pre></td></tr></table></figure><p>JSON.parse 和 JSON.stringify 看起来不错，不过存在一些<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">问题</a>：</p><ol><li>undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。</li><li>所有以 symbol 为属性键的属性都会被完全忽略掉。</li><li>不可枚举的属性会被忽略。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>)</span>&#123;&#125;&#125;) <span class="comment">// '&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">x</span>: <span class="literal">undefined</span>, <span class="attr">y</span>: <span class="built_in">Object</span>, <span class="attr">z</span>: <span class="built_in">Symbol</span>(<span class="string">""</span>)&#125;) <span class="comment">// '&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="literal">undefined</span>, <span class="built_in">Object</span>, <span class="built_in">Symbol</span>(<span class="string">""</span>)]) <span class="comment">// '[null,null,null]' </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;[<span class="built_in">Symbol</span>(<span class="string">"foo"</span>)]: <span class="string">"foo"</span>&#125;) <span class="comment">// '&#123;&#125;'</span></span><br></pre></td></tr></table></figure><h3>使用递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if o is not an object </span></span><br><span class="line">  <span class="keyword">if</span> (!o || (<span class="keyword">typeof</span> o) != <span class="string">'object'</span>) <span class="keyword">return</span> o</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Array</span>.isArray(o) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(o) </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'object'</span>) &#123;</span><br><span class="line">        res[key] = deepClone(o[key])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res[key] = o[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  x: &#123;<span class="attr">name</span>: <span class="string">'Leo'</span>&#125;,</span><br><span class="line">  y: <span class="literal">undefined</span>,</span><br><span class="line">  z: <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  t: <span class="built_in">Symbol</span>(<span class="string">'tt'</span>),</span><br><span class="line">  m: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  n: [[<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj1)</span><br><span class="line">obj1.n[<span class="number">0</span>].push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2.n[<span class="number">0</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>注意：由于使用 <code>for in</code> 循环，所以只能深度拷贝对象自身属性（非原型链上的属性），并且属性为 enumerable。</p><p>使用递归拷贝对象的方法，在目标非常大，层级关系非常深的时候会出现性能问题，具体解决方案可以参考我之前写的 <a href="https://lz5z.com/JavaScript%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/">JavaScript递归优化</a> 使用栈代替递归的方式解决。</p><h3>lodash</h3><p>lodash 中提供 4 个对象<a href="https://lodash.com/docs/4.17.10#clone" target="_blank" rel="noopener">拷贝</a>相关的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.clone() <span class="comment">// 提供浅拷贝</span></span><br><span class="line">_.cloneDeep() <span class="comment">// 提供深拷贝</span></span><br><span class="line">_.cloneDeepWith() <span class="comment">// 提供递归拷贝，并且可以自定义拷贝内容</span></span><br><span class="line">_.cloneWith() <span class="comment">// 提供浅拷贝，并且可以自定义拷贝内容</span></span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">customizer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.isElement(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.cloneNode(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> el = _.cloneDeepWith(<span class="built_in">document</span>.body, customizer)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(el === <span class="built_in">document</span>.body) <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(el.nodeName) <span class="comment">// =&gt; 'BODY'</span></span><br><span class="line"><span class="built_in">console</span>.log(el.childNodes.length) <span class="comment">// =&gt; 20</span></span><br></pre></td></tr></table></figure><p>相信上述几种方法已经能够满足我们平时大部分的需求了，如果有额外的需求，只能自己定义实现深/浅拷贝的方式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 引用数据类型中，变量保存的是一个指向堆内存的指针，当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj1 = &amp;#123; &lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj2 = obj1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj2.x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj1) &lt;span class=&quot;comment&quot;&gt;// &amp;#123; x: 2, y: 2 &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj2) &lt;span class=&quot;comment&quot;&gt;// &amp;#123; x: 2, y: 2 &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;以上的拷贝方式就是浅拷贝，当 obj2 的值改变时，obj1 的值也随之发生改变。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="clone" scheme="https://lz5z.com/tags/clone/"/>
    
      <category term="深拷贝" scheme="https://lz5z.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="https://lz5z.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="lodash" scheme="https://lz5z.com/tags/lodash/"/>
    
  </entry>
  
  <entry>
    <title>Shell 学习</title>
    <link href="https://lz5z.com/shell-study/"/>
    <id>https://lz5z.com/shell-study/</id>
    <published>2018-03-07T22:51:37.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>Shell 变量</h2><ul><li>变量默认都是字符串类型</li><li>变量名和等号之间不能有空格</li><li>命名：只能使用英文字母，数字和下划线，首个字符不能以数字开头</li><li>查看变量 set 命令，删除变量 <code>unset variable_name</code></li><li><code>set -u</code> 调用未声明变量报错（默认无提示）</li></ul><h3>变量叠加</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=123</span><br><span class="line">x="$x"456</span><br><span class="line">x=$&#123;x&#125;789</span><br><span class="line">echo $x # 123456789</span><br></pre></td></tr></table></figure><a id="more"></a><h3>readonly</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=123</span><br><span class="line">readonly x</span><br><span class="line">x=312 #-bash: a: readonly variable</span><br></pre></td></tr></table></figure><h3>Shell 字符串</h3><p>Shell 字符串可以用单引号，也可以用双引号，也可以不用引号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str='Hello World'</span><br><span class="line">name='Jack'</span><br><span class="line">str="Hello, $&#123;name&#125;"</span><br><span class="line">str="Hello, "$name""</span><br><span class="line">str="Hello, \"$name\"! "</span><br></pre></td></tr></table></figure><p>其中双引号中可以出现变量和转义符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="abcd"</span><br><span class="line">echo $&#123;#string&#125; # 获取字符串长度</span><br></pre></td></tr></table></figure><p>提取子字符串<br>以下实例从字符串第 2 个字符开始截取 4 个字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="Hello World"</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 ello</span><br></pre></td></tr></table></figure><p>查找字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="Hello World"</span><br><span class="line">echo `expr index "$string" llo` # 3</span><br></pre></td></tr></table></figure><h2>Shell 数组</h2><p>Shell 中只支持一维数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names=('leo' 'jack' 'tim')</span><br><span class="line">names[3]='petter' # 可以不使用连续的下标，而且下标的范围没有限制</span><br><span class="line">echo $&#123;names[0]&#125; # leo</span><br><span class="line">echo $&#123;names[@]&#125; # 获取全部元素</span><br><span class="line">echo $&#123;#names[@]&#125; # 获取数组长度</span><br><span class="line">echo $&#123;#names[*]&#125; # 获取数组长度</span><br><span class="line">echo $&#123;#names[0]&#125; # 获取第一个元素长度</span><br></pre></td></tr></table></figure><h2>Shell 注释</h2><p>Shell 没有多行注释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是一个注释</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author：lizhen</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> site：https://lz5z.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slogan：人生苦短，我再睡会</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### config start #####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> blabla</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### config end  #####</span></span></span><br></pre></td></tr></table></figure><h2>Shell 参数</h2><p>创建脚本 <code>test.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:lizhen</span></span><br><span class="line"></span><br><span class="line">echo "Shell 传递参数";</span><br><span class="line">echo "执行的文件名：$0";</span><br><span class="line">echo "第一个参数为：$1";</span><br><span class="line">echo "第二个参数为：$2";</span><br><span class="line">echo "第三个参数为：$3";</span><br><span class="line">echo "参数个数：$#";</span><br><span class="line">echo "参数字符串：$*";</span><br><span class="line">echo "所有参数：$@";</span><br><span class="line">echo "进程ID号: $$";</span><br></pre></td></tr></table></figure><p>为脚本设置执行权限，并执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chmod +x test.sh</span><br><span class="line">./test.sh 1 2 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Shell 传递参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行的文件名：./test.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个参数为：1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个参数为：2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第三个参数为：3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数个数：4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数字符串：1 2 3 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所有参数：1 2 3 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进程ID号: 27694</span></span><br></pre></td></tr></table></figure><h2>Shell 运算符</h2><p>原生 bash 不支持数学运算符，但是可以通过其他命令实现，比如 expr。</p><h3>算术运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val=`expr 2 + 2` # 注意空格</span><br><span class="line">echo val # 4</span><br><span class="line">echo `expr 2 - 2` # 0</span><br><span class="line">echo `expr 2 \* 2` # 4 # 乘号前面必须要有反斜杠</span><br><span class="line">echo `expr 2 / 2` # 1</span><br><span class="line">echo `expr 3 % 2` # 1</span><br><span class="line">echo `expr 2 == 2` # 1</span><br><span class="line">echo `expr 2 != 2` # 0</span><br></pre></td></tr></table></figure><h3>关系运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ $a -eq $b ] # -eq 相等</span><br><span class="line">[ $a -ne $b ] # -ne 不等</span><br><span class="line">[ $a -gt $b ] # -gt 大于</span><br><span class="line">[ $a -lt $b ] # -lt 小于</span><br><span class="line">[ $a -ge $b ] # -ge 大于等于</span><br><span class="line">[ $a -le $b ] # -le 小于等于</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=$1</span><br><span class="line">b=$2</span><br><span class="line">echo $a</span><br><span class="line">echo $b</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a -eq $b : a 等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a -eq $b: a 不等于 b"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./test.sh 10 20</span><br><span class="line"><span class="meta">#</span><span class="bash"> 10 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 20</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"10 -eq 20: a 不等于 b"</span></span></span><br></pre></td></tr></table></figure><h3>布尔运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:lizhen</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 非运算 !</span></span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo "$a != $b : a 不等于 b"</span><br><span class="line">else</span><br><span class="line">   echo "$a != $b: a 等于 b"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或运算 -o</span></span><br><span class="line">if [ $a -lt 100 -o $b -gt 100 ]</span><br><span class="line">then</span><br><span class="line">   echo "$a 小于 100 或 $b 大于 100 : true"</span><br><span class="line">else</span><br><span class="line">   echo "$a 小于 100 或 $b 大于 100 : false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 与运算 -a</span></span><br><span class="line">if [ $a -lt 100 -a $b -gt 15 ]</span><br><span class="line">then</span><br><span class="line">   echo "$a 小于 100 且 $b 大于 15 : true"</span><br><span class="line">else</span><br><span class="line">   echo "$a 小于 100 且 $b 大于 15 : false"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3>逻辑运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="meta">#</span><span class="bash"> 逻辑AND &amp;&amp;</span></span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 逻辑OR ||</span></span><br><span class="line">if [[ $a -lt 100 || $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo "true"</span><br><span class="line">else</span><br><span class="line">   echo "false"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3>字符串运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a="abc"</span><br><span class="line">b="cde"</span><br><span class="line">[ $a = $b ] # 字符串相等</span><br><span class="line">[ $a != $b ] # 字符串不等</span><br><span class="line">[ -z $a ] # 字符串长度为0</span><br><span class="line">[ -n $a ] # 字符串长度不为0</span><br><span class="line">[ $a ] # 字符串不为空</span><br></pre></td></tr></table></figure><h2>echo 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo "\"Are you OK?\"" # 转义字符</span><br><span class="line">echo "$a" # 变量</span><br><span class="line">echo -e "I\'m \nOK" # -e 开启转义</span><br><span class="line">echo -e "I\'m OK \c" # -e 开启转义 \c 不换行</span><br><span class="line">echo "Are you OK?" &gt; tesh.sh # 显示结果到文件</span><br><span class="line">echo '$a\"' # $a\" # 原样输出字符串，不转义不去变量 单引号</span><br><span class="line">echo `date` # 显示时间</span><br></pre></td></tr></table></figure><h2>printf 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">printf</span> format-string [arguments...]</span></span><br><span class="line"></span><br><span class="line">printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  </span><br><span class="line">printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234 </span><br><span class="line">printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543 </span><br><span class="line">printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876</span><br></pre></td></tr></table></figure><p>%s %c %d %f都是格式替代符</p><p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p><h2>test 命令</h2><p>test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><h3>数值测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if test $[a] -eq $[b] # 如果 a 等于 b</span><br><span class="line">then</span><br><span class="line">  echo "$a 等于 $b"</span><br><span class="line">else</span><br><span class="line">  echo "$a 不等于 $b"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>代码中的 [] 表示执行基本的算数运算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=10</span><br><span class="line">echo "$[a+b]" # 20 # 不能有空格</span><br></pre></td></tr></table></figure><h3>字符串测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a="abc"</span><br><span class="line">b="ABC"</span><br><span class="line">if test $a = $b</span><br><span class="line">then </span><br><span class="line">  echo "字符串相等"</span><br><span class="line">else </span><br><span class="line">  echo "字符串不等"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3>文件测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -e 文件名  如果文件存在则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 文件名  如果文件存在且可读则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -w 文件名  如果文件存在且可写则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x 文件名  如果文件存在且可执行则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s 文件名  如果文件存在且至少有一个字符则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 文件名  如果文件存在且为目录则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f 文件名  如果文件存在且为普通文件则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 文件名  如果文件存在且为字符型特殊文件则为真</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -b 文件名  如果文件存在且为块特殊文件则为真</span></span><br><span class="line"></span><br><span class="line">if test -e ./test.sh</span><br><span class="line">then </span><br><span class="line">  echo "test.sh 文件存在"</span><br><span class="line">else</span><br><span class="line">  echo "文件不存在"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2>Shell 流程控制</h2><h3>条件控制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> </span></span><br><span class="line">if condition</span><br><span class="line">then </span><br><span class="line">  command1</span><br><span class="line">  command2</span><br><span class="line">  ...</span><br><span class="line">  commandN</span><br><span class="line">fi  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> <span class="keyword">else</span>-if <span class="keyword">else</span></span></span><br><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3>for 循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> 循环</span></span><br><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> 循环</span></span><br><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo "The value is: $loop"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3>while 循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do </span><br><span class="line">  command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span> 循环</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">  echo $int</span><br><span class="line">  let "int++"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3>无限循环</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do </span><br><span class="line">  command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3>case</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span></span></span><br><span class="line">echo '输入 1 到 4 之间的数字:'</span><br><span class="line">echo '你输入的数字为:'</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo '你选择了 1'</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo '你选择了 2'</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo '你选择了 3'</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo '你选择了 4'</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo '你没有输入 1 到 4 之间的数字'</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><h3>break</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字:"</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3>continue</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "输入 1 到 5 之间的数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "你输入的数字为 $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "你输入的数字不是 1 到 5 之间的!"</span><br><span class="line">            continue</span><br><span class="line">            echo "游戏结束"</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>esac<br>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p><h2>Shell 函数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo "输入的两个数字进行相加运算..."</span><br><span class="line">    echo "输入第一个数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo "输入第二个数字: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo "输入的两个数字之和为 $? !"</span><br></pre></td></tr></table></figure><p>函数返回值在调用该函数后通过 $? 来获得。</p><blockquote><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p></blockquote><h3>函数参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 $&#123;10&#125; !"</span><br><span class="line">    echo "第十一个参数为 $&#123;11&#125; !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><h2>Shell 重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &gt; file # 将输出重定向到 file</span><br><span class="line">command &lt; file # 将输入重定向到 file</span><br><span class="line">command &gt;&gt; file # 将输出以追加的方式重定向到 file</span><br></pre></td></tr></table></figure><h3>禁止输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; /dev/null</span><br></pre></td></tr></table></figure><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</p></blockquote><h2>Shell 文件包含</h2><p><a href="http://test1.sh" target="_blank" rel="noopener">test1.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a="abc"</span><br></pre></td></tr></table></figure><p><a href="http://test2.sh" target="_blank" rel="noopener">test2.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 . 号来引用test1.sh 文件</span></span><br><span class="line">. ./test1.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用以下包含文件代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ./test1.sh</span></span><br><span class="line"></span><br><span class="line">echo "$a"</span><br></pre></td></tr></table></figure><p>接下来，我们为 <a href="http://test2.sh" target="_blank" rel="noopener">test2.sh</a> 添加可执行权限并执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test2.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test2.sh</span></span><br></pre></td></tr></table></figure><blockquote><p>注：被包含的文件 <a href="http://test1.sh" target="_blank" rel="noopener">test1.sh</a> 不需要可执行权限。</p></blockquote><h2>read</h2><p>-p 输入提示信息<br>-t 等待时间（单位是秒）<br>-n 字符数，read只<br>-s 输入隐藏数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "please input your name: " -t 30 name</span><br><span class="line">echo $name</span><br><span class="line"></span><br><span class="line">read -p "please input your sex [M/F]: " -n 1 sex</span><br><span class="line">echo -e "\n"</span><br><span class="line">echo $sex</span><br><span class="line"></span><br><span class="line">read -p "please input your password: " -s password</span><br><span class="line">echo -e "\n"</span><br><span class="line">echo $password</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;Shell 变量&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;变量默认都是字符串类型&lt;/li&gt;&lt;li&gt;变量名和等号之间不能有空格&lt;/li&gt;&lt;li&gt;命名：只能使用英文字母，数字和下划线，首个字符不能以数字开头&lt;/li&gt;&lt;li&gt;查看变量 set 命令，删除变量 &lt;code&gt;unset variable_name&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;set -u&lt;/code&gt; 调用未声明变量报错（默认无提示）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;变量叠加&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x=123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x=&quot;$x&quot;456&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x=$&amp;#123;x&amp;#125;789&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $x # 123456789&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://lz5z.com/categories/Linux/"/>
    
    
      <category term="Shell" scheme="https://lz5z.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/2 学习</title>
    <link href="https://lz5z.com/http2-study/"/>
    <id>https://lz5z.com/http2-study/</id>
    <published>2018-03-07T21:35:06.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>HTTP/2.0 简介</h2><ol><li>HTTP/2 标准于 2015 年发布，目前大部分主流浏览器均已提供支持。</li><li>HTTP/2 没有改变 HTTP 的应用语义，其请求方法、状态码、URI 等核心概念与 HTTP/1.1 保持一致。</li><li>HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。</li><li>HTTP/2 的前身是 <a href="https://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY 协议</a>。</li><li>HTTP/2 中 TLS 为可选，但是大厂商如 chrome 和 firefox 表示只会实现基于 TLS 的 HTTP/2。所以要部署 HTTP/2，首先要升级 HTTPS。</li><li>HTTP/2 通过以下举措，减少网络延迟，提供浏览器加载速度：<ul><li>对 HTTP 头字段进行数据压缩(即 HPACK 算法)；</li><li>HTTP/2 服务端推送(Server Push)；</li><li>请求管线化；</li><li>修复 HTTP/1. 0版本以来未修复的队头阻塞问题；</li><li>对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内。</li></ul></li></ol><a id="more"></a><h2>HTTP/2 测试</h2><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">Akamai http2 demo</a> 这个 Akamai 公司建立的官方 demo，左右两边分别为 HTTP/1.1 和 HTTP/2，两边都同时请求 300 多张图片，从加载时间可以看出 HTTP/2 在速度上的绝对优势。</p><p>chrome 商店中有一个工具 <a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">HTTP/2 and SPDY indicator</a> 用来查看当前网站是否基于 HTTP/2，添加到 chrome 后如果蓝色闪电亮了说明支持 HTTP/2。</p><h2>HTTP/2 新特性</h2><p>HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。HTTP/1.x 协议解析基于纯文本，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。二进制只有 0 和 1 的组合实现起来方便且健壮。</p><h3>帧、消息、流和 TCP 连接</h3><p>有别于 HTTP/1.1 在连接中的明文请求，HTTP/2 将一个 TCP 连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。这也是 HTTP/1.1 与 HTTP/2 最大的区别。 HTTP/2 中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个 TCP 通道；协议将每个请求分区为二进制的控制帧与数据帧部分，以便解析。</p><h3>多路复用</h3><p>在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」这也是我们在站点中使用 CDN 的主要原因。</p><p>多路复用原理上还是基于以上 TCP 连接通道，通过单一的 TCP 连接发起和响应多重请求机制。</p><h3>首部压缩 - HPACK 算法</h3><p>在 HTTP/1.x 中，header 中带有大量信息，而且每次都要重复发送，HTTP/2 中引入 HPACK 算法用于对 HTTP 头部做压缩。其原理在于：</p><ul><li>客户端与服务端共同维护一份静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码；</li><li>客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）；</li><li>客户端和服务端共同支持基于相同内容得静态哈夫曼码表的哈夫曼编码（Huffman Coding）。</li></ul><h3>服务器推送 - Server Push</h3><p>HTTP/2 引入了服务器推送，可以在客户端请求资源之前发送数据，这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。除此之外，服务器还能够缓存数据，在同源策略下，不同页面共享缓存资源成为可能。</p><h3>重置</h3><p>HTTP/1.1 的有一个缺点是：当一个含有确切值的 Content-Lengt h的 HTTP 消息被送出之后，你就很难中断它了。当然，通常你可以断开整个 TCP 链接（但也不总是可以这样），但这样导致的代价就是需要通过三次握手来重新建立一个新的TCP连接。</p><p>一个更好的方案是只终止当前传输的消息并重新发送一个新的。在 HTTP/2 里面，我们可以通过发送 RST_STREAM 帧来实现这种需求，从而避免浪费带宽和中断已有的连接。</p><h2>参考文档</h2><ul><li><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/#prettyPhoto" target="_blank" rel="noopener">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a></li><li><a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="noopener">HTTP/2 资料汇总</a></li><li><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="noopener">HTTP/2.0 相比1.0有哪些重大改进？</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a></li><li><a href="https://ye11ow.gitbooks.io/http2-explained/" target="_blank" rel="noopener">http2讲解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;HTTP/2.0 简介&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;HTTP/2 标准于 2015 年发布，目前大部分主流浏览器均已提供支持。&lt;/li&gt;&lt;li&gt;HTTP/2 没有改变 HTTP 的应用语义，其请求方法、状态码、URI 等核心概念与 HTTP/1.1 保持一致。&lt;/li&gt;&lt;li&gt;HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。&lt;/li&gt;&lt;li&gt;HTTP/2 的前身是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/SPDY&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SPDY 协议&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;HTTP/2 中 TLS 为可选，但是大厂商如 chrome 和 firefox 表示只会实现基于 TLS 的 HTTP/2。所以要部署 HTTP/2，首先要升级 HTTPS。&lt;/li&gt;&lt;li&gt;HTTP/2 通过以下举措，减少网络延迟，提供浏览器加载速度：&lt;ul&gt;&lt;li&gt;对 HTTP 头字段进行数据压缩(即 HPACK 算法)；&lt;/li&gt;&lt;li&gt;HTTP/2 服务端推送(Server Push)；&lt;/li&gt;&lt;li&gt;请求管线化；&lt;/li&gt;&lt;li&gt;修复 HTTP/1. 0版本以来未修复的队头阻塞问题；&lt;/li&gt;&lt;li&gt;对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="网络" scheme="https://lz5z.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://lz5z.com/tags/HTTP/"/>
    
      <category term="HTTP2" scheme="https://lz5z.com/tags/HTTP2/"/>
    
  </entry>
  
  <entry>
    <title>再见2017，你好2018</title>
    <link href="https://lz5z.com/GoodBye2017-Hello2018/"/>
    <id>https://lz5z.com/GoodBye2017-Hello2018/</id>
    <published>2018-02-11T20:11:42.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>2017</h2><p>好久没有更新博客了。</p><p>2017年过得真快，转眼已经快触不到2017的尾巴了，如果算农历年的话，留给它的时间也已经不多了。</p><p>2017年对于我来说发生的最重要的事情就是跳槽了，从 OOCL 离职，到入职 WPS 正好一年了。这一年可以说是我职业发展最为重要的一年，以后应该都会在这个方向前行了。这一年差不多是我从门外汉逐步入门的过程，虽然之前也有一两年的工作经验，但大多时候是打酱油，在一个大的项目中缝缝补补。而经过 WPS 一年的训练，如今我可以写一些小的项目，也完全看懂了部门的大项目的整个架构。</p><p>第二件事就是今年八月份买了人生第一辆小车车-日产骐达。这辆小车车如今已经是我们家中第三重要的成员了，给生活提升了极大的幸福感。尤其是搬家的时候，身心俱疲，但是当进入小车的一瞬间，知道自己无论如何有落脚的地方，就觉得很安心。</p><a id="more"></a><p>第三件事就是公司搬家，下面是我离开旧金山时候拍的照片。</p><p>旧金山大楼：</p><img src="/assets/img/旧金山大楼.jpg" alt="旧金山" width="60%"><p>这是旧金山的工位，呆了差不多10个月：</p><img src="/assets/img/旧金山工位.jpg" alt="旧金山工位" width="60%"><p>下面是刚搬到新办公室的照片，一台 PC，一台 mac mini，两台电脑都很卡。</p><img src="/assets/img/新工位.jpg" alt="新工位" width="60%"><p>后面自己买了 2k 32 寸的显示器，公司又给升级了最新的 PC - DELL 的高配 7050 + 三星 SSD，现在不再抱怨电脑卡了。新升级设备后给自己加了好多天的班，用流畅舒服的设备敲代码让人欲罢不能啊。（老板听到后请给我加薪）</p><img src="/assets/img/新工位2.jpg" alt="新工位2" width="60%"><p>还有一件事就是部门给了优秀员工奖，虽然没有实质性的奖励，但是可以看到 leader 予以的器重，所以还是很开心的。年终考评时，前端负责人也给了很不错的评价，说以后会让我负责更多的东西，多给我成长的机会。</p><h2>2018</h2><p>2018年又长了一岁了，最重要的当然是结婚的事情提上了日程，以前别人问怎么还不结婚的时候，总是答，人家还小呢。但是这几年越发觉得自己其实已是一个油腻的中年人了，上学时本来就比周围的人大，一直被称为 “振哥”，工作以后发现同等年纪的人已经工作三四年了，越发焦急，觉得自己一事无成，马齿徒增。大学毕业的时候选择工作而没有像别的同学那样读研也是同样的原因。而明年的结婚算是给自己和家人一个交代，完成了人生的一件大事。</p><p>2018年当然是希望自己技术越来好，能承担越来越多的责任。当然最重要的是，要赚更多的钱，家人都健康快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;2017&lt;/h2&gt;&lt;p&gt;好久没有更新博客了。&lt;/p&gt;&lt;p&gt;2017年过得真快，转眼已经快触不到2017的尾巴了，如果算农历年的话，留给它的时间也已经不多了。&lt;/p&gt;&lt;p&gt;2017年对于我来说发生的最重要的事情就是跳槽了，从 OOCL 离职，到入职 WPS 正好一年了。这一年可以说是我职业发展最为重要的一年，以后应该都会在这个方向前行了。这一年差不多是我从门外汉逐步入门的过程，虽然之前也有一两年的工作经验，但大多时候是打酱油，在一个大的项目中缝缝补补。而经过 WPS 一年的训练，如今我可以写一些小的项目，也完全看懂了部门的大项目的整个架构。&lt;/p&gt;&lt;p&gt;第二件事就是今年八月份买了人生第一辆小车车-日产骐达。这辆小车车如今已经是我们家中第三重要的成员了，给生活提升了极大的幸福感。尤其是搬家的时候，身心俱疲，但是当进入小车的一瞬间，知道自己无论如何有落脚的地方，就觉得很安心。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="总结" scheme="https://lz5z.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>webpack 打包加速实战</title>
    <link href="https://lz5z.com/webpack%E6%89%93%E5%8C%85%E5%8A%A0%E9%80%9F%E5%AE%9E%E6%88%98/"/>
    <id>https://lz5z.com/webpack打包加速实战/</id>
    <published>2018-01-13T09:05:31.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>webpack 打包优化</h2><p>最近项目不算忙，抽时间重构了一下项目的打包，先说一下成就。</p><p>在我的开发电脑上：</p><p>OS: macOS High Sierra<br>CPU: 2.6 GHz Intel Core i5<br>内存: 8G 1600 DDR3<br>硬盘: 1 TB SATA磁盘</p><p>代码全量编译时间从 4 分 51 秒优化到 2 分 08 - 20 秒左右。</p><p>在项目编译电脑上：</p><p>OS: Ubuntu 16.04.3 LTS<br>CPU: Intel® Core™ i5-7500 CPU @ 3.40GHz<br>内存: 64G 2133 DDR4<br>硬盘: 1 TB SSD</p><p>代码全量编译时间从 4 分 08 秒优化到 1 分 10 - 20 秒左右。</p><a id="more"></a><h2>用了哪些手段</h2><h3>升级电脑</h3><p>升级 SSD 可能是提升效果最明显的吧，从上面两组数据中就可以看出。相同的优化在 SSD 中表现要明显很多。</p><h3>升级 webpack3</h3><p><a href="https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="noopener">webpack 3: Official Release!!</a></p><p>如果你的项目还在用 webpack2 的话，强烈建议你升级到 webpack3。webpack3 向下兼容，只不过有一些插件需要同时升级，注意看控制台给出的日志，把需要升级的一起升级了就好了。</p><h4>Scope Hoisting-作用域提升</h4><p>webpack 打包的时候，每个模块都被一个闭包函数包裹，过多的闭包函数降低了浏览器中 JS 执行效率，Scope Hoisting 的作用是减少闭包函数的数量，将有关联的模块放到同一个闭包函数中。</p><p>启用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scope Hoisting 是基于 ECMAScript Module syntax ，对于 Commonjs 和 AMD 的模块不适用。</p><p>上面升级的算是副本，下面才是正文。</p><h2>正文开始</h2><p>现在开发的项目算是比较大的项目，严格来说，是多个 SPA 组成的多项目。这样做的好处是能减少架构师的工作，同一份架构给多个项目使用，能保证项目稳定性。坏处也比较明显，就是会额外引入无用的依赖，比如共用的 helper 模块，很多项目都引用了，但是并不是每个项目都使用里面的每个函数。这点 tree-shaking 可以给出解决方案，但是实际开发过程中，由于同事们代码质量参差不齐，有些没用到的函数和模块也都引用了，所以导致 tree-shaking 的效果并不是很好。比如在大项目中，同事把几个 helper 里面函数全部封装到 vue-filter 中，当然里面的内容主要项目大多数都引用到了，但是后面同事在初始化一个小项目的同时，无论是否需要也都用了相同的代码（copy and paste）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> helpers <span class="keyword">from</span> <span class="string">'helpers'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> helpers2 <span class="keyword">from</span> <span class="string">'helpers/string'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> helpers3 <span class="keyword">from</span> <span class="string">'helpers/...'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> helpers4 <span class="keyword">from</span> <span class="string">'helpers/...'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// register global utility filters.</span></span><br><span class="line"><span class="keyword">let</span> _filters = <span class="built_in">Object</span>.assign(helpers, helpers2, helpers3, helpers4)</span><br><span class="line"><span class="built_in">Object</span>.keys(_filters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> Vue.filter(key, _filters[key]))</span><br></pre></td></tr></table></figure><p>于是 helper 中每个 function 都挂载在 Vue-filter 中，所以完美的避开了 tree-shaking。</p><p>另外 tree-shaking 虽然能够一定程度的减少打包后代码的体积，但是开发和编译的速度还是会受到一定的影响。</p><p>下面是代码打包速度优化的一些思路，多数来源于网上的资料。</p><h3>commonChunkPlugin 抽取公共代码</h3><p>抽取公共代码有两个好处，一个是能减少编译代码的数量，一个是能够充分利用浏览器缓存，比如遇到项目切换的情况，使用 service-worker 中缓存共用的 common 代码能够减少请求的数量。</p><p>以下是 vue-cli 中给出的解决方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split vendor js into its own file</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  minChunks(<span class="built_in">module</span>) &#123;</span><br><span class="line">    <span class="comment">// any required modules inside node_modules are extracted to vendor</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// extract webpack runtime and module manifest to its own file in order to</span></span><br><span class="line"><span class="comment">// prevent vendor hash from being updated whenever app bundle is updated</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'manifest'</span>,</span><br><span class="line">  minChunks: <span class="literal">Infinity</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// This instance extracts shared chunks from code splitted chunks and bundles them</span></span><br><span class="line"><span class="comment">// in a separate chunk, similar to the vendor chunk</span></span><br><span class="line"><span class="comment">// see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'app'</span>,</span><br><span class="line">  <span class="keyword">async</span>: <span class="string">'vendor-async'</span>,</span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  minChunks: <span class="number">3</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h3>DLL 预编译</h3><p>DLL 预编译的作用是将项目中稳定的依赖单独打包编译生成动态链接库，在业务代码中引用。这点在开发过程中优势比较明显，每次更新代码重新编译的时候都能够省去 DLL 库的编译，有不小的速度提升。</p><p>DLL 需要有一个额外的打包过程，新建一个 webpck.dll.conf.js 用来打包 DLL，并且在 package.json 中添加打包过程。</p><p>package.json</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"rimraf dist &amp;&amp; npm run dll &amp;&amp; npm run build:server &amp;&amp; npm run build:client"</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"dll"</span>: <span class="string">"cross-env NODE_ENV=dll node build"</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.dll.conf.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vendors = [</span><br><span class="line">  <span class="string">'babel-polyfill'</span>,</span><br><span class="line">  <span class="string">'es6-promise'</span>,</span><br><span class="line">  <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">  <span class="string">'vue-router'</span>,</span><br><span class="line">  <span class="string">'vuex'</span>,</span><br><span class="line">  <span class="string">'vuex-router-sync'</span>,</span><br><span class="line">  <span class="string">'axios'</span>,</span><br><span class="line">  <span class="string">'cookie'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_[hash]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'vendor'</span>: vendors,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      ... <span class="comment">// 压缩参数略</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      path: path.join(__dirname, <span class="string">'../dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行 <code>npm run dll</code> 在 dist 目录下生成了两个文件 vendor.dll.js 和 vendor.manifest.json。其中 vendor.dll.js 中是打包压缩后的 vendor 代码，vendor.manifest.json 是 vendor 文件的 node_modle 路径和 webpack 打包 id 的映射。</p><p>然后通过 DllReferencePlugin 将 vendor 引入业务代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里将生成的 vendor.dll.js 文件 copy 到 你需要的目录 </span></span><br><span class="line"><span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">  <span class="keyword">from</span>: <span class="string">'dist/vendor.dll.js'</span>,</span><br><span class="line">  to: config.build.assetsSubDirectory,</span><br><span class="line">  flatten: <span class="literal">true</span></span><br><span class="line">&#125;]),</span><br><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">  context: __dirname,</span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'../dist/vendor-manifest.json'</span>)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>最后还需要在 html 中引入生成的 DLL，网上有一些教程是直接把 script 标签写入 html 中的，但是由于我们多个项目同时依赖同一份 html 模板，其中某一些项目并不需要引入 DLL，比如一些静态页面。于是使用 html-webpack-include-assets-plugin 实现按需加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...pkgs.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = [<span class="keyword">new</span> HtmlWebpackPlugin(current.plugin)]</span><br><span class="line">  <span class="keyword">let</span> &#123;assets, filename&#125; = current.plugin || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (pre) res = [...pre, ...res]</span><br><span class="line">  <span class="keyword">if</span> (assets) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...res, <span class="keyword">new</span> HtmlWebpackIncludeAssetsPlugin(&#123;</span><br><span class="line">    files: [filename],</span><br><span class="line">    assets: assets.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;assetsSubDirectory&#125;</span>/<span class="subst">$&#123;item&#125;</span>`</span>),</span><br><span class="line">    append: <span class="literal">false</span>,</span><br><span class="line">    publicPath: assetsPublicPath</span><br><span class="line">    &#125;)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;, <span class="literal">null</span>),</span><br></pre></td></tr></table></figure><p>在 pkgs 中控制 HtmlWebpackPlugin 的参数，和是否需要引入 vendor.dll.js。</p><p>pkg 模板如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extChunks = IS_PROD ? [<span class="string">'manifest'</span>] : []</span><br><span class="line"><span class="keyword">const</span> chunksSortMode = IS_PROD ? <span class="string">'dependency'</span> : <span class="string">'auto'</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="string">'static/templates/index.pug'</span></span><br><span class="line"><span class="keyword">const</span> minfiy = &#123;&#125;</span><br><span class="line"></span><br><span class="line">exports pkg = &#123;</span><br><span class="line">  <span class="string">'index'</span>: &#123;</span><br><span class="line">    buddle: <span class="string">'server-index-bundle.js'</span>,</span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'...省略路径../entry.js'</span>),</span><br><span class="line">    plugin: &#123;</span><br><span class="line">      filename: <span class="string">'app/index.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'app'</span>, <span class="string">'vendor'</span>, <span class="string">'common'</span>, ...extChunks],</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      assets: [<span class="string">'vendor.dll.js'</span>],</span><br><span class="line">      chunksSortMode,</span><br><span class="line">      template,</span><br><span class="line">      minify</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 如果没有额外的依赖 assets 不用传</span></span><br><span class="line"> <span class="string">'404'</span>: &#123;</span><br><span class="line">    plugin: &#123;</span><br><span class="line">      filename: <span class="string">'404.html'</span>,</span><br><span class="line">      chunks: [<span class="string">'exception'</span>],</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      chunksSortMode,</span><br><span class="line">      template: <span class="string">'static/404.pug'</span>,</span><br><span class="line">      minify</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后可以明显看到 app.js 和 vendor.js 体积缩小，但是项目总体积略有增大。因为通过 DLL 的方式，额外存储了外部依赖的路径和 ID。</p><h3>alias 减少搜索路径</h3><p>这点想必大家都知道</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'static'</span>: path.resolve(__dirname, <span class="string">'../static'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可以用引用 node_modules 里面的方法引用 src 下面的模块</span></span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">'../src'</span>), <span class="string">"node_modules"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>多线程加速</h3><p>（1） uglifyjs-webpack-plugin 多线程提示 JS 压缩效率</p><p>使用 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a> 不仅可以加速 webpack 压缩 js 代码的速度，还能与 <a href="https://doc.webpack-china.org/guides/tree-shaking/" target="_blank" rel="noopener">webpack tree-shaking</a> 配合，减少代码体积。webpack 本身并不会执行 tree-shaking。它需要依赖于像 UglifyJS 这样的第三方工具来执行实际的未引用代码(dead code)删除工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UglifyJsParallelPlugin(&#123;</span><br><span class="line">  uglifyOptions: &#123;</span><br><span class="line">    ecma: <span class="number">8</span>,</span><br><span class="line">    mangle: <span class="literal">true</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      beautify: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    compress: &#123;</span><br><span class="line">      drop_console: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  sourceMap: <span class="literal">false</span>,</span><br><span class="line">  cache: <span class="literal">true</span>,</span><br><span class="line">  parallel: os.cpus().length * <span class="number">2</span>,</span><br><span class="line">  exclude: <span class="regexp">/\.min\.js$/</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>记得开启缓存，能有效提升打包效率。</p><p>（2） happypack 多线程提升 loader 执行效率。</p><p>使用 happypack 之前，你可以先去 <a href="https://github.com/amireh/happypack/wiki/Loader-Compatibility-List" target="_blank" rel="noopener">Loader Compatibility List</a> 看一下 happypack 的兼容性列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'cache-loader'</span>, <span class="comment">// 使用 cache-loader 缓存</span></span><br><span class="line">          options: &#123;</span><br><span class="line">          cacheDirectory: resolve(<span class="string">'node_modules/.cache'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'happypack/loader?id=babel'</span> <span class="comment">// 将 babel loader替换为 happypack</span></span><br><span class="line">      ],</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        include: [</span><br><span class="line">          resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)</span><br><span class="line">       ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">  <span class="comment">// 使用 happypack 插件</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123; </span><br><span class="line">  id: <span class="string">'babel'</span>,</span><br><span class="line">  threadPool: happyThreadPool,</span><br><span class="line">  verbose: <span class="literal">false</span>,</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader: <span class="string">`babel-loader`</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 happypack 后，性能比较差的 mac mini 速度反而降低了一些，但是性能比较强的编译机速度有不少的提升，所以 happypack 可以酌情使用，测试后发现速度有提升再加入，没有提升就果断弃用。</p><h3>缓存 HardSourceWebpackPlugin</h3><p><a href="https://github.com/mzgoddard/hard-source-webpack-plugin" target="_blank" rel="noopener">hard-source-webpack-plugin</a> 也是利用缓存效果提升打包速度。</p><blockquote><p>HardSourceWebpackPlugin is a plugin for webpack to provide an intermediate caching step for modules.</p></blockquote><p>用法很简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">'hard-source-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>dev 优化</h2><p>开发的时候，使用 koa-webpack-middleware 的 devMiddleware, hotMiddleware 两个中间件是提供 dev 服务和代码热新服务，devMiddleware 本质上是对 webpack-dev-middleware 的一层封装，而 hotMiddleware 是对 webpack-hot-middleware 的一层封装。</p><p>开发过程中，所有的代码均被载入两个 webpack 服务中，因此有一丁点的代码改动都需要重新编译所有的 buddle，这对开发过程是极其不好的体验，因此划分代码依赖，通过 npm 参数编译不同的项目，来达到加速开发的效果。</p><p>比如使用 <code>npm run dev project1</code> 来开发项目 project1，而其它代码并不加载到 webpack 中。</p><p>拿到 project1 参数可以通过 node.js 的 process 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> projects = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (!!projects &amp;&amp; projects.length) &#123;</span><br><span class="line">  <span class="comment">// filter your entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>总结</h2><p>以上打包优化都是参考网上的一些东西， 在实际使用过程中，发现有些文章内容是写了，但是并没有亲身实践，有些错误或者不完善的地方甚至都是一模一样的，所以自己结合实际项目走了一遍流程后，还是决定把东西写出来，希望对看到的人有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;webpack 打包优化&lt;/h2&gt;&lt;p&gt;最近项目不算忙，抽时间重构了一下项目的打包，先说一下成就。&lt;/p&gt;&lt;p&gt;在我的开发电脑上：&lt;/p&gt;&lt;p&gt;OS: macOS High Sierra&lt;br&gt;CPU: 2.6 GHz Intel Core i5&lt;br&gt;内存: 8G 1600 DDR3&lt;br&gt;硬盘: 1 TB SATA磁盘&lt;/p&gt;&lt;p&gt;代码全量编译时间从 4 分 51 秒优化到 2 分 08 - 20 秒左右。&lt;/p&gt;&lt;p&gt;在项目编译电脑上：&lt;/p&gt;&lt;p&gt;OS: Ubuntu 16.04.3 LTS&lt;br&gt;CPU: Intel® Core™ i5-7500 CPU @ 3.40GHz&lt;br&gt;内存: 64G 2133 DDR4&lt;br&gt;硬盘: 1 TB SSD&lt;/p&gt;&lt;p&gt;代码全量编译时间从 4 分 08 秒优化到 1 分 10 - 20 秒左右。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="webpack" scheme="https://lz5z.com/tags/webpack/"/>
    
      <category term="dll" scheme="https://lz5z.com/tags/dll/"/>
    
  </entry>
  
  <entry>
    <title>常用命令</title>
    <link href="https://lz5z.com/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://lz5z.com/常用命令/</id>
    <published>2017-12-20T08:56:26.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些常用的系统或者软件命令</p><h2>kill port</h2><p>linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看端口占用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i :8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结束进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">kill</span> -9 [pid]</span></span><br></pre></td></tr></table></figure><p>windows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看端口占用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -aon | findstr 8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pid 进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tasklist | findstr 19516</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结束进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> taskkill /pid 19516 /F</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用进程名字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> taskkill -F -IM node.exe</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2>定时关机</h2><p>linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">shutdown</span><br><span class="line">有如下选项：</span><br><span class="line">- k     =&gt;不执行任何关机操作，只发出警告信息给所有用户</span><br><span class="line">- r     =&gt; 重新启动计算机</span><br><span class="line">- h    =&gt; 关机并彻底断电</span><br><span class="line">- f     =&gt;快速关机且重启动时跳过fsck</span><br><span class="line">- n    =&gt;快速关机不经过init程序</span><br><span class="line">- c    =&gt; 取消之前的定时关机</span><br><span class="line">立即关机：shutdown -h now</span><br><span class="line">立即重启：shutdown -r now</span><br><span class="line">注意：now 不能省略</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -h +10 <span class="comment"># 10分钟后自动关机</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -h 10:00 <span class="comment"># 10点整关机</span></span></span><br></pre></td></tr></table></figure><p>windows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shutdown</span><br><span class="line">-a     =&gt;取消关机</span><br><span class="line">-s 关机</span><br><span class="line">-f     =&gt;强行关闭应用程序</span><br><span class="line">-l     =&gt;注销当前用户</span><br><span class="line">-r     =&gt;关机并重启</span><br><span class="line">-s -t 时间     =&gt;设置关机倒计时</span><br><span class="line">-h 休眠</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -s -t 3600  <span class="comment"># 一个小时候自动关机</span></span></span><br></pre></td></tr></table></figure><h2>刷新 dns hosts</h2><p>windows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipconfig /flushdns</span></span><br></pre></td></tr></table></figure><h2>Git</h2><h3>config</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的 Git 配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global] </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">"[name]"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">"[email address]"</span></span></span><br></pre></td></tr></table></figure><h3>add</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add -A (stage all files: new, modified, deleted)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .  (stage files: new, modified, deleted[version 2])</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -u (stage files: modified, deleted)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --ignore-removal . (stage files: new, modified)</span></span><br></pre></td></tr></table></figure><h3>commit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1][file2]... -m [message] <span class="comment"># file 要包含路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> amend 使用一次新的 commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1][file2]... -m[message]</span></span><br></pre></td></tr></table></figure><h3>pull</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br></pre></td></tr></table></figure><h3>push</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span></span><br></pre></td></tr></table></figure><h3>branch</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h3>cherry-pick</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit id]</span></span><br></pre></td></tr></table></figure><h3>remote</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些常用的系统或者软件命令&lt;/p&gt;&lt;h2&gt;kill port&lt;/h2&gt;&lt;p&gt;linux&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 查看端口占用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; lsof -i :8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 结束进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo &lt;span class=&quot;built_in&quot;&gt;kill&lt;/span&gt; -9 [pid]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;windows&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 查看端口占用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; netstat -aon | findstr 8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 查看 pid 进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; tasklist | findstr 19516&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 结束进程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; taskkill /pid 19516 /F&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 或者使用进程名字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; taskkill -F -IM node.exe&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="linux" scheme="https://lz5z.com/tags/linux/"/>
    
      <category term="windows" scheme="https://lz5z.com/tags/windows/"/>
    
      <category term="git" scheme="https://lz5z.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CSS 伪元素技巧</title>
    <link href="https://lz5z.com/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E6%8A%80%E5%B7%A7/"/>
    <id>https://lz5z.com/CSS伪元素技巧/</id>
    <published>2017-12-08T20:08:00.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>伪元素技巧</h2><p>在 <a href="https://lz5z.com/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">CSS 伪元素基本用法</a>一文中讲述了伪元素的基础功能，本章学习一些进阶功能，看看伪元素能实现哪些方便好用的功能。</p><h3>清除浮动</h3><p>如果一个元素内部的子元素全部都是浮动的话，那么这个元素会出现高度塌陷，这个时候就需要清除浮动。高度塌陷的负面作用主要有：不能正确显示背景，边框不能撑开，margin 和 padding 不能正确显示。</p><p>假设有代码如下：</p><a id="more"></a><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用伪元素清除浮动的办法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  zoom: 1; // IE6/7 兼容性</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.outer</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它清除浮动的办法：</p><p>（1）给父元素设置高度。<br>（2）<code>clear: both</code> 清除浮动。</p><p>常见的用法是在父元素结束之前，统一引入一个元素 <code>clear: both</code> 用来清除浮动。</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法实现起来很简单，不过缺点也很明显，引入了额外的 DOM 元素。</p><p>clear 属性可以对应的属性值有：</p><ul><li>left 在左侧不允许浮动元素。</li><li>right 在右侧不允许浮动元素。</li><li>both 在左右两侧均不允许浮动元素。</li><li>none 默认值。允许浮动元素出现在两侧。</li><li>inherit 规定应该从父元素继承 clear 属性的值。</li></ul><p>（3）给父级元素定义 <code>overflow: auto</code> 或者 <code>overflow: hidden</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  zoom: 1; // IE6/7 兼容性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 overflow 属性来清除浮动只可以使用 hiddent 和 auto 不能使用 visible。 为了兼容 IE 最好用 <code>overflow:hidden</code>，缺点是元素会被截断。</p><p>总结清除浮动最佳方案</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的 clearfix 方案</span><br><span class="line">// 引入了 zoom 以支持 IE6/7</span><br><span class="line">// 同时加入 :before 以解决现代浏览器上边距折叠的问题</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>扩大可点击范围</h3><p>这点在移动端开发显得尤为重要，可以增强用户体验。</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种不使用伪元素扩大可点击范围的方式是使用 border + background-clip</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">  <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>实现分割线效果</h3><!DOCTYPE html><html lang="en"><head><style>.divide{width:100%;text-align:center}.divide:after,.divide:before{content:"";position:absolute;margin:14px 14px 10px 10px;height:1px;width:calc(50% - 75px);background-color:red;padding:0 10px}.divide:before{left:0}.divide:after{right:0}</style></head><body><p class="divide">我是分割线</p></body></html><p>实现方式</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"divide"</span>&gt;</span>我是分割线<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.divide</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.divide</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.divide</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">14px</span> <span class="number">14px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(50% - 75px);</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.divide</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.divide</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>调用元素属性</h3><p>通过在 content 中使用 attr 函数可以调用元素的属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>引用媒体资源</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(https://lz5z.com/assets/img/avatar.svg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>计数器 counter</h3><ol><li>counter-reset：创建或者重置一个计数器</li><li>counter-increment：计数器递增</li><li>content：配合伪元素插入内容</li></ol><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"sites"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>Amazon<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>一共选择了<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"count"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>个网站<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sites</span> &#123;</span><br><span class="line">  <span class="attribute">counter-reset</span>: site;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sites</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: site;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.count</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(site);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>自制 checked 样式</h3><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Document</title><style>#sites li{margin:0 auto;width:30px;font-size:14px;line-height:1.5;cursor:pointer}#sites li:before{color:#7cfc00;background:#fff;border:2px solid #d3d3d3;content:" ";width:16px;height:16px;line-height:1;margin-left:-38px;position:absolute;text-align:center;vertical-align:middle;cursor:pointer;pointer-events:all}#sites li.checked:before{background:green;border:2px solid green;color:#fff;content:"\2714"}</style></head><body><ol id="sites"><li class="checked">Apple</li><li>Google</li><li class="checked">Amazon</li><li>Facebook</li></ol></body><script>function hasClass(el, className) {  if (el.classList) {    return el.classList.contains(className)  } else {    return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))  }}function addClass(el, className) {  if (el.classList) {    el.classList.add(className)  } else if (!hasClass(el, className)) {    el.className += ` ${className}`  }}function removeClass(el, className) {  if (el.classList) {    el.classList.remove(className)  } else if (hasClass(el, className)) {    let reg = new RegExp('(\\s|^)' + className + '(\\s|$)')    el.className = el.className.replace(reg, ' ')  }}function changeStyle(ele) {  if (hasClass(ele, 'checked')) {    removeClass(ele, 'checked')  } else {    addClass(ele, 'checked')  }}let sites = document.querySelector('ol#sites')// 事件委托sites.addEventListener('click', function(e) {  e = e || window.event  let target = e.target || e.srcElement  if (target.tagName.toLowerCase() === 'li') {    changeStyle(target)  }}, false)</script></html><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">id</span>=<span class="string">"sites"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"checked"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"checked"</span>&gt;</span>Amazon<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#7cfc00</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">38px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">pointer-events</span>: all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-class">.checked</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\2714"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>最后</h2><p>在网上还有很多关于伪元素的用法，非常有趣，既能减少 DOM 元素数量，还能用 CSS 实现一部分 JS 的功能，非常酷炫，后面见到有趣的用法会不断记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;伪元素技巧&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://lz5z.com/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/&quot;&gt;CSS 伪元素基本用法&lt;/a&gt;一文中讲述了伪元素的基础功能，本章学习一些进阶功能，看看伪元素能实现哪些方便好用的功能。&lt;/p&gt;&lt;h3&gt;清除浮动&lt;/h3&gt;&lt;p&gt;如果一个元素内部的子元素全部都是浮动的话，那么这个元素会出现高度塌陷，这个时候就需要清除浮动。高度塌陷的负面作用主要有：不能正确显示背景，边框不能撑开，margin 和 padding 不能正确显示。&lt;/p&gt;&lt;p&gt;假设有代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://lz5z.com/tags/CSS/"/>
    
      <category term="伪元素" scheme="https://lz5z.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
      <category term="清除浮动" scheme="https://lz5z.com/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS 伪元素基本用法</title>
    <link href="https://lz5z.com/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://lz5z.com/CSS伪元素基本用法/</id>
    <published>2017-12-08T18:06:19.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>伪元素</h1><p>CSS 中可以利用伪元素给 DOM 元素添加特殊的样式。比如说，我们可以通过 <code>:before</code> 在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><p>CSS3 规范中要求使用双冒号(::)添加伪元素，用以区分伪元素和伪类，比如 <code>::before</code> 是伪元素，<code>:hover</code> 是伪类。但是大部分伪元素依然支持单冒号的形式，<code>::before</code> 写成 <code>:before</code> 也可以，为了向后兼容，一般推荐使用单冒号的形式。</p><p>支持单双冒号的伪元素有： <code>:before/::before</code>，<code>:after/::after</code>，<code>:first-letter/::first-letter</code>，<code>:first-line/::first-line</code>。</p><p>仅支持双冒号的伪元素有： <code>::selection</code>，<code>::placeholder</code>，<code>::backdrop</code>。</p><a id="more"></a><h2><code>:before</code> &amp; <code>:after</code></h2><p><code>:before</code> 和 <code>:after</code> 可以在元素前面或者后面插入内容，用 content 属性表示要插入的内容，这个虚拟元素默认是行内元素，可以配合其它样式使用。</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'Hello'</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'World'</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p 元素会显示 <strong>Hello World</strong>，但是被插入的内容实际上不在文档树中。</p><h2><code>:first-letter</code></h2><p><code>:first-letter</code> 用来获取元素中文本的首字母，被修饰的首字母不在文档树中。注意没有 <code>:last-letter</code>。</p><p>首行只在 block-container box 内部才有意义, 因此 <code>:first-letter</code> 伪元素 只在 display 属性值为 block, inline-block, table-cell, list-item 或者 table-caption 的元素上才起作用。 其他情况下 <code>:first-letter</code> 毫无意义。</p><p><code>:first-letter</code> 的优先级低于 <code>:before</code>，也就是如果元素用 <code>:before</code> 先插入文本，会获取 before 伪元素中的内容。</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'Hello '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，<code>:first-letter</code> 实际获取的元素是 <code>：before</code> 中的 <strong>H</strong>。</p><p>注意： 在一个使用了 <code>:first-letter</code> 伪元素的选择器中，只有很小的一部分 css 属性能被使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter" target="_blank" rel="noopener">::first-letter</a></p><h2><code>:first-line</code></h2><p><code>:first-line</code> 用来获取 <strong>块状元素</strong> 中的第一行文本，不能用于内联元素。</p><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">br</span>&gt;</span>World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:first-line</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个使用了 ::first-line 伪元素的选择器中，只有很小的一部分css属性能被使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line" target="_blank" rel="noopener">::first-line</a></p><h2><code>::selection</code></h2><p><code>::selection</code> 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分），该伪元素只支持双冒号的形式。</p><p>只有 Gecko 引擎需要加前缀（-moz）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::-moz-selection</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-pseudo">::selection</span>  &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 只有一小部分 CSS 属性可以用于 <code>::selection</code> 选择器： color, background-color, cursor, outline, text-decoration, text-emphasis-color 和 text-shadow。要特别注意的是，background-image 会如同其他属性一样被忽略。</p><h2><code>::placeholder</code> (试验性质)</h2><p><code>:placeholder</code> 匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-moz-placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* IE 10 only */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-ms-input-placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Firefox 18 and below */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-moz-input-placeholder</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><code>::backdrop</code> (试验性质)</h2><p>用于改变全屏模式下背景色，全屏模式默认背景色为黑色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:fullscreen</span><span class="selector-pseudo">::backdrop</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>参考文章</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">MDN - Pseudo-elements</a></li><li><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">summary-of-pseudo-classes-and-pseudo-elements/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;伪元素&lt;/h1&gt;&lt;p&gt;CSS 中可以利用伪元素给 DOM 元素添加特殊的样式。比如说，我们可以通过 &lt;code&gt;:before&lt;/code&gt; 在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。&lt;/p&gt;&lt;p&gt;CSS3 规范中要求使用双冒号(::)添加伪元素，用以区分伪元素和伪类，比如 &lt;code&gt;::before&lt;/code&gt; 是伪元素，&lt;code&gt;:hover&lt;/code&gt; 是伪类。但是大部分伪元素依然支持单冒号的形式，&lt;code&gt;::before&lt;/code&gt; 写成 &lt;code&gt;:before&lt;/code&gt; 也可以，为了向后兼容，一般推荐使用单冒号的形式。&lt;/p&gt;&lt;p&gt;支持单双冒号的伪元素有： &lt;code&gt;:before/::before&lt;/code&gt;，&lt;code&gt;:after/::after&lt;/code&gt;，&lt;code&gt;:first-letter/::first-letter&lt;/code&gt;，&lt;code&gt;:first-line/::first-line&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;仅支持双冒号的伪元素有： &lt;code&gt;::selection&lt;/code&gt;，&lt;code&gt;::placeholder&lt;/code&gt;，&lt;code&gt;::backdrop&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://lz5z.com/tags/CSS/"/>
    
      <category term="伪元素" scheme="https://lz5z.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
      <category term="before" scheme="https://lz5z.com/tags/before/"/>
    
      <category term="after" scheme="https://lz5z.com/tags/after/"/>
    
  </entry>
  
  <entry>
    <title>HTML meta 标签</title>
    <link href="https://lz5z.com/html-meta/"/>
    <id>https://lz5z.com/html-meta/</id>
    <published>2017-12-02T15:22:13.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>引言</h1><p>最近做的一个关于电影的网站 <a href="https://movie.lz5z.com/" target="_blank" rel="noopener">IMDB Top250</a>，想对其进行 SEO 优化，用到 meta 信息的时候，很多知识都是 『似乎』、『好像』、『可能』 的感觉，回想自己一直没有系统的学习过 meta 相关的知识，这些东西虽然简单，但是很多时候能发挥出意想不到的效果，尤其对于 SEO 有非常重要的作用。</p><h2>meta 简介</h2><p>meta 标签位于文档的头部，可提供有关页面的元信息（meta-information）。 meta 标签本身不包含任何内容，通过其属性定义了与文档相关联的内容。</p><p>meta 标签一共有五个属性值： charset、content、http-equiv、name、scheme。 其中 http-equiv 和 name<br>必须与 content 配合组成键值对使用， charset 为 HTML5 属性， scheme 属性 HTML5 不支持。</p><a id="more"></a><h3>charset</h3><p>定义 HTML 文档编码方式，一般使用世界通用语言编码 UTF-8。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 HTML4 中的写法是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3>http-equiv</h3><p>http-equiv 为枚举属性，与 content 属性组成键值对，一般用于服务器向浏览器传回一些特定的信息，以帮助浏览器编译和显示页面内容。虽然有些服务器会发送许多这种键值对，但是所有服务器都至少要发送一个：<code>content-type:text/html</code>。这将告诉浏览器准备接收一个 HTML 文档。</p><p>http-equiv 可枚举的值有： content-type, default-style, refresh。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"3;URL=https://lz5z.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上表示页面 3 秒后自动跳转。</p><h3>name</h3><p>name 属性是用的最多的属性，常用的有 description，keywords，author，viewport，generator 等等。</p><p>其中 keywords 对应 content 用逗号分隔，description 为搜索引擎显示网页时候的简介。</p><p>viewport 用于指定视窗的属性，在移动端开发时显得尤为重要。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"HTML5,meta"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"blabla"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一些属性值，比如 referrer，robots，renderer。</p><p>(1) referrer 控制所有从该文档发出的 HTTP 请求中 HTTP Referer 头的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referer"</span> <span class="attr">content</span>=<span class="string">"always"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>referrer 对应的 content 属性可取的值：</p><ul><li><code>no-referrer</code>不要发送 HTTP Referer 首部。</li><li><code>origin</code>发送当前文档的 origin。</li><li><code>no-referrer-when-downgrade</code>当目的地是先验安全的(https-&gt;https)则发送 origin 作为 referrer ，但是当目的地是较不安全的 (https-&gt;http)时则不发送 referrer 。这个是默认的行为。</li><li><code>origin-when-crossorigin</code>在同源请求下，发送完整的URL (不含查询参数) ，其他情况下则仅发送当前文档的 origin。</li><li><code>unsafe-URL</code>在同源请求下，发送完整的URL (不含查询参数)。</li></ul><blockquote><p>HTTP Referer 头：<br>Referer 请求头字段允许由客户端指定资源的 URI 来自于哪一个请求地址，这对服务器有好处。Referer 请求头让服务器能够拿到请求资源的来源，可以用于分析用户的兴趣爱好、收集日志、优化缓存等等。同时也让服务器能够发现过时的和错误的链接并及时维护。</p></blockquote><p>注意：动态地插入 <code>&lt;meta name=&quot;referrer&quot;&gt;</code> (通过 document.write 或者 appendChild) 是不起作用的。同样注意如果同时有多个彼此冲突的策略被定义，那么 no-referrer 策略会生效。</p><p>(2) robots 用来告诉搜索引擎的爬虫哪些页面需要索引，哪些不需要索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>robots 对应的 content 可取的值：</p><ul><li>all：文件将被检索，且页面上的链接可以被查询。</li><li>none：文件将不被检索，且页面上的链接不可以被查询。</li><li>index：文件将被检索。</li><li>follow：页面上的链接可以被查询。</li><li>noindex：文件将不被检索，但页面上的链接可以被查询。</li><li>nofollow：文件将被检索，但页面上的链接不可以被查询。</li></ul><p>还有一些只有固定的搜索引擎支持的参数，比如 noodp，noarchive 等，这里就不说明了。</p><p>(3) renderer</p><p>renderer 并不是 w3c 标准，但却经常见于一些网页中，这个属性主要用于双核或者多核浏览器（猎豹浏览器，360浏览器）使用指定的内核处理自己的网页。目前大多数 「双核」 浏览器内部的两个内核分别是 IE 内核和 WebKit 内核，IE 内核主要用于兼容「老一辈」的网页，使其能够正常显示；WebKit 内核则用于渲染「新一代」的网页，从而发挥出更快的显示速度、更好的显示效果、更优异的脚本执行性能。</p><p>作为用户来说并不关心你使用哪个内核，简单易用才是王道，因此在网页中设置首选内核会让网页有更好的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit|ie-stand"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>renderer</code> 对应的 content 用于指定浏览器内核，<br>webkit(WebKit 内核)、ie-stand(IE 内核-标准模式)、ie-comp(IE 内核-兼容模式)。我们也可以同时指定多个内核名称，之间以符号&quot;|&quot;进行分隔，此时浏览器将会按照从左到右的先后顺序选择其具备的渲染内核来处理当前网页。</p><p>IE8 有自己独特的写法 X-UA-Compatible 对于 IE8 之外的浏览器是不识别的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Edge 模式通知 IE 以最高级别的可用模式显示内容</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"edge"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// 如果 IE 有安装 Google Chrome Frame，那么就走安装的组件，如果没有就和上面一样。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注： 如果设置浏览器内核为 Webkit (极速模式)，打开网页后却为 IE (兼容模式)，尝试刷新浏览器则会自动切换模式。</p></blockquote><p>通常是这样设置的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(4) format-detection</p><p>防止 ios 把数字/字符串识别为电话/邮件/日期/地址</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"date=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"address=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">MDN-meta</a><br><a href="http://web.jobbole.com/86648/" target="_blank" rel="noopener">关于控制 Referer 你想要知道的一切</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;引言&lt;/h1&gt;&lt;p&gt;最近做的一个关于电影的网站 &lt;a href=&quot;https://movie.lz5z.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMDB Top250&lt;/a&gt;，想对其进行 SEO 优化，用到 meta 信息的时候，很多知识都是 『似乎』、『好像』、『可能』 的感觉，回想自己一直没有系统的学习过 meta 相关的知识，这些东西虽然简单，但是很多时候能发挥出意想不到的效果，尤其对于 SEO 有非常重要的作用。&lt;/p&gt;&lt;h2&gt;meta 简介&lt;/h2&gt;&lt;p&gt;meta 标签位于文档的头部，可提供有关页面的元信息（meta-information）。 meta 标签本身不包含任何内容，通过其属性定义了与文档相关联的内容。&lt;/p&gt;&lt;p&gt;meta 标签一共有五个属性值： charset、content、http-equiv、name、scheme。 其中 http-equiv 和 name&lt;br&gt;必须与 content 配合组成键值对使用， charset 为 HTML5 属性， scheme 属性 HTML5 不支持。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://lz5z.com/categories/HTML/"/>
    
    
      <category term="HTML5" scheme="https://lz5z.com/tags/HTML5/"/>
    
      <category term="meta" scheme="https://lz5z.com/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>迁移 github pages 到 coding.net</title>
    <link href="https://lz5z.com/%E8%BF%81%E7%A7%BBBlog%E5%88%B0Coding/"/>
    <id>https://lz5z.com/迁移Blog到Coding/</id>
    <published>2017-10-27T15:37:59.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因，github 在国内时不时不能访问，虽然有各种办法可以跨越屏障，但是你不能用预测未来会发生哪些事情，于是决定将博客迁移到国内，<a href="https://coding.net" target="_blank" rel="noopener">coding</a> 是一个不错的选择，主要有以下几个优点。</p><ul><li>国内速度更快</li><li>自带 SSL，且免费</li><li>五个免费的私人仓库</li><li>功能较全: pages, webIDE, CI 等</li><li>经过一段时间迭代，产品经得起考验</li></ul><a id="more"></a><h2>步骤</h2><p>首先直接从 github 把 blog 项目导入到 coding，项目名称命名为 [name].coding.me，相当于 github 上面的 [name].github.io。</p><p>进入项目代码，点击左侧 『代码 -&gt; Pages 服务』，选择静态 Pages 服务，coding 部署来源仅支持 coding-pages 分支和 master 分支，所以选择 master 分支。</p><img src="/assets/img/coding.png" alt="我是一只图片"><p>这时，通过 [name].coding.me 就能够访问页面了，但是这还远远不够，我们还需要添加自定义域名和开启 SSL 服务。</p><h2>自定义域名 SSL</h2><p>首先确保项目根目录中有 CNAME 文件，里面是自己的域名，比如我的域名 <strong><a href="http://lz5z.com">lz5z.com</a></strong>，然后在 coding 页面自定义域名中输入此域名，并且开启强制 HTTPS 访问。</p><img src="/assets/img/coding_pages.png" alt="我是一只图片"><p>然后去自己域名服务商那里修改 DNS Server，我的域名在万网购买，于是在万网控制台添加一个 CNAME 记录和一个 A 记录，加上之前 github pages 添加的主机记录，截图如下。</p><img src="/assets/img/coding_dns.png" alt="我是一只图片"><p>红色部分为新添加的记录，如果不知道 <a href="http://coding.net" target="_blank" rel="noopener">coding.net</a> 的 ip 地址的话，可以手动 ping 一下。</p><p>由于之前使用 cloudflare 的免费 SSL 服务而将 DNS Server 的地址指向了 cloudflare，这个时候把地址改回万网默认配置即可。</p><p>经过漫长的等待，DNS 解析生效，此时通过 <a href="https://lz5z.com">https://lz5z.com</a> 访问，发现域名已经生效了，但是存在两个问题：</p><ul><li>国内地址访问网站， SSL 没有问题，但是国外访问时 SSL 会报错，在 chrome 中有一个不能忍受的警告。</li><li>每次访问博客地址的时候，首先会看到一个 coding 的广告，然后再重定向到自己要访问的地址，这也是不能忍受的。</li></ul><h3>解决 SSL 证书错误</h3><p>国外地址访问网站报 SSL 不合法主要是因为这个原因：</p><blockquote><p>注意：申请 SSL/TLS 证书需要通过 Let’s Encrypt 的 HTTP 方式验证域名所有权。如果您的域名在境外无法访问 Coding Pages 的服务器，将导致 SSL/TLS 证书申请失败。</p></blockquote><p>查阅资料发现大家的解决方式都是设置双线解析，也就是国外访问通过 github pages，国内访问通过 <a href="http://coding.net" target="_blank" rel="noopener">coding.net</a>，因此要为域名设置解析路线，如果域名服务商自定义解析路线，可以选择免费的 <a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSPod</a> 做 DNS 解析。</p><p>DNSPod 提供双线解析的原理我不是很明白，而且比较困惑的是 github pages 自定义域名原生是不资辞 SSL 的，之前的做法是使用 cloudflare 的 SSL 服务进行重定向，假如使用双线解析的话，那国外地址为什么能够看到合法的 SSL 呢？</p><p>而且按照网上的做法改了 DNS 解析后，并没有发生双线解析，无论是国外还是国内都是解析到 <a href="http://coding.net" target="_blank" rel="noopener">coding.net</a>，但是解决了国外地址访问报 SSL 证书错误的问题。着实很奇怪，以下是我的做法。</p><h3>DNSPod</h3><p>注册 -&gt; 登录 -&gt; 实名认证 -&gt; 进入控制台 -&gt; 添加域名</p><p>添加域名的时候 DNSPod 会自动监测域名之前的解析情况，然后用 DNSPod 服务器提供的 DNS 地址替代万网提供的地址。</p><p>DNSPod DNS 记录如下：</p><img src="/assets/img/coding_dnspod.png" alt="我是一只图片"><p>更改万网 DNS Server 为 DNSPod:</p><img src="/assets/img/coding_dnsserver.png" alt="我是一只图片"><p>再次经过漫长的等待，DNS 生效后，无论国内国外访问网站都是合法的 SSL，excited！</p><h3>解决 coding 广告后重定向</h3><p>每次新建隐私窗口打开网站都是先看 coding 的广告，然后再重定向到之前的地址，这是极差的用户体验，不过 coding 官方提供了解决办法，简单的就是购买 coding 的会员，免费的办法就是在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，具体办法参考 coding pages 服务的说明。添加之后勾选 <strong>已放置 Hosted by Coding Pages</strong>，等待一天或者两天就生效了。</p><h2>总结</h2><p>这次切换 github pages 到 <a href="http://coding.net" target="_blank" rel="noopener">coding.net</a> 真的费时费力，不过好在现在网页能够正常访问，而且速度也比之前快很多，所以还是比较满意的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于众所周知的原因，github 在国内时不时不能访问，虽然有各种办法可以跨越屏障，但是你不能用预测未来会发生哪些事情，于是决定将博客迁移到国内，&lt;a href=&quot;https://coding.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;coding&lt;/a&gt; 是一个不错的选择，主要有以下几个优点。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;国内速度更快&lt;/li&gt;&lt;li&gt;自带 SSL，且免费&lt;/li&gt;&lt;li&gt;五个免费的私人仓库&lt;/li&gt;&lt;li&gt;功能较全: pages, webIDE, CI 等&lt;/li&gt;&lt;li&gt;经过一段时间迭代，产品经得起考验&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="github pages" scheme="https://lz5z.com/tags/github-pages/"/>
    
      <category term="coding.net" scheme="https://lz5z.com/tags/coding-net/"/>
    
      <category term="SSL" scheme="https://lz5z.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>解决 webpack 打包后 z-index 重新计算的问题</title>
    <link href="https://lz5z.com/%E8%A7%A3%E5%86%B3webpack%E6%89%93%E5%8C%85%E5%90%8Ez-index%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://lz5z.com/解决webpack打包后z-index重新计算的问题/</id>
    <published>2017-10-24T13:18:37.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>背景</h2><p>与 PC 端共同开发一个页面，页面由 PC 端提供，内部 iframe 则由我们前端提供。开发时候遇到了一个问题，webpack 打包后 css 的 z-index 值与原始值不符，导致 iframe 里面的 toast 被外面 z-index 较小的 dialog 覆盖。更改 toast 的 z-index，发现没起作用，页面上的 z-index 依然是之前的值，而不是 css 中赋予的值。给 z-index 加上 !important 后依然无效，查资料发现是 OptimizeCssAssetsPlugin 调用 cssProcessor cssnano 对 z-index 进行了重新计算导致的。</p><p>这本来是 webpack 插件的一个善举（让 z-index 数值更加合理），但是具体情况来看，这里显然不需要这个 “善举”。</p><a id="more"></a><h2>解决方案</h2><p>解决方案按照网上的资料，可以在 OptimizeCssAssetsPlugin 插件中关掉 <a href="http://cssnano.co/" target="_blank" rel="noopener">cssnano</a> 对 z-index 的重新计算（cssnano 称为 rebase）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OptimizeCSSPlugin(&#123;</span><br><span class="line">    cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">    cssProcessorOptions: &#123;</span><br><span class="line">        discardComments: &#123;<span class="attr">removeAll</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">        <span class="comment">// 避免 cssnano 重新计算 z-index</span></span><br><span class="line">        safe: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    canPrint: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>cssnano 将 z-index rebase 归类为 unsafe，只有在单个网页的 css 全部写入一个 css 文件，并且不通过 JavaScript 进行改动时是 safe。</p><p>参考： <a href="http://cssnano.co/optimisations/zindex/" target="_blank" rel="noopener">http://cssnano.co/optimisations/zindex/</a></p><p>cssnano 默认进行 z-index rebase。</p><p>unsafe (potential bug) 优化项默认不开启应该比较友好。</p><h2>另外一个方案</h2><p>以上是网上提供的方案，而且亲测有效，但是由于项目太大，因为其中一个小功能改了整个项目的 css 处理策略，难免有些担心会影响到其它页面。思考再三，决定不改 webpack 配置。</p><p>观察之前项目中使用的框架，在生成 dialog 或者 toast 的时候，即使在 webpack 插件对 css 进行处理之后，其 z-index 依然是很大的。</p><p>比如 element-ui 下 的 popup-manager.js 中首先设置 zIndex 为 2000，然后在 openModal 的时候动态添加 css 到 DOM 中，并且改变 zIndex 的值，而在浏览器中观察弹框的 z-index，果然是没有经过 cssnano rebase 的。</p><p>于是仿照 element-ui 的做法，把 z-index 相关的 css 用 js 动态插入到 DOM 中，就完美地解决了这个问题，并且没有对其它项目产生影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改变 toast 的 z-index</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">addToastStyle</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nod = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">`.mint-toast&#123;z-index:2009;&#125;`</span></span><br><span class="line">    nod.type = <span class="string">'text/css'</span></span><br><span class="line">    nod.appendChild(<span class="built_in">document</span>.createTextNode(str))</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(nod)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2>总结</h2><p>webpack 在对代码进行打包之前，会扫描所有的模块，建立模块之间的依赖树，而插件的运作时机也是相对于此时的静态代码，因此用 js 动态插入 css，webpack 显然不会知道要插入的 css 是什么样的，因此动态插入的 css 内容就不会经过插件的处理，也就避免了 OptimizeCssAssetsPlugin 的 “善举”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;与 PC 端共同开发一个页面，页面由 PC 端提供，内部 iframe 则由我们前端提供。开发时候遇到了一个问题，webpack 打包后 css 的 z-index 值与原始值不符，导致 iframe 里面的 toast 被外面 z-index 较小的 dialog 覆盖。更改 toast 的 z-index，发现没起作用，页面上的 z-index 依然是之前的值，而不是 css 中赋予的值。给 z-index 加上 !important 后依然无效，查资料发现是 OptimizeCssAssetsPlugin 调用 cssProcessor cssnano 对 z-index 进行了重新计算导致的。&lt;/p&gt;&lt;p&gt;这本来是 webpack 插件的一个善举（让 z-index 数值更加合理），但是具体情况来看，这里显然不需要这个 “善举”。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="webpack" scheme="https://lz5z.com/tags/webpack/"/>
    
      <category term="css" scheme="https://lz5z.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件权限</title>
    <link href="https://lz5z.com/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>https://lz5z.com/Linux文件权限/</id>
    <published>2017-10-10T19:06:38.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>linux 文件属性</h2><p>linux 中用户相对于文件有三种身份：owner、group、others，每种身份各有 read、write、execute 三种权限。</p><p>使用 <code>ls -l</code> 命令可以查看与文件权限相关的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">drwxr-xr-x  2 lizhen  staff  68 10 10 19:14 foo</span><br><span class="line">-rw-r--r--  1 lizhen  staff   0 10 10 19:14 test.txt</span><br><span class="line">lrwxr-xr-x  1 lizhen  staff  62  7 10 10:01 subl -&gt; /Applications/Sublime Text.app/Contents/SharedSupport/bin/subl</span><br></pre></td></tr></table></figure><p>其中第一个字符表示文件类型：d 表示文件为一个目录，- 表示文件为普通文件，l 表示链接， b 表示设备文件。</p><p>接下来的字符中，以三个为一组，且均为 r(read)、 w(write)、 x(execute) 三个参数的组合，首先三个字符表示文件所有者权限，后面三个字符表示用户组权限，最后三个表示其他人对文件的权限。这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]。</p><img src="/assets/img/linux_permission.png" alt="linux_permission"><p>后面的字段分别代表：硬链接个数，所有者，所在组，文件或者目录大小，最后访问/修改时间，文件或者目录名。</p><a id="more"></a><h2>更改文件属性</h2><p>chgrp：改变文件所属群组 change group<br>chown：改变文件拥有者 change owner<br>chmod：改变文件的权限 change mod</p><h3>chgrp</h3><p>首先使用 groups 命令查看当前用户在哪些分组中，然后使用 chgrp 命令改变文件所属用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chgrp -R admin foo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l </span></span><br><span class="line">drwxr-xr-x  2 lizhen  admin  68 10 10 19:14 foo</span><br></pre></td></tr></table></figure><p>-R 表示递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 参数，那么该目录下的所有文件的属组都会更改。可以通过 <code>/etc/group</code> 查看当前系统所有的分组。</p><p>可以看到文件分组由 staff 变成了 admin。</p><h3>chown</h3><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure><p>chown 可以更改文件的 owner，也可以同时更改文件属组。假如当前系统中有一个名为 test 的用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R <span class="built_in">test</span> foo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">drwxr-xr-x  2 test   admin  68 10 10 19:14 foo</span><br></pre></td></tr></table></figure><p>此时 foo 的 owner 变成了 test。可以通过 <code>/etc/passwd</code> 文件查看当前系统所有的用户。</p><p>chown 还可以用户修改文件所在的分组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chown [-R] lizhen:staff foo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">drwxr-xr-x  2 lizhen  staff  68 10 10 19:14 foo</span><br></pre></td></tr></table></figure><p>文件属性又变回去了。</p><h3>chmod</h3><p>chmod 用来更改文件属性，权限可以使用符号或数字来表示。</p><p>使用符号表示权限：</p><p>[ + ]为文件或目录增加权限<br>[ - ]删除文件或目录的权限<br>[ = ]设置指定的权限</p><p>通过使用 u(owner)、g(group)、o(other) 来代表三种身份的权限，此外 a 代表 all，即全部身份。</p><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u/g/o/a +/-/= r/w/x filename</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l test.txt</span></span><br><span class="line">-rw-r--r--  1 lizhen  staff  0 10 10 20:33 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 owner 权限增加 execute，group 和 others 减少 read</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u+x,g-r,o-r test.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l test.txt</span></span><br><span class="line">-rwx------  1 lizhen  staff  0 10 10 20:33 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 owner 权限为 rw，group 和 others 为 r</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u=rw,g=r,o=r test.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l test.txt</span></span><br><span class="line">-rw-r--r--  1 lizhen  staff  0 10 10 20:33 test.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 增加所有用户的执行权限</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod a+x test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l test.txt</span></span><br><span class="line">-rwxr-xr-x  1 lizhen  staff  0 10 10 20:33 test.txt</span><br></pre></td></tr></table></figure><p>使用数字改变权限：</p><p>x: 1<br>w: 2<br>r: 4</p><p>所以权限 <code>rwx</code> 就等于 <code>4 + 2 + 1 = 7</code>，也就是 <code>chmod a=rwx file</code> 相当于 <code>chmod 777 file</code>。</p><p>-rw——- (600) 只有所有者才有读和写的权限<br>-rw-r–r– (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限<br>-rwx—— (700) 只有所有者才有读，写，执行的权限<br>-rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限<br>-rwx–x–x (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限<br>-rw-rw-rw- (666) 每个人都有读写的权限<br>-rwxrwxrwx (777) 每个人都有读写和执行的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 711 test.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l test.txt </span></span><br><span class="line">-rwx--x--x  1 lizhen  staff  0 10 10 20:33 test.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;linux 文件属性&lt;/h2&gt;&lt;p&gt;linux 中用户相对于文件有三种身份：owner、group、others，每种身份各有 read、write、execute 三种权限。&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;ls -l&lt;/code&gt; 命令可以查看与文件权限相关的信息：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ls -l&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;drwxr-xr-x  2 lizhen  staff  68 10 10 19:14 foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-r--r--  1 lizhen  staff   0 10 10 19:14 test.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lrwxr-xr-x  1 lizhen  staff  62  7 10 10:01 subl -&amp;gt; /Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;其中第一个字符表示文件类型：d 表示文件为一个目录，- 表示文件为普通文件，l 表示链接， b 表示设备文件。&lt;/p&gt;&lt;p&gt;接下来的字符中，以三个为一组，且均为 r(read)、 w(write)、 x(execute) 三个参数的组合，首先三个字符表示文件所有者权限，后面三个字符表示用户组权限，最后三个表示其他人对文件的权限。这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]。&lt;/p&gt;&lt;img src=&quot;/assets/img/linux_permission.png&quot; alt=&quot;linux_permission&quot;&gt;&lt;p&gt;后面的字段分别代表：硬链接个数，所有者，所在组，文件或者目录大小，最后访问/修改时间，文件或者目录名。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://lz5z.com/categories/Linux/"/>
    
    
      <category term="权限" scheme="https://lz5z.com/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>ES2016 和 ES2017 学习</title>
    <link href="https://lz5z.com/ES2016%E5%92%8CES2017%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lz5z.com/ES2016和ES2017学习/</id>
    <published>2017-09-12T16:26:44.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 发布之后，TC-39 小组每年发布一次 ECMAScript 语言新特性，这个 repository <a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">tc39/ecma262</a> 中记录着最新版的提议。新版本的 ECMAScript 使用年份来表示版本，所以 ES6 被称为 ES2015， ES7 被称为 ES2016，所以标准起见，以后我们也称之为 ES2016 和 ES2017。</p><h2>ECMAScript 2016</h2><p>ES2016 只有两个新特性</p><ol><li>Array.prototype.includes</li><li>求冥运算(Exponentiation Operator)</li></ol><a id="more"></a><h3>Array.prototype.includes</h3><p>includes 查找一个值是否在数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>)         <span class="comment">//true</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].includes(<span class="string">'d'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>includes 还可以接收两个参数，第一个表示要查找的值，第二个表示从数组第 N 个元素开始查找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">2</span>)  <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>)  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>) <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意上面 <code>[1, 2, NaN].includes(NaN)</code> 的返回值为 true，虽然 <code>NaN === NaN</code> 的结果为 false，所以『包含』和『相等』还是有区别的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tt = [<span class="number">-0</span>, <span class="number">1</span>, <span class="literal">NaN</span>]</span><br><span class="line">tt.includes(<span class="number">0</span>)   <span class="comment">// true</span></span><br><span class="line">tt.indexOf(<span class="literal">NaN</span>)  <span class="comment">// -1</span></span><br><span class="line">tt.includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>测试发现 includes 和 indexOf 在 node 8 / chrome 61 下速度差异不大，因此在使用的时候不用考虑性能的问题。</p><p>在 ES2015 中，String 对象也有 includes 方法，String.prototype.includes，但是只能用于 String，不能用于 characters。</p><h3>幂运算 Exponentiation operator</h3><p>ES2016 新增幂运算符改进语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> ** <span class="number">3</span> <span class="comment">// 27</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">5</span>, <span class="number">2</span>) === <span class="number">5</span> ** <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line">a **= <span class="number">3</span> <span class="comment">// 27</span></span><br></pre></td></tr></table></figure><p>幂运算符的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">优先级</a>高于二元运算符，低于一元运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * <span class="number">5</span> ** <span class="number">2</span>  <span class="comment">// 50</span></span><br><span class="line">-(<span class="number">5</span> ** <span class="number">2</span>)   <span class="comment">// -25</span></span><br><span class="line">(<span class="number">-5</span>) ** <span class="number">2</span>   <span class="comment">// 25</span></span><br><span class="line"><span class="comment">// 运算符左侧不能是除了 ++ 或 -- 之外的任意一元表达式</span></span><br><span class="line"><span class="number">-5</span> ** <span class="number">2</span>     <span class="comment">// Uncaught SyntaxError: Unexpected token ** </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">2</span></span><br><span class="line">++num ** <span class="number">2</span>    <span class="comment">// 9</span></span><br><span class="line">num-- ** <span class="number">2</span>    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h2>ECMAScript 2017</h2><p>主要新特性：</p><ol><li>异步函数(Async/Await)</li><li>共享内存和原子(Shared memory and atomics)</li></ol><p>小改款</p><ol><li>Object.values() 和 Object.entries()</li><li>字符串填充(padStart 和 padEnd)</li><li>Object.getOwnPropertyDescriptors()</li><li>函数参数列表和调用中的尾逗号(Trailing commas)</li></ol><h3>async/await</h3><ul><li>async 函数声明： async function foo () {}</li><li>async 函数表达式： const foo = async function () {}</li><li>async 函数定义： let obj = { async foo () {} }</li><li>async 箭头函数： const foo = async () =&gt; {}</li></ul><p>关于 async/await 很早以前就写过了，而且现在基本上已经成了异步代码必备了，这里就不赘述了。</p><p>详情参考<a href="https://lz5z.com/JavaScript%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">JavaScript异步解决方案async/await</a></p><h3>共享内存和原子(Shared memory and atomics)</h3><p>共享内存和原子内容比较多，后面会单独写一篇文章，暂时留坑。</p><h3>Object.entries() 和 Object.values()</h3><p>(1) Object.entries()</p><p>该方法将一个对象中所有可枚举的属性与值按照二维数组的方式返回，如果对象是数组，则数组的下标作为键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>&#125;) <span class="comment">// [['one', 1], ['two', 2]]</span></span><br><span class="line"><span class="built_in">Object</span>.entries([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// [['0', 1], ['1', 2]]</span></span><br></pre></td></tr></table></figure><p>返回数组的顺序与 Object.keys() 一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="number">3</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">1</span>: <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)  <span class="comment">// [['1', 'c'], ['2', 'b'], ['3', 'c']]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)     <span class="comment">// ['1', '2', '3']</span></span><br></pre></td></tr></table></figure><p>Object.entries() 会忽略对象中 key 为 Symbol 的键值对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">'abc'</span> &#125;) <span class="comment">// [ [ 'foo', 'abc' ] ]</span></span><br></pre></td></tr></table></figure><p>通过 Object.entries() 设置一个 Map 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(&#123;</span><br><span class="line">    one: <span class="number">1</span>,</span><br><span class="line">    two: <span class="number">2</span>,</span><br><span class="line">&#125;))</span><br><span class="line"><span class="built_in">JSON</span>.stringify([...map])  <span class="comment">// [["one",1],["two",2]]</span></span><br></pre></td></tr></table></figure><p>通过 Object.entries() 遍历对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// "one": 1</span></span><br><span class="line"><span class="comment">// "two": 2</span></span><br></pre></td></tr></table></figure><p>(2) Object.values()</p><p>该方法返回对象可枚举键值对中所有的 value。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;)  <span class="comment">// [ 1, 2 ]</span></span><br></pre></td></tr></table></figure><h3>字符串填充(padStart 和 padEnd)</h3><p>(1) String.prototype.padStart</p><p>padStart 函数通过填充字符串首部使字符串达到一定的长度。该方法接受两个参数，第一个表示目标字符串长度，第二个表示填充内容，默认填充内容为空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>)         <span class="comment">// "       abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">"foo"</span>)  <span class="comment">// "foofoofabc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">6</span>,<span class="string">"123465"</span>) <span class="comment">// "123abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">8</span>, <span class="string">"0"</span>)     <span class="comment">// "00000abc"</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">1</span>)          <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure><p>(2) String.prototype.padEnd</p><p>padEnd 填充字符串的时候从尾部开始填充，其它均与 padStart 相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.padEnd(<span class="number">10</span>)          <span class="comment">// "abc       "</span></span><br><span class="line"><span class="string">'abc'</span>.padEnd(<span class="number">10</span>, <span class="string">"foo"</span>)   <span class="comment">// "abcfoofoof"</span></span><br><span class="line"><span class="string">'abc'</span>.padEnd(<span class="number">6</span>, <span class="string">"123456"</span>) <span class="comment">// "abc123"</span></span><br><span class="line"><span class="string">'abc'</span>.padEnd(<span class="number">1</span>)           <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure><h3>Object.getOwnPropertyDescriptors()</h3><p>该方法获取目标对象所有属性的属性描述符，该属性必须是自己定义的，不能是通过原型链继承来的。</p><p>关于属性描述符的作用，可以查看<a href="https://lz5z.com/Object.defineProperty%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/">使用 Object.defineProperty 为对象定义属性</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="number">123</span>,</span><br><span class="line">    get bar() &#123; <span class="keyword">return</span> <span class="string">'abc'</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &#123; [Symbol('foo')]:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>使用 Object.assign() copy 一个对象/属性 的时候，不能正确 copy 属性的 get 和 set，而通过 getOwnPropertyDescriptors() 能够实现正确 copy 一个对象/对象属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo =  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">        name = newName</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(result, Leo)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(result, <span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// &#123;value: "", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>我们发现通过 Object.assign() copy 后的 ‘name’ 属性，其 ‘get’, ‘set’ 属性不见了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(result2, <span class="built_in">Object</span>.getOwnPropertyDescriptors(Leo))</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(result2, <span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// &#123;enumerable: true, configurable: true, get: ƒ, set: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>使用 Object.getOwnPropertyDescriptors 配合 Object.defineProperties 就可以实现正确 copy 了。</p><h3>函数参数列表和调用中的尾逗号(Trailing commas)</h3><p>这个新特性很简单，就是允许我们在定义或者调用函数的时候参数后面多加一个逗号而不报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b,</span>) </span>&#123;&#125; <span class="comment">// correct</span></span><br><span class="line"></span><br><span class="line">foo (<span class="string">'abc'</span>, <span class="string">'def'</span>,)  <span class="comment">// correct</span></span><br></pre></td></tr></table></figure><p>在数组和对象中这样的写法也没有问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>,]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">first: <span class="string">'Leo'</span>,</span><br><span class="line">last: <span class="string">'Li'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入这个特性的好处就是当我们调整参数或者代码结构的时候，不需要再额外地添加或者删除逗号了，尤其是对代码进行注释的时候会方便很多。在版本管理上，不会因为出现一个逗号，导致原本只有一行的修改变成两行。</p><h2>参考资料</h2><p><a href="http://exploringjs.com/es2016-es2017/" target="_blank" rel="noopener">Exploring ES2016 and ES2017</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 发布之后，TC-39 小组每年发布一次 ECMAScript 语言新特性，这个 repository &lt;a href=&quot;https://github.com/tc39/ecma262&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tc39/ecma262&lt;/a&gt; 中记录着最新版的提议。新版本的 ECMAScript 使用年份来表示版本，所以 ES6 被称为 ES2015， ES7 被称为 ES2016，所以标准起见，以后我们也称之为 ES2016 和 ES2017。&lt;/p&gt;&lt;h2&gt;ECMAScript 2016&lt;/h2&gt;&lt;p&gt;ES2016 只有两个新特性&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Array.prototype.includes&lt;/li&gt;&lt;li&gt;求冥运算(Exponentiation Operator)&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="ES7" scheme="https://lz5z.com/tags/ES7/"/>
    
      <category term="ES8" scheme="https://lz5z.com/tags/ES8/"/>
    
      <category term="ES2016" scheme="https://lz5z.com/tags/ES2016/"/>
    
      <category term="ES2017" scheme="https://lz5z.com/tags/ES2017/"/>
    
  </entry>
  
  <entry>
    <title>vue2 组件通信——使用 dispatch 和 broadcast</title>
    <link href="https://lz5z.com/vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E4%BD%BF%E7%94%A8dispatch%E5%92%8Cbroadcast/"/>
    <id>https://lz5z.com/vue2组件通信-使用dispatch和broadcast/</id>
    <published>2017-09-01T09:37:44.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用 <a href="http://element.eleme.io/" target="_blank" rel="noopener">Element</a> 过程中发现组件通信大量使用 <code>dispatch</code> 和 <code>broadcast</code> 两个方法，之前在 <a href="https://lz5z.com/vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">vue2 组件通信</a> 也提到过 vue2 中取消了 <code>$dispatch</code> 和 <code>$broadcast</code> 两个重要的事件，而 Element 重新实现了这两个函数。</p><p>代码地址放在 <a href="https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js" target="_blank" rel="noopener"><code>element-ui/lib/mixins/emitter</code></a></p><a id="more"></a><p><strong>emitter.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line">exports.__esModule = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_broadcast</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = child.$options.componentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _broadcast.apply(child, [componentName, eventName].concat([params]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">exports.default = &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatch: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="keyword">this</span>.$parent || <span class="keyword">this</span>.$root;</span><br><span class="line">      <span class="keyword">var</span> name = parent.$options.componentName;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          name = parent.$options.componentName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast: <span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">      _broadcast.call(<span class="keyword">this</span>, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3>解析</h3><p><code>dispatch</code> 和 <code>broadcast</code> 方法都需要 3 个参数，<code>componentName</code> 组件名称， <code>eventName</code> 事件名称， <code>params</code> 传递的参数。</p><p><code>dispatch</code> 方法会寻找所有的父组件，直到找到名称为 <code>componentName</code> 的组件，调用其 <code>$emit()</code> 事件。<code>broadcast</code> 方法则是遍历当前组件的所有子组件，找到名称为 <code>componentName</code> 的子组件，然后调用其 <code>$emit()</code> 事件。</p><p>这里也看出了 Element 中的 <code>dispatch</code> 与 <code>broadcast</code> 的不同，vue1 中的 <code>$dispatch</code> 和 <code>$broadcast</code> 会将事件通知给所有的 父/子 组件，只要其监听了相关事件，都能够（能够，不是一定）触发；而 Element 则更像是定向爆破，指哪打哪，其实更符合我们日常的需求。</p><h3>使用方式</h3><p>兄弟组件之间的通信可以很好的诠释上述两个事件。假设父组件 <strong>App.vue</strong> 中引入了两个子组件 <strong>Hello.vue</strong> 和 <strong>Fuck.vue</strong>。<br>如果你的项目中巧合使用了 Element，那可以按照下面的方式将其引入进来，如果没有用 Element 也不用担心，复制上面的 <code>emitter.js</code>，通过 mixins 的方式引入即可。</p><p>在 <strong>App.vue</strong> 中监听 <code>message</code> 事件，收到事件后，通过 <code>broadcast</code> 和接收到的参数，将事件定向传播给相关组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fuck</span>&gt;</span><span class="tag">&lt;/<span class="name">fuck</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'components/Hello'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Fuck <span class="keyword">from</span> <span class="string">'components/Fuck'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Emitter <span class="keyword">from</span> <span class="string">'element-ui/lib/mixins/emitter'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'app'</span>,</span></span><br><span class="line"><span class="actionscript">    componentName: <span class="string">'ROOT'</span>,</span></span><br><span class="line"><span class="undefined">    mixins: [Emitter],</span></span><br><span class="line"><span class="undefined">    components: &#123;</span></span><br><span class="line"><span class="undefined">      Hello,</span></span><br><span class="line"><span class="undefined">      Fuck</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    created () &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$on(<span class="string">'message'</span>, params =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.broadcast(params.componentName, params.eventName, params.text)</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Fuck.vue</strong> 与 <strong>Hello.vue</strong> 的内容基本相同，下面只列出 <strong>Fuck.vue</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Emitter <span class="keyword">from</span> <span class="string">'element-ui/lib/mixins/emitter'</span></span><br><span class="line"><span class="keyword">import</span> event <span class="keyword">from</span> <span class="string">'mixins/event'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  componentName: <span class="string">'Fuck'</span>,</span><br><span class="line">  mixins: [Emitter, event],</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'Fuck'</span>,</span><br><span class="line">      textarea: <span class="string">''</span>,</span><br><span class="line">      tableData: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submit () &#123;</span><br><span class="line">      <span class="keyword">this</span>.communicate(<span class="string">'message'</span>, &#123;</span><br><span class="line">        componentName: <span class="string">'Hello'</span>,</span><br><span class="line">        text: <span class="keyword">this</span>.textarea</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.textarea = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'message'</span>, text =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.tableData.push(<span class="keyword">this</span>.getMessage(text))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mixins/event.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Emitter <span class="keyword">from</span> <span class="string">'element-ui/lib/mixins/emitter'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [Emitter],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    communicate (event, params = &#123;&#125;) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dispatch(<span class="string">'ROOT'</span>, event, <span class="built_in">Object</span>.assign(&#123;</span><br><span class="line">        eventName: event</span><br><span class="line">      &#125;, params))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Fuck.vue</strong> 中监听了 <code>message</code> 事件，当收到消息时，向 <code>tableData</code> 中加入新的值。而 <code>summit</code> 方法则调用 <code>event.js</code> 中的 <code>communicate</code> 方法，通过 <code>dispatch</code> 方法将事件传播给 <code>ROOT</code> 组件。</p><p><a href="https://github.com/Leo555/vue_communication" target="_blank" rel="noopener">完整代码地址</a></p><h2>vue 组件通信方式总结</h2><ol><li>父组件向子组件传递信息使用 props down</li><li>子组件向父组件传递信息使用 event up</li><li>其它关系类型组件通信使用 global event bus</li><li>大型 SPA 组件之间通信使用 Vuex 管理组件状态</li><li>使用 Element 下 emitter.js 中的 dispatch 和 broadcast 做事件定向传播</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用 &lt;a href=&quot;http://element.eleme.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Element&lt;/a&gt; 过程中发现组件通信大量使用 &lt;code&gt;dispatch&lt;/code&gt; 和 &lt;code&gt;broadcast&lt;/code&gt; 两个方法，之前在 &lt;a href=&quot;https://lz5z.com/vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/&quot;&gt;vue2 组件通信&lt;/a&gt; 也提到过 vue2 中取消了 &lt;code&gt;$dispatch&lt;/code&gt; 和 &lt;code&gt;$broadcast&lt;/code&gt; 两个重要的事件，而 Element 重新实现了这两个函数。&lt;/p&gt;&lt;p&gt;代码地址放在 &lt;a href=&quot;https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;element-ui/lib/mixins/emitter&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://lz5z.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://lz5z.com/tags/Vue/"/>
    
      <category term="dispatch" scheme="https://lz5z.com/tags/dispatch/"/>
    
      <category term="broadcast" scheme="https://lz5z.com/tags/broadcast/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载的几种实现方式</title>
    <link href="https://lz5z.com/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://lz5z.com/图片懒加载的几种实现方式/</id>
    <published>2017-08-28T14:55:20.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://lz5z.com/lazyload">demo地址</a></p><h2>懒加载</h2><p>Lazyload 可以加快网页访问速度，减少请求，实现思路就是判断图片元素是否可见来决定是否加载图片。当图片位于浏览器视口 (viewport) 中时，动态设置 <code>&lt;img&gt;</code> 标签的 src 属性，浏览器会根据 src 属性发送请求加载图片。</p><h2>懒加载实现</h2><p>首先不设置 src 属性，将图片真正的 url 放在另外一个属性 data-src 中，在图片即将进入浏览器可视区域之前，将 url 取出放到 src 中。</p><p>懒加载的关键是<strong>如何判断图片处于浏览器可视范围内</strong>，通常有三种方法：</p><a id="more"></a><h3>方法一</h3><p>通过对比屏幕可视窗口高度和浏览器滚动距离与元素相对文档顶部的距离之间的关系，判断元素是否可见。</p><p>示意图如下：</p><img src="/assets/img/lazyload.svg" alt="lazyload.svg"><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInSight</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clientHeight = <span class="built_in">window</span>.innerHeight <span class="comment">// 获取屏幕可视窗口高度</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="built_in">document</span>.body.scrollTop <span class="comment">// 浏览器窗口顶部与文档顶部之间的距离</span></span><br><span class="line">    <span class="comment">// el.offsetTop 元素相对于文档顶部的距离 </span></span><br><span class="line">    <span class="comment">// +100是为了提前加载</span></span><br><span class="line">    <span class="keyword">return</span> el.offsetTop &lt;= clientHeight + scrollTop + <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>方法二</h3><p>通过 getBoundingClientRect() 获取图片相对于浏览器视窗的位置</p><p>示意图如下：</p><img src="/assets/img/lazyload1.svg" alt="lazyload1.svg"><p>getBoundingClientRect() 方法返回一个 ClientRect 对象，里面包含元素的位置和大小的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClientRect &#123;</span><br><span class="line">bottom: <span class="number">596</span>,</span><br><span class="line">height: <span class="number">596</span>,</span><br><span class="line">left: <span class="number">0</span>,</span><br><span class="line">right: <span class="number">1920</span>,</span><br><span class="line">top: <span class="number">0</span>,</span><br><span class="line">width: <span class="number">1920</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中位置是相对于浏览器视图左上角而言。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInSight1</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> bound = el.getBoundingClientRect() </span><br><span class="line">    <span class="keyword">const</span> clientHeight = <span class="built_in">window</span>.innerHeight <span class="comment">// 表示浏览器可视区域的高度</span></span><br><span class="line">    <span class="comment">// bound.top 表示图片到可视区域顶部距离</span></span><br><span class="line">    <span class="comment">// +100是为了提前加载</span></span><br><span class="line">    <span class="keyword">return</span> bound.top &lt;= clientHeight + <span class="number">100</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>方法三</h3><p>使用 IntersectionObserver API，观察元素是否可见。“可见”的本质是目标元素与 viewport 是否有交叉区，所以这个 API 叫做“交叉观察器”。</p><p>实现方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!el.src) &#123;</span><br><span class="line">        <span class="keyword">const</span> source = el.dataset.src</span><br><span class="line">        el.src = source</span><br><span class="line">        el.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> entries) &#123;</span><br><span class="line">        <span class="keyword">const</span> el = entry.target</span><br><span class="line">        <span class="keyword">const</span> intersectionRatio = entry.intersectionRatio</span><br><span class="line">        <span class="keyword">if</span> (intersectionRatio &gt; <span class="number">0</span> &amp;&amp; intersectionRatio &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            loadImg(el)</span><br><span class="line">        &#125;</span><br><span class="line">        el.onload = el.onerror = <span class="function"><span class="params">()</span> =&gt;</span> io.unobserve(el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkImgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imgs = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'img[data-src]'</span>))</span><br><span class="line">    imgs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> io.observe(item))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>IntersectionObserver</h2><p>IntersectionObserver 的作用就是检测一个元素是否可见，以及元素什么时候进入或者离开浏览器视口。</p><h3>兼容性</h3><ul><li>Chrome 51+（发布于 2016-05-25）</li><li>Android 5+ （Chrome 56 发布于 2017-02-06）</li><li>Edge 15 （2017-04-11）</li><li>iOS 不支持</li></ul><h3>Polyfill</h3><p>WICG 提供了一个 <a href="https://github.com/w3c/IntersectionObserver" target="_blank" rel="noopener">polyfill</a></p><h3>API</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option)</span><br></pre></td></tr></table></figure><p>IntersectionObserver 是一个构造函数，接受两个参数，第一个参数是可见性变化时的回调函数，第二个参数定制了一些关于可见性的参数（可选），IntersectionObserver 实例化后返回一个观察器，可以指定观察哪些 DOM 节点。</p><p>下面是一个最简单的应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取 img</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>)</span><br><span class="line"><span class="comment">// 2. 实例化 IntersectionObserver，添加 img 出现在 viewport 瞬间的回调</span></span><br><span class="line"><span class="keyword">const</span> observer =  <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">changes</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我出现了！'</span>) </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 3. 开始监听 img</span></span><br><span class="line">observer.observe(img)</span><br></pre></td></tr></table></figure><p>(1) callback</p><p>回调 callback 接受一个数组作为参数，数组元素是 IntersectionObserverEntry 对象。IntersectionObserverEntry 对象上有7个属性，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IntersectionObserverEntry &#123;</span><br><span class="line">time: <span class="number">72.15500000000002</span>, </span><br><span class="line">rootBounds: ClientRect, </span><br><span class="line">boundingClientRect: ClientRect, </span><br><span class="line">intersectionRatio: <span class="number">0.4502074718475342</span>,</span><br><span class="line">intersectionRect: ClientRect, </span><br><span class="line">isIntersecting: <span class="literal">true</span>,</span><br><span class="line">target: img</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>boundingClientRect: 对 observe 的元素执行 getBoundingClientRect 的结果</li><li>rootBounds: 对根视图执行 getBoundingClientRect 的结果</li><li>intersectionRect: 目标元素与视口（或根元素）的交叉区域的信息</li><li>target: observe 的对象，如上述代码就是 img</li><li>time: 过了多久才出现在 viewport 内</li><li>intersectionRatio：目标元素的可见比例，intersectionRect 占 boundingClientRect 的比例，完全可见时为1，完全不可见时小于等于0</li><li>isIntersecting: 目标元素是否处于视口中</li></ul><p>(2) option</p><p>假如我们需要特殊的触发条件，比如元素可见性为一半的时候触发，或者我们需要更改根元素，这时就需要配置第二个参数 option 了。</p><p>通过设置 option 的 threshold 改变回调函数的触发条件，threshold 是一个范围为0到1数组，默认值是[0]，也就是在元素可见高度变为0时就会触发。如果赋值为 [0, 0.5, 1]，那回调就会在元素可见高度是0%，50%，100%时，各触发一次回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer =  <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">changes</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(changes.length); </span><br><span class="line">&#125;, &#123;</span><br><span class="line">  root: <span class="literal">null</span>, </span><br><span class="line">  rootMargin: <span class="string">'20px'</span>, </span><br><span class="line">  threshold: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>root 参数默认是 null，也就是浏览器的 viewport，可以设置为其它元素，rootMargin 参数可以给 root 元素添加一个 margin，如 <code>rootMargin: '20px'</code> 时，回调会在元素出现前 20px 提前调用，消失后延迟 20px 调用回调。</p><p>(3) 观察器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察多个 DOM 元素</span></span><br><span class="line">io.observe(elementA)</span><br><span class="line">io.observe(elementB)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">io.unobserve(element)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭观察器</span></span><br><span class="line">io.disconnect()</span><br></pre></td></tr></table></figure><h3>使用 IntersectionObserver 优势</h3><p>使用前两种方式实现 lazyload 都需要监听浏览器 scroll 事件，而且要对每个目标元素执行 getBoundingClientRect() 方法以获取所需信息，这些代码都在主线程上运行，所以可能造成性能问题。</p><p>Intersection Observer API 会注册一个回调方法，每当期望被监视的元素进入或者退出另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的交集部分大小发生变化的时候回调方法也会被执行。通过这种方式，网站将不需要为了监听两个元素的交集变化而在主线程里面做任何操作，并且浏览器可以帮助我们优化和管理两个元素的交集变化。</p><h2>参考资料</h2><ol><li><a href="https://juejin.im/entry/599a78be6fb9a0247e424d67" target="_blank" rel="noopener">原生 JS 实现最简单的图片懒加载</a></li><li><a href="https://github.com/justjavac/the-front-end-knowledge-you-may-dont-know/issues/10" target="_blank" rel="noopener">IntersectionObserver</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API#Browser_compatibility" target="_blank" rel="noopener">MDN-Intersection Observer API</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://lz5z.com/lazyload&quot;&gt;demo地址&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;懒加载&lt;/h2&gt;&lt;p&gt;Lazyload 可以加快网页访问速度，减少请求，实现思路就是判断图片元素是否可见来决定是否加载图片。当图片位于浏览器视口 (viewport) 中时，动态设置 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签的 src 属性，浏览器会根据 src 属性发送请求加载图片。&lt;/p&gt;&lt;h2&gt;懒加载实现&lt;/h2&gt;&lt;p&gt;首先不设置 src 属性，将图片真正的 url 放在另外一个属性 data-src 中，在图片即将进入浏览器可视区域之前，将 url 取出放到 src 中。&lt;/p&gt;&lt;p&gt;懒加载的关键是&lt;strong&gt;如何判断图片处于浏览器可视范围内&lt;/strong&gt;，通常有三种方法：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="lazyload" scheme="https://lz5z.com/tags/lazyload/"/>
    
      <category term="getBoundingClientRect" scheme="https://lz5z.com/tags/getBoundingClientRect/"/>
    
      <category term="IntersectionObserver" scheme="https://lz5z.com/tags/IntersectionObserver/"/>
    
  </entry>
  
  <entry>
    <title>service worker 使用</title>
    <link href="https://lz5z.com/service-worker%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lz5z.com/service-worker学习/</id>
    <published>2017-07-09T20:05:46.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>service worker 简介</h2><p>service worker 的功能和特性可以总结为以下几点：</p><ol><li>service worker 是一个独立 worker 线程，独立于当前网页进程，有自己独立的 worker context</li><li>service worker 的线程能力基于 webworker 而生，通过 postMessage 和 onMessage 进行线程之间的通信；缓存机制是依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">cache API</a> 实现的。service worker = webworker + cache API</li><li>一旦被 install 之后，就永远存在，除非被 uninstall；需要的时候可以直接唤醒，不需要的时候自动睡眠</li><li>可以可编程拦截代理请求( https 请求)和缓存文件，缓存的文件直接可以被网页进程取到（包括网络离线状态）</li><li>离线内容开发者可控；能向客户端推送消息；不能直接操作 dom</li><li>必须在 https 环境下才能工作，当然 localhost 或者 127.0.0.1 也是 ok 的</li><li>service worker 是异步的，内部通过 Promise 实现， localStorage 是同步的，因此 service worker 内不许用使用 loaclStorage</li><li>依赖 HTML5 fetch API 和 Promise</li></ol><a id="more"></a><h1>service worker 使用</h1><h2>注册</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        navigator.serviceWorker.register(<span class="string">'/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 注册成功</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful with scope: '</span>, </span><br><span class="line">                    registration.scope);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 注册失败:(</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次页面加载成功后，就会调用 register() 方法，浏览器将会判断 service worker 线程是否已注册并做出相应的处理。<br>scope 参数是可选的，默认值为 <code>sw.js</code> 所在的文件目录。<br>打开 chrome 浏览器, 输入 chrome://inspect/#service-workers 可以可以用 DevTools 查看 Service workers 的工作情况。</p><h2>安装</h2><p>service worker 注册后，浏览器就会尝试安装并激活它，并且在这里完成静态资源的缓存。</p><p>所以我们在 <code>sw.js</code> 中添加 install 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(<span class="string">'my-test-cache-v1'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.addAll([</span><br><span class="line">                <span class="string">'/'</span>,</span><br><span class="line">                <span class="string">'/index.html'</span>,</span><br><span class="line">                <span class="string">'/main.css'</span>,</span><br><span class="line">                <span class="string">'/index.js'</span>,</span><br><span class="line">                <span class="string">'/sw-lifecycle.jpg'</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>install 事件一般是被用来完成浏览器的离线缓存功能，service worker 的缓存机制是依赖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">cache API</a> 实现的。cache API 为绑定在 service worker 上的全局对象，可以用来存储网络响应发来的资源，这些资源只在站点域名内有效，并且一直存在，直到你告诉它不再存储。</p><h3>缓存和返回请求</h3><p>每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，因此我们可以利用 fetch 事件对资源响应做一些拦截操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 如果 service worker 有自己的返回，就直接返回，减少一次 http 请求</span></span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 service worker 没有返回，从服务器请求资源</span></span><br><span class="line">            <span class="keyword">var</span> request = event.request.clone(); <span class="comment">// 把原始请求拷过来</span></span><br><span class="line">            <span class="keyword">return</span> fetch(request).then(<span class="function"><span class="keyword">function</span> (<span class="params">httpRes</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 请求失败了，直接返回失败的结果就好了。。</span></span><br><span class="line">                <span class="keyword">if</span> (!httpRes &amp;&amp; httpRes.status !== <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> response;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 请求成功的话，再一次缓存起来。</span></span><br><span class="line">                <span class="keyword">var</span> responseClone = httpRes.clone();</span><br><span class="line">                caches.open(<span class="string">'my-test-cache-v1'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                    cache.put(event.request, responseClone);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> httpRes;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样看来，其实可以把 service worker 理解为一个浏览器端的代理服务器，这个代理服务器通过 scope 和 fetch 事件来 hook 站点的请求，来达到资源缓存的功能。</p><p>注意：request 和 response 不能直接使用而是通过 clone 的方式使用是因为他们是 stream，因此只能使用一次。</p><h3>install vs fetch</h3><ul><li>install 的优点是第二次访问即可离线，缺点是需要将需要缓存的资源 URL 在编译时插入到脚本中，增加代码量和降低可维护性；</li><li>fetch 的优点是无需更改编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线可用。</li></ul><h2>service worker 更新</h2><p><code>/sw.js</code> 控制着页面资源和请求的缓存，如果 <code>/sw.js</code> 需要更新应该怎么办呢？</p><ul><li>service worker 控制着整个 App 的离线缓存。 为了避免 service worker 缓存自己导致死锁无法升级，通常将 sw.js 本身的缓存直接交给 HTTP 服务器缓存。</li><li>更新 <code>sw.js</code> 文件，当浏览器获取到了新的文件，发现 <code>sw.js</code> 文件发生更新，就会安装新的文件并触发 install 事件。</li><li>但是此时已经处于激活状态的旧的 service worker 还在运行，新的 service worker 完成安装后会进入 waiting 状态，直到所有已打开的页面都关闭。</li><li>新服务工作线程取得控制权后，将会触发其 activate 事件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装阶段跳过等待，直接进入 activate</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(self.skipWaiting());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">evnet</span>) </span>&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="built_in">Promise</span>.all([</span><br><span class="line">            <span class="comment">// 更新客户端</span></span><br><span class="line">            self.clients.claim(),</span><br><span class="line">            <span class="comment">// 清理旧版本</span></span><br><span class="line">            caches.keys().then(<span class="function"><span class="keyword">function</span> (<span class="params">cacheList</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">                    cacheList.map(<span class="function"><span class="keyword">function</span> (<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (cacheName !== <span class="string">'my-test-cache-v1'</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        ])</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：如果 <code>sw.js</code> 文件被浏览器缓存，则可能导致更新得不到响应。如遇到该问题，可尝试这么做：在 webserver 上添加对该文件的过滤规则，不缓存或设置较短的有效期。</p><h3>手动更新 /sw.js</h3><p>也可以借助 <code>Registration.update()</code> 手动更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> version = <span class="string">'1.0.1'</span>;</span><br><span class="line"></span><br><span class="line">navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localStorage.getItem(<span class="string">'sw_version'</span>) !== version) &#123;</span><br><span class="line">        reg.update().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            localStorage.setItem(<span class="string">'sw_version'</span>, version)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3>自动更新</h3><p>除了浏览器触发更新之外，service worker 还有一个特殊的缓存策略： 如果该文件已 24 小时没有更新，当 Update 触发时会强制更新。这意味着最坏情况下 service worker 会每天更新一次。</p><h3>调试时更新</h3><p>可以单独设置调试时 service worker 安装后立即激活：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    self.skipWaiting();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>service worker 生命周期</h2><img src="/assets/img/sw-lifecycle.png" alt="sw-lifecycle"><h3>service worker 工作流程</h3><p>service worker 基于注册、安装、激活等步骤在浏览器 js 主线程中独立分担缓存任务。</p><ul><li>首先在页面的 javaScript 主线程中使用 navigator.serviceWorker.register() 来注册 servcie worker。</li><li>如果注册成功，service worker 在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊的 worker context，与主脚本的运行线程相独立，同时也没有访问 DOM 的能力。</li><li>后台开始安装步骤，通常在安装的过程中需要缓存一些静态资源。install 事件回调中有两个方法：<ul><li>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li><li>self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</li></ul></li><li>当 service worker 安装完成后，会接收到一个激活事件（activate event）。激活事件的处理函数中，主要操作是清理旧版本的 service worker 脚本中使用资源。activate 回调中有两个方法：<ul><li>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。</li><li>self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。</li></ul></li><li>激活成功后 service worker 可以控制页面了，刷新页面可以查看 service worker 的工作成果。</li></ul><h3>service worker 事件</h3><ul><li>install: service worker 安装成功后被触发的事件，在事件处理函数中可以添加需要缓存的文件。</li><li>activate：当 service worker 安装完成后并进入激活状态，会触发 activate 事件。通过监听 activate 事件你可以做一些预处理，如对于旧版本的更新、对于无用缓存的清理等。</li><li>message：service worker 通过 postMessage API，可以实现与主线程之间的通信。</li></ul><p>下面是一个使用 service worker 的 postMessage API 做的一个简单计算器，其中计算部分在 service worker 线程中完成。假如有一些比较耗时的工作，比如大量计算，或者 fetch 数据，可以将其放入 service worker 线程中，以达到提高页面响应的目的。</p><iframe defer src="https://lz5z.com/service_worker_postMessage/" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="width:500px;height:50px" width="500" height="50" allowtransparency="true"></iframe><p><a href="https://lz5z.com/service_worker_postMessage/">在线演示</a><br><a href="https://github.com/Leo555/service_worker_postMessage" target="_blank" rel="noopener">源码</a></p><ul><li>fetch (请求)：当浏览器在当前指定的 scope 下发起请求时，会触发 fetch 事件，并得到传有 response 参数的回调函数，回调中就可以做各种代理缓存的事情了。</li><li>push (推送)：push 事件是为推送准备的。不过首先需要了解一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="noopener">Notification API</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API" target="_blank" rel="noopener">PUSH API</a>。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。</li></ul><h2>示例</h2><p>这个<a href="http://service-worker.org/" target="_blank" rel="noopener">网站</a>记录了很多 service worker demo。</p><h2>参考文档</h2><ul><li><a href="https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction" target="_blank" rel="noopener">lavas</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API-MDN</a></li><li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers?hl=zh-cn" target="_blank" rel="noopener">服务工作线程</a></li><li><a href="http://harttle.com/2017/04/10/service-worker-update.html" target="_blank" rel="noopener">Service Worker 更新机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;service worker 简介&lt;/h2&gt;&lt;p&gt;service worker 的功能和特性可以总结为以下几点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;service worker 是一个独立 worker 线程，独立于当前网页进程，有自己独立的 worker context&lt;/li&gt;&lt;li&gt;service worker 的线程能力基于 webworker 而生，通过 postMessage 和 onMessage 进行线程之间的通信；缓存机制是依赖 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Cache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cache API&lt;/a&gt; 实现的。service worker = webworker + cache API&lt;/li&gt;&lt;li&gt;一旦被 install 之后，就永远存在，除非被 uninstall；需要的时候可以直接唤醒，不需要的时候自动睡眠&lt;/li&gt;&lt;li&gt;可以可编程拦截代理请求( https 请求)和缓存文件，缓存的文件直接可以被网页进程取到（包括网络离线状态）&lt;/li&gt;&lt;li&gt;离线内容开发者可控；能向客户端推送消息；不能直接操作 dom&lt;/li&gt;&lt;li&gt;必须在 https 环境下才能工作，当然 localhost 或者 127.0.0.1 也是 ok 的&lt;/li&gt;&lt;li&gt;service worker 是异步的，内部通过 Promise 实现， localStorage 是同步的，因此 service worker 内不许用使用 loaclStorage&lt;/li&gt;&lt;li&gt;依赖 HTML5 fetch API 和 Promise&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://lz5z.com/categories/HTML/"/>
    
    
      <category term="HTML5" scheme="https://lz5z.com/tags/HTML5/"/>
    
      <category term="service worker" scheme="https://lz5z.com/tags/service-worker/"/>
    
      <category term="离线缓存" scheme="https://lz5z.com/tags/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/"/>
    
      <category term="postMessage" scheme="https://lz5z.com/tags/postMessage/"/>
    
  </entry>
  
  <entry>
    <title>hexo 支持 emoji</title>
    <link href="https://lz5z.com/hexo%E6%94%AF%E6%8C%81emoji/"/>
    <id>https://lz5z.com/hexo支持emoji/</id>
    <published>2017-07-05T16:24:06.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h3>添加方法</h3><p>很简单，换一个 markdown 引擎，然后再增加 emoji 插件即可。😊</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm un hexo-renderer-marked --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm i hexo-renderer-markdown-it --save </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install markdown-it-emoji --save</span></span><br></pre></td></tr></table></figure><p>据说 <a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">hexo-renderer-markdown-it</a> 的速度要比 Hexo 原装插件要快，而且功能更多：</p><a id="more"></a><blockquote><p>Main Features</p><ul><li>Support for <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>, <a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">GFM</a> and <a href="http://commonmark.org/" target="_blank" rel="noopener">CommonMark</a></li><li>Extensive configuration</li><li>Faster than the default renderer | <code>hexo-renderer-marked</code></li><li>Safe ID for headings</li><li>Anchors for headings with ID</li><li>Footnotes</li><li><code>&lt;sub&gt;</code> H<sub>2</sub>O</li><li><code>&lt;sup&gt;</code> x<sup>2</sup></li><li><code>&lt;ins&gt;</code> <ins>Inserted</ins></li></ul></blockquote><p>然后编辑 <code>_config.yml</code>：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    -<span class="ruby"> markdown-it-footnote</span></span><br><span class="line"><span class="ruby">    - markdown-it-sup</span></span><br><span class="line"><span class="ruby">    - markdown-it-sub</span></span><br><span class="line"><span class="ruby">    - markdown-it-abbr</span></span><br><span class="line"><span class="ruby">    - markdown-it-emoji</span></span><br></pre></td></tr></table></figure><h3>使用方法</h3><ol><li>在 <a href="https://emoji.codes/" target="_blank" rel="noopener">Emoji</a> 中找到你想要的表情，然后点击即可复制。</li><li>比如你想发一个笑脸 😄 直接输入笑脸对应的 emoji 编码 <code>:smile:</code> 就可以。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;添加方法&lt;/h3&gt;&lt;p&gt;很简单，换一个 markdown 引擎，然后再增加 emoji 插件即可。😊&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm un hexo-renderer-marked --save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm i hexo-renderer-markdown-it --save &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm install markdown-it-emoji --save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;据说 &lt;a href=&quot;https://github.com/hexojs/hexo-renderer-markdown-it&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-renderer-markdown-it&lt;/a&gt; 的速度要比 Hexo 原装插件要快，而且功能更多：&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="Hexo" scheme="https://lz5z.com/tags/Hexo/"/>
    
      <category term="emoji" scheme="https://lz5z.com/tags/emoji/"/>
    
  </entry>
  
  <entry>
    <title>为什么 call 的速度快于 apply</title>
    <link href="https://lz5z.com/call-faster-than-apply/"/>
    <id>https://lz5z.com/call-faster-than-apply/</id>
    <published>2017-06-29T16:43:04.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<p>在 stackoverflow 看到一个有趣的问题: <a href="https://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply" target="_blank" rel="noopener">Why is call so much faster than apply?</a> 于是使用 <a href="https://benchmarkjs.com/" target="_blank" rel="noopener">benchmark.js</a> 在 node 中自己测试了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Benchmark = <span class="built_in">require</span>(<span class="string">'benchmark'</span>)</span><br><span class="line"><span class="keyword">const</span> suite = <span class="keyword">new</span> Benchmark.Suite</span><br><span class="line"><span class="keyword">const</span> applyFun = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.apply(str, [<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callFun = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(str, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add tests</span></span><br><span class="line">suite.add(<span class="string">'apply'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    applyFun(<span class="string">'apple'</span>)</span><br><span class="line">&#125;).add(<span class="string">'call'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callFun(<span class="string">'apple'</span>)</span><br><span class="line">&#125;).on(<span class="string">'cycle'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target))</span><br><span class="line">&#125;).on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Fastest is '</span> + <span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).map(<span class="string">'name'</span>))</span><br><span class="line">&#125;).run(&#123;<span class="string">'async'</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><h3>测试环境：</h3><p>系统：macOS Sierra<br>CPU：2.6 GHz Intel Core i5<br>内存：8 GB 1600 MHz DDR3<br>Node: 8.1.0</p><h3>测试结果：</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply x <span class="number">951</span>,<span class="number">707</span> ops/sec ±<span class="number">0.46</span>% (<span class="number">87</span> runs sampled)</span><br><span class="line">call x <span class="number">969</span>,<span class="number">699</span> ops/sec ±<span class="number">0.52</span>% (<span class="number">91</span> runs sampled)</span><br><span class="line">Fastest is call</span><br></pre></td></tr></table></figure><p>可见虽然 call 比 apply 要快一些，但是差别并不是很大，那么在浏览器上面表现如何呢？</p><img src="/assets/img/call_vs_apply.jpg" alt="call_vs_apply_in_browsers"><p>你也可以点击下面的 button 在自己的浏览器上查看运行效果。</p><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>call vs apply</title><script defer src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/platform/1.3.4/platform.min.js"></script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/benchmark/2.1.4/benchmark.min.js"></script><script>window.onload = () => {        let log = document.getElementById("log")        let btn = document.getElementById("btn")        const applyFun = str => {            return [].slice.apply(str, [1])        }        const callFun = str => {            return [].slice.call(str, 1)        }        const logMessage = arg => {            let eDiv = document.createElement("div")            eDiv.innerHTML = typeof arg === "string" ? arg : arg.toString()            log.appendChild(eDiv)        }        const prepare = () => {            log.innerHTML = ''            btn.disabled = true        }        window.run = () => {            prepare()            const suite = new Benchmark.Suite            // add tests            suite.add('apply', function() {                applyFun('apple')            }).add('call', function() {                callFun('apple')            }).on('cycle', function(event) {                logMessage(String(event.target))            }).on('complete', function() {                logMessage('Fastest is ' + this.filter('fastest').map('name'))                btn.disabled = false            }).run({                'async': true            })        }    }</script></head><body><button id="btn" onclick="run()">run test</button> <span id="log"></span><hr></body></html><p>可以看到几个浏览器中都是 call 的速度要快于 apply，不过都没有特别明显。其中 Safari 的速度让我大吃一惊，直接比其它几个浏览器快了一个数量级。看来 WWDC 2017 发布会上苹果吹的牛没有那么大啊，不过也可能 mac 从硬件层面对 Safari 进行优化。</p><h3>为什么 call 要快于 apply</h3><p>SO 上面解释的比较详细，在语言设计的时候，apply 需要执行的步数就比 call 要多：无论 call 还是 apply，最终都是调用一个叫做 <code>[[Call]]</code> 的内部函数，而 apply 相对于 call 多做了一些参数处理，如参数判断、格式化等。</p><h3>困惑</h3><p>SO 上面提到 call 的性能是 apply 的 4 倍甚至 30 倍，为什么在我这里的测试只有一丁点差距呢？<br>突然想到是否参数问题，于是去掉参数和增加参数，分别于 node 环境中测试，发现变化并不大，差距依然很小。那么猜想可能是 ES5 与 ES6 的差距导致的。</p><p>对比 <a href="http://es5.github.io/#x15.3.4.3" target="_blank" rel="noopener">ES5</a> 和 <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.apply" target="_blank" rel="noopener">ES6</a> 中对这两个函数的定义，发现 Function.prototype.call 的变化并不大，主要变化发生在 Function.prototype.apply 上，从 ES5 的 9 步变成了 ES6 的 6步。主要变化发生在对参数处理的部分，其它关于内部函数调用的部分，看起来并没有太多差异。</p><h3>总结</h3><p>通过测试发现随着 ECMAScript 语言和 JavaScript 解释器性能不断增强，call vs apply 在性能上的差距越来越小， SO 上面提到的数倍甚至几十倍的差距，目前已经不存在了，因此在使用上可以随心所欲了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 stackoverflow 看到一个有趣的问题: &lt;a href=&quot;https://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why is call so much faster than apply?&lt;/a&gt; 于是使用 &lt;a href=&quot;https://benchmarkjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;benchmark.js&lt;/a&gt; 在 node 中自己测试了一下：&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Benchmark = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;benchmark&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; suite = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Benchmark.Suite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; applyFun = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [].slice.apply(str, [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; callFun = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [].slice.call(str, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// add tests&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;suite.add(&lt;span class=&quot;string&quot;&gt;&#39;apply&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    applyFun(&lt;span class=&quot;string&quot;&gt;&#39;apple&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).add(&lt;span class=&quot;string&quot;&gt;&#39;call&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    callFun(&lt;span class=&quot;string&quot;&gt;&#39;apple&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).on(&lt;span class=&quot;string&quot;&gt;&#39;cycle&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(event.target))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).on(&lt;span class=&quot;string&quot;&gt;&#39;complete&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;Fastest is &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.filter(&lt;span class=&quot;string&quot;&gt;&#39;fastest&#39;&lt;/span&gt;).map(&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).run(&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;async&#39;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="call" scheme="https://lz5z.com/tags/call/"/>
    
      <category term="apply" scheme="https://lz5z.com/tags/apply/"/>
    
  </entry>
  
  <entry>
    <title>CSS Modules 学习</title>
    <link href="https://lz5z.com/CSS_Modules/"/>
    <id>https://lz5z.com/CSS_Modules/</id>
    <published>2017-06-21T10:39:32.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>CSS Modules 的用法很简单，不过现阶段还需要 webpack 的支持。CSS Modules 的功能非常少，它一共就干了两件事：局部作用域和模块依赖。</p><h2>CSS Modules 示例</h2><p><a href="https://github.com/Leo555/css_modules_study" target="_blank" rel="noopener">代码地址</a></p><p>项目路径</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="selector-tag">README</span><span class="selector-class">.md</span></span><br><span class="line">├── <span class="selector-tag">index</span><span class="selector-class">.html</span></span><br><span class="line">├── <span class="selector-tag">node_modules</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── <span class="selector-tag">package</span><span class="selector-class">.json</span></span><br><span class="line">├── <span class="selector-tag">src</span></span><br><span class="line">│   ├── <span class="selector-tag">animation</span><span class="selector-class">.css</span></span><br><span class="line">│   ├── <span class="selector-tag">colors</span><span class="selector-class">.css</span></span><br><span class="line">│   ├── <span class="selector-tag">index</span><span class="selector-class">.js</span></span><br><span class="line">│   └── <span class="selector-tag">style</span><span class="selector-class">.css</span></span><br><span class="line">└── <span class="selector-tag">webpack</span><span class="selector-class">.config</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>把文件 clone 下来后，安装依赖，然后就可以运行了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Leo555/css_modules_study.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> css_modules_study</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm run start</span></span><br></pre></td></tr></table></figure><p>浏览器会自动打开静态文件，方便查看效果。</p><h2>CSS Modules 用法</h2><h3>webpack</h3><p>首先配置 webpack 环境(本文使用webpack2)，给 css-loader 增加一个 modules 查询参数，表示打开 CSS Modules 功能。</p><p>简单的示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    loader: <span class="string">"style-loader!css-loader?modules"</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果需要给 CSS Modules 传递一些参数，可以用对象的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [<span class="string">"style-loader"</span>, </span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">"css-loader"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        modules: <span class="literal">true</span>,</span><br><span class="line">        localIdentName: <span class="string">'[path][name]__[local]--[hash:base64:5]'</span>,</span><br><span class="line">        importLoaders: <span class="number">1</span>,</span><br><span class="line">        camelCase: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>作用域</h3><p>开启 CSS Modules 后，所有的 CSS 选择器都是局部作用域，除非声明它为全局的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Scoped Selectors*/</span></span><br><span class="line"><span class="selector-class">.className</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Global Selectors*/</span></span><br><span class="line"><span class="selector-pseudo">:global(.text)</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">22px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个 CSS class 通过如下方法被 JS 引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">"./style.css"</span>;</span><br><span class="line"><span class="comment">// import &#123; className &#125; from "./style.css";</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">app.innerHTML = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class="<span class="subst">$&#123;styles.className&#125;</span>"&gt;Hello CSS Modules&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class="text"&gt;Global Selectors&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>后面的引用方式都相同，因此略去，具体可查看 <a href="https://github.com/Leo555/css_modules_study/blob/master/src/index.js" target="_blank" rel="noopener">index.js</a>。</p><p>查看构建后的 CSS，发现局部变量的名字被编译成 hash (<code>localIdentName: '[path][name]__[local]--[hash:base64:5]'</code>)，而全局变量的名字不变。</p><img src="/assets/img/css-modules.png" alt="css-modules"><p>原来 CSS Modules 就做了这么一点微小的工作。</p><h3>class 继承和重写</h3><p>CSS Modules 通过组合的方式进行集成，以达成代码复用的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Class Composes*/</span></span><br><span class="line"><span class="selector-class">.otherClassName</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: className;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Composes Overrides*/</span></span><br><span class="line"><span class="selector-class">.background</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#efefef</span>;</span><br><span class="line">  <span class="attribute">composes</span>: otherClassName;</span><br><span class="line">  <span class="attribute">border-style</span>: dotted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>otherClassName 继承 className，因为拥有了 color 和 margin 属性，而 background 继承 otherClassName，却重写了 border-style。</p><h3>局部动画</h3><p>在 animation.css 中，定义了动画 tada：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> tada &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(1, 1, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  10%, 20% &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(.9, .9, .9) <span class="built_in">rotate3d</span>(0, 0, 1, -3deg);</span><br><span class="line">  &#125;</span><br><span class="line">  30%, 50%, 70%, 90% &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(1.1, 1.1, 1.1) <span class="built_in">rotate3d</span>(0, 0, 1, 3deg);</span><br><span class="line">  &#125;</span><br><span class="line">  40%, 60%, 80% &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(1.1, 1.1, 1.1) <span class="built_in">rotate3d</span>(0, 0, 1, -3deg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale3d</span>(1, 1, 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tada</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: tada <span class="number">2s</span> infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 style 中的引用方式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Scoped Animations*/</span></span><br><span class="line"><span class="selector-class">.backgroundAnimation</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: background;</span><br><span class="line">  <span class="attribute">composes</span>: tada from <span class="string">'./animation.css'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面第二个 composes 也展示了如何从其它 CSS 模块中引用选择器。</p><h3>定义变量</h3><p>通过 @value 定义变量和引用变量</p><p>colors.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">value</span> color: black;</span><br><span class="line">@<span class="keyword">value</span> fontSize: <span class="number">22px</span>;</span><br></pre></td></tr></table></figure><p>引用方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Define variables*/</span></span><br><span class="line">@<span class="keyword">value</span> colors: <span class="string">"./colors.css"</span>;</span><br><span class="line">@<span class="keyword">value</span> color, fontSize from colors;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.color</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: otherClassName;</span><br><span class="line">  <span class="attribute">color</span>: color;</span><br><span class="line">  <span class="attribute">font-size</span>: fontSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Vue 结合 CSS Modules</h2><p>vue-loader 中集成了 CSS Modules，可以作为模拟 CSS 作用域的替代方案。</p><h3>使用</h3><p>在 <code>&lt;style&gt;</code> 上添加 module 属性即可开启 CSS Modules 模式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="undefined">  color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bold</span> &#123;</span></span><br><span class="line"><span class="undefined">  font-weight: bold;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css-loader 会自动将生成的 CSS 对象注入到 $style 中，只需要在 <code>&lt;template&gt;</code> 中使用动态 class 绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"$style.red"</span>&gt;</span></span><br><span class="line">    This should be red</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于它是一个计算属性，它也适用于 <code>:class</code> 的 object/array 语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"&#123; [$style.red]: isRed &#125;"</span>&gt;</span></span><br><span class="line">      Am I red?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"[$style.red, $style.bold]"</span>&gt;</span></span><br><span class="line">      Red and bold</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 访问它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  created () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$style.red)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3>自定义注入名称</h3><p>在 .vue 中可以定义不止一个 <code>&lt;style&gt;</code>，为了避免被覆盖，你可以通过设置 module 属性来为它们定义注入后计算属性的名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>=<span class="string">"a"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="comment">/* identifiers injected as a */</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>总结</h2><p>在前端模块化的道路上，CSS 显然落后 JS 非常多。ES2015/ES2016 的快速普及和 Babel/webpack 等工具的发展，让 JS 在大型项目工程化中越发强大，<a href="http://www.infoq.com/cn/news/2017/05/JavaScript-become-language" target="_blank" rel="noopener">最终成为一流语言</a> 。</p><p>CSS Modules 解决了哪些问题呢？</p><ol><li>消除了全局命名的问题，再也不用担心不同文件之间的命名冲突了，也不用写一层又一层的选择器了。</li><li>通过 JS 去管理 CSS 之间的依赖，在引入组件的时候，可以只引入次组件需要的 CSS，组件更加独立。</li><li>CSS 变量 可以在 CSS 和 JS 中共享，对于复杂组件的使用会有奇效。</li><li>对代码压缩也有一定帮助。</li></ol><blockquote><p>CSS 模块化的解决方案有很多，但主要有两类。一类是彻底抛弃 CSS，使用 JS 或 JSON 来写样式。Radium，jsxstyle，react-style 属于这一类。优点是能给 CSS 提供 JS 同样强大的模块化能力；缺点是不能利用成熟的 CSS 预处理器（或后处理器） Sass/Less/PostCSS，:hover 和 :active 伪类处理起来复杂。另一类是依旧使用 CSS，但使用 JS 来管理样式依赖，代表是 CSS Modules。CSS Modules 能最大化地结合现有 CSS 生态和 JS 模块化能力，API 简洁到几乎零学习成本。发布时依旧编译出单独的 JS 和 CSS。它并不依赖于 React，只要你使用 Webpack，可以在 Vue/Angular/jQuery 中使用。是我认为目前最好的 CSS 模块化解决方案。</p></blockquote><p>引自 <a href="https://github.com/camsong/blog/issues/5" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a></p><h2>参考资料</h2><ul><li><a href="https://github.com/camsong/blog/issues/5" target="_blank" rel="noopener">CSS Modules 详解及 React 中实践</a></li><li><a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">css-modules</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noopener">CSS Modules 用法教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS Modules 的用法很简单，不过现阶段还需要 webpack 的支持。CSS Modules 的功能非常少，它一共就干了两件事：局部作用域和模块依赖。&lt;/p&gt;&lt;h2&gt;CSS Modules 示例&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Leo555/css_modules_study&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;项目路径&lt;/p&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;├── &lt;span class=&quot;selector-tag&quot;&gt;README&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.md&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── &lt;span class=&quot;selector-tag&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── &lt;span class=&quot;selector-tag&quot;&gt;node_modules&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └── ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── &lt;span class=&quot;selector-tag&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.json&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── &lt;span class=&quot;selector-tag&quot;&gt;src&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── &lt;span class=&quot;selector-tag&quot;&gt;animation&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.css&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── &lt;span class=&quot;selector-tag&quot;&gt;colors&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.css&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── &lt;span class=&quot;selector-tag&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └── &lt;span class=&quot;selector-tag&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.css&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── &lt;span class=&quot;selector-tag&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.config&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="CSS Modules" scheme="https://lz5z.com/tags/CSS-Modules/"/>
    
      <category term="webpack" scheme="https://lz5z.com/tags/webpack/"/>
    
      <category term="vue" scheme="https://lz5z.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 动画—animation</title>
    <link href="https://lz5z.com/CSS3%E5%8A%A8%E7%94%BB%E2%80%94animation/"/>
    <id>https://lz5z.com/CSS3动画—animation/</id>
    <published>2017-06-12T17:23:48.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>animation 属性目前还存在浏览器兼容性问题，建议使用 PostCSS 或手动添加浏览器前缀。本文学习使用 animation 属性创建简单动画。</p><!DOCTYPE html><html lang="en"><head><style>.anima_div{width:60px;height:40px;background:#92B901;position:relative;padding:20px 10px 0 10px;animation:animated_div 5s infinite;border-radius:5px}@keyframes animated_div{0%{transform:rotate(0);left:0}25%{transform:rotate(20deg);left:0}50%{transform:rotate(0);left:300px}55%{transform:rotate(0);left:300px}70%{transform:rotate(0);left:300px;background:#1ec7e6}100%{transform:rotate(-360deg);left:0}}</style></head><body><div class="anima_div"></div></body></html><a id="more"></a><h2>animation</h2><p>animation 是复合属性，其子属性有：</p><p>(1) animation-delay 动画延时<br>(2) animation-direction 动画在每次运行完后是反向运行还是重新回到开始位置重复运行<br>(3) animation-duration 动画一个周期的时长<br>(4) animation-iteration-count 动画重复次数，infinite无限次重复动画<br>(5) animation-name 指定由 @keyframes<br>(6) animation-timing-function 设置动画速度曲线，默认是 “ease”<br>(7) animation-fill-mode 指定动画执行后跳回到初始状态还是保留在结束状态<br>此外，还有 animation-play-state 属性，但是不能简写到 animation 属性中，该属性允许暂停和恢复动画。</p><p>基本语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">animation-name</span>: <span class="selector-tag">first_animation</span>;</span><br><span class="line"><span class="selector-tag">animation-duration</span>: 5<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">animation-timing-function</span>: <span class="selector-tag">linear</span>;</span><br><span class="line"><span class="selector-tag">animation-delay</span>: 2<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">animation-iteration-count</span>: <span class="selector-tag">infinite</span>;</span><br><span class="line"><span class="selector-tag">animation-direction</span>: <span class="selector-tag">alternate</span>;</span><br><span class="line"><span class="selector-tag">animation-play-state</span>: <span class="selector-tag">running</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简写 */</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">first_animation</span> 5<span class="selector-tag">s</span> <span class="selector-tag">linear</span> 2<span class="selector-tag">s</span> <span class="selector-tag">infinite</span> <span class="selector-tag">alternate</span>;</span><br></pre></td></tr></table></figure><blockquote><p>animation: name duration timing-function delay iteration-count direction;</p></blockquote><h3>@keyframes</h3><p>@keyframes 用于规定动画如何从一种样式逐渐变化为另一种样式，其基本用法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> first_animation &#123;</span><br><span class="line">  0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">  50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> first_animation &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键词 “from” 和 “to”，等同于 0% 和 100%，表示动画开始状态和结束状态。中间状态由浏览器自动推算。</p><h3>animation-iteration-count</h3><p>animation-iteration-count 指定动画播放的次数，默认值为 1。可以指定具体的次数，也可以使用关键字 infinite 让动画无限次播放。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">animation-name</span>: <span class="selector-tag">first_animation</span>;</span><br><span class="line"><span class="selector-tag">animation-duration</span>: 5<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">animation-iteration-count</span>: 1;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-tag">animation</span>: <span class="selector-tag">first_animation</span> 5<span class="selector-tag">s</span> <span class="selector-tag">infinite</span>;</span><br></pre></td></tr></table></figure><h3>animation-fill-mode</h3><p>animation-fill-mode 指定动画执行后跳回到初始状态还是保留在结束状态。</p><blockquote><p>animation-fill-mode : none | forwards | backwards | both;</p></blockquote><p>none: 不改变默认行为<br>forwards：当动画完成后，保持最后一个属性值(在最后一个关键帧中定义)<br>backwards：让动画回到第一帧的状态(在第一个关键帧中定义)<br>both：根据 animation-direction 轮流应用 forwards 和 backwards 规则</p><script async src="//jsfiddle.net/Leo555/3nrjmak2/1/embed/result,html,css/"></script><h3>animation-direction</h3><p>animation-direction 指定对象动画运动的方向，有以下四种取值：</p><p>normal：正常方向，默认<br>reverse：动画反向运行,方向始终与normal相反<br>alternate：动画会循环正反方向交替运动<br>alternate-reverse：动画从反向开始，再正反方向交替运动</p><h3>animation-play-state</h3><p>animation-play-state 用于手动控制动画的状态，有 paused 和 running 两种取值：</p><p>running：默认值，表示动画正常运动<br>paused：表示暂停动画</p><script async src="//jsfiddle.net/Leo555/0yzvd9nL/2/embed/result,css/"></script><h2>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations" target="_blank" rel="noopener">MDN-CSS Animations</a></li><li><a href="http://www.cnblogs.com/imwtr/p/5885885.html" target="_blank" rel="noopener">CSS3的变形transform、过渡transition、动画animation学习</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener">CSS动画简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;animation 属性目前还存在浏览器兼容性问题，建议使用 PostCSS 或手动添加浏览器前缀。本文学习使用 animation 属性创建简单动画。&lt;/p&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;style&gt;.anima_div{width:60px;height:40px;background:#92B901;position:relative;padding:20px 10px 0 10px;animation:animated_div 5s infinite;border-radius:5px}@keyframes animated_div{0%{transform:rotate(0);left:0}25%{transform:rotate(20deg);left:0}50%{transform:rotate(0);left:300px}55%{transform:rotate(0);left:300px}70%{transform:rotate(0);left:300px;background:#1ec7e6}100%{transform:rotate(-360deg);left:0}}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;anima_div&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="animation" scheme="https://lz5z.com/tags/animation/"/>
    
      <category term="动画" scheme="https://lz5z.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 动画—transition</title>
    <link href="https://lz5z.com/CSS3%E5%8A%A8%E7%94%BB%E2%80%94transition/"/>
    <id>https://lz5z.com/CSS3动画—transition/</id>
    <published>2017-06-12T10:21:22.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3 过渡属性被封装在 transition 规范中，过渡的意义在于，给了 CSS 时间轴的概念，在此之前所有的 CSS 状态变化都是瞬间完成的。过渡可以视为简单版的动画，通过定义开始状态和结束状态，达到样式转变的功能。</p><p>目前各大浏览器都支持 transition，所以不加浏览器前缀即可使用。</p><p>CSS3 transition 规范定义了以下四个 CSS 属性：</p><p>transition-delay(过渡延迟时间)<br>transition-duration(过渡持续时间)<br>transition-property(过渡属性)<br>transition-timing-function(过渡效果的时间曲线)</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* transition: 1s 1s width ease; */</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">width</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-delay</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">ease</span>;</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/kd7f9khw/embed/result,html,css/"></script><h3>过渡属性 transition-property</h3><p>默认值为 all，表示浏览器所有能接受的可过渡属性，可以使用单个值或以逗号隔开的多个值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">width</span>,<span class="selector-tag">height</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>,2<span class="selector-tag">s</span>;</span><br><span class="line"><span class="comment">/* transition: 1s width, 2s height; */</span></span><br><span class="line"><span class="comment">/* transition: width 1s, height 2s; */</span></span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/whanfhLk/2/embed/result,html,css/"></script><p>可以在 <a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="noopener">这里</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties" target="_blank" rel="noopener">这里</a> 查看哪些 CSS 属性支持 transition。</p><h3>延迟时间 transition-delay</h3><p>transition-delay 属性规定了在执行一个过渡之前的等待时间。IE 和 Opera 不接受 transition-duration 在-10ms和10ms之间的值。默认值0表示不过渡直接看到执行后的结果。单位是秒s，也可以是毫秒ms。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition-delay</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-delay</span>: 1000<span class="selector-tag">ms</span>;</span><br></pre></td></tr></table></figure><h3>过渡时间 transition-duration</h3><p>动画的执行时间，默认值0表示不过渡。单位是秒s，也可以是毫秒ms。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1000<span class="selector-tag">ms</span>;</span><br></pre></td></tr></table></figure><h3>过渡效果 transition-timing-function</h3><p>ease：默认值，缓解效果，变化速度逐渐放慢<br>linear：线性效果，匀速变化<br>ease-in：渐显效果，加速变化<br>ease-out：渐隐效果，减速变化<br>ease-in-out：渐显渐隐效果<br>cubic-bezier： 自定义变化速度，可以使用 <a href="http://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="noopener">cubic-bezier</a> 定制想要的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> <span class="selector-tag">cubic-bezier</span>(<span class="selector-class">.14</span>,<span class="selector-class">.78</span>,<span class="selector-class">.92</span>,<span class="selector-class">.36</span>) 1<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/37m1tc5a/1/embed/result,html,css/"></script><h3>transition</h3><p>transition 是一个复合属性，可以同时定义<br>transition-property、transition-duration、transition-timing-function、transition-delay 子属性值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* property name | duration | timing function | delay */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">margin-left</span> 4<span class="selector-tag">s</span> <span class="selector-tag">ease-in-out</span> 1<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* property name | duration | delay */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">margin-left</span> 4<span class="selector-tag">s</span> 1<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* property name | duration */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">margin-left</span> 4<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Apply to all changed properties */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">all</span> 0<span class="selector-class">.5s</span> <span class="selector-tag">ease-out</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Apply to multiple properties */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 2<span class="selector-tag">s</span>, <span class="selector-tag">height</span> 2<span class="selector-tag">s</span>, <span class="selector-tag">background-color</span> 2<span class="selector-tag">s</span>, <span class="selector-tag">transform</span> 2<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><p>写复合属性的时候，四个属性是可以改变顺序的，不过两个时间属性若同时出现，第一个代表 duration，第二个代表 delay，如果只出现一个时间属性，则表示 duration。</p><h3>transition 结合 transform</h3><p>使用 transition 结合 transform 能够完成一些简单的动画效果</p><script async src="//jsfiddle.net/Leo555/e7j3p7ru/2/embed/result,html,css/"></script><p>使用 transition 做动画简单易用，不过也存在一些缺点：</p><p>(1) 动画需要事件触发<br>(2) 动画只能执行一次<br>(3) transition 只能定义开始状态和结束状态，不能定义中间状态</p><p>因此如果想要完成比较复杂的动画，还是要用 css3 中的 animation 属性。</p><h2>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener">CSS动画简介</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions" target="_blank" rel="noopener">MDN-Using CSS transitions</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS3 过渡属性被封装在 transition 规范中，过渡的意义在于，给了 CSS 时间轴的概念，在此之前所有的 CSS 状态变化都是瞬间完成的。过渡可以视为简单版的动画，通过定义开始状态和结束状态，达到样式转变的功能。&lt;/p&gt;&lt;p&gt;目前各大浏览器都支持 transition，所以不加浏览器前缀即可使用。&lt;/p&gt;&lt;p&gt;CSS3 transition 规范定义了以下四个 CSS 属性：&lt;/p&gt;&lt;p&gt;transition-delay(过渡延迟时间)&lt;br&gt;transition-duration(过渡持续时间)&lt;br&gt;transition-property(过渡属性)&lt;br&gt;transition-timing-function(过渡效果的时间曲线)&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="动画" scheme="https://lz5z.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="transition" scheme="https://lz5z.com/tags/transition/"/>
    
      <category term="过渡" scheme="https://lz5z.com/tags/%E8%BF%87%E6%B8%A1/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 动画—transform</title>
    <link href="https://lz5z.com/CSS3%E5%8A%A8%E7%94%BB%E2%80%94transform/"/>
    <id>https://lz5z.com/CSS3动画—transform/</id>
    <published>2017-06-09T16:23:31.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>在 CSS3 中，跟动画相关的属性有：变形 transform、过渡 transition、动画 animation。先放一个 Lea Verou 大神的链接 <a href="http://leaverou.github.io/animatable/" target="_blank" rel="noopener">animatable</a>。</p><p>本章学习 CSS3 中的 transform 属性。</p><a id="more"></a><h2>变形 transform</h2><p>transform 属性目前还存在浏览器兼容性问题，建议使用 PostCSS 或手动添加浏览器前缀。<br>使用 transform，元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew）。<br>transform 属性只对 block 元素生效。</p><script async src="//jsfiddle.net/Leo555/jeejj6yL/13/embed/result,html,css/"></script><h3>移动 translate</h3><p>transform: translate(x, y); 表示使元素在 X 轴和 Y 轴移动，y 可以省略，表示不移动。如果参数为负，则表示往相反的方向移动。同时还可以使用 translateX、translateY 和 translateZ 表示在某一个方向移动。Z 轴移动的前提是元素本身或者元素的父元素设定了透视值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(12<span class="selector-tag">px</span>, 50%);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(2<span class="selector-tag">em</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(0<span class="selector-class">.3in</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(20<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/bhotf9bb/embed/result,html,css/"></script><h3>旋转 rotate</h3><p>旋转 transform: rotate(angle) angle 取值有：角度值deg，弧度值rad，梯度gard，转/圈turn，正数值代表顺时针旋转，反之逆时针。</p><p>rotateX、rotateY、rotateZ 表示分别在 X、Y、Z 轴上旋转。rotate3d(x, y, z, angle) 表示在3维空间旋转。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-30deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(0<span class="selector-class">.5turn</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate3d</span>(1, 2<span class="selector-class">.0</span>, 3<span class="selector-class">.0</span>, 10<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateX</span>(0<span class="selector-class">.5deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(0<span class="selector-class">.5deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateZ</span>(0<span class="selector-class">.5deg</span>);</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/L5xfztsb/2/embed/result,html,css/"></script><h3>缩放 scale</h3><p>缩放 transform: scale(x, y) 表示使元素在 X 轴和 Y 轴缩放。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(2, 0<span class="selector-class">.5</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(2);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(0<span class="selector-class">.5</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale3d</span>(2<span class="selector-class">.5</span>, 1<span class="selector-class">.2</span>, 0<span class="selector-class">.3</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleZ</span>(0<span class="selector-class">.3</span>);</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/bo2zu0fv/embed/result,html,css/"></script><h3>倾斜 skew</h3><p>倾斜 transform: skew(x, y) 表示 X 轴和 Y 轴倾斜的角度，取值类型为角度值deg。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skew</span>(30<span class="selector-tag">deg</span>, 20<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewX</span>(30<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewY</span>(1<span class="selector-class">.07rad</span>);</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/h7pox5r3/4/embed/result,html,css/"></script><h3>矩阵变形 matrix</h3><p>矩阵变形transform: matrix(a,c,e,b,d,f) 相当于直接应用一个[a c e b d f]变换矩阵。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>:  <span class="selector-tag">matrix</span>(<span class="selector-tag">a</span>, <span class="selector-tag">c</span>, <span class="selector-tag">b</span>, <span class="selector-tag">d</span>, <span class="selector-tag">tx</span>, <span class="selector-tag">ty</span>)</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/nn7q512z/embed/result,html,css/"></script><h3>变形原点 transform-origin</h3><p>transform-origin 用来定义转换元素的位置，在没有重置 transform-origin 改变元素原点位置的情况下，CSS 的变形操作都是以元素自己中心位置进行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span>;</span><br><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line"><span class="selector-tag">transform-origin</span>: 50% 100%;</span><br><span class="line"><span class="selector-tag">transform-origin</span>: 50% <span class="selector-tag">bottom</span>;</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(30<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure><script async src="//jsfiddle.net/Leo555/o992vtgg/embed/result,html,css/"></script><h2>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform" target="_blank" rel="noopener">MDN</a></li><li><a href="http://www.cnblogs.com/imwtr/p/5885885.html" target="_blank" rel="noopener">CSS3的变形transform、过渡transition、动画animation学习</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 CSS3 中，跟动画相关的属性有：变形 transform、过渡 transition、动画 animation。先放一个 Lea Verou 大神的链接 &lt;a href=&quot;http://leaverou.github.io/animatable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;animatable&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;本章学习 CSS3 中的 transform 属性。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="动画" scheme="https://lz5z.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="transform" scheme="https://lz5z.com/tags/transform/"/>
    
      <category term="变形" scheme="https://lz5z.com/tags/%E5%8F%98%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>异形：契约</title>
    <link href="https://lz5z.com/%E5%BC%82%E5%BD%A2%E5%A5%91%E7%BA%A6/"/>
    <id>https://lz5z.com/异形契约/</id>
    <published>2017-05-16T22:49:25.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p>今年最期待的电影，没有之一。《异形》系列电影忠实粉丝，不知道看了多少遍。2012年的《普罗米修斯》也是不亚于《异形1》的经典之作，雷德利·斯科特更是越老电影越具有哲思。</p><a id="more"></a><p>下面是 B 站上的一则影评，建议高清食用。</p><p><embed height="415" width="544" quality="high" allowfullscreen type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=10597309&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年最期待的电影，没有之一。《异形》系列电影忠实粉丝，不知道看了多少遍。2012年的《普罗米修斯》也是不亚于《异形1》的经典之作，雷德利·斯科特更是越老电影越具有哲思。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="电影" scheme="https://lz5z.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="异形" scheme="https://lz5z.com/tags/%E5%BC%82%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>机器学习—通过 APP 预测用户性别</title>
    <link href="https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94app%E9%A2%84%E6%B5%8B%E7%94%A8%E6%88%B7%E6%80%A7%E5%88%AB/"/>
    <id>https://lz5z.com/机器学习—app预测用户性别/</id>
    <published>2017-05-16T14:32:51.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>项目描述</h2><p>公司组织的一个机器学习的小比赛，<s> 数据<a href="">下载地址</a></s> 。大意是根据用户所安装的 APP (加密)预测用户的性别，训练数据标记 label (性别)，典型的监督学习方案。</p><h2>数据描述</h2><p>下载之后，解压成为文本文件。 数据格式如下：<br>每一行代表一个用户的数据，一共120万个样本用户数据<br>每一行都有5列，每一列以制表符 tab 分割（\t)。<br>第一列是用户编号（已经脱敏，转化成1 ~1,200,000的编号)<br>第二列是用户的性别 （male/female)<br>第三列是用户的移动设备类型<br>第四列是用户的 APP 列表，每个 APP 已经脱敏，以数字编号代替 APP 名称。多个 APP 之间以逗号（,)作为分隔符<br>第五列是用户所在区域。</p><p>其中移动设备类型/APP 列表/区域是特征数据。性别是结果数据。</p><a id="more"></a><h2>方案</h2><p>首先分析数据，一共有机型、APP、区域三个维度。性别可能对 APP 和机型有偏好，但是不能对区域有偏好，而是不同的区域可能对 APP 有不同的偏好，比如某省用户偏爱直播，某省用户偏爱交友等等。</p><p>建模方案，把 APP 和 机型（数值化）作为两个维度对数据进行训练，分区域建模，不同的区域使用不同的模型。然后使用全部数据或随机部分数据建模形成公共数据模型，公共模型用来分析用户区域数据不足或者来自未建模区域的数据。</p><h2>具体实现</h2><p>技术方案：Python + scikit-learn + pandas + numpy</p><p>环境搭建使用 Anaconda</p><p><s><a href="https://github.com/Leo555/wps_ai_war" target="_blank" rel="noopener">代码地址</a></s></p><h2>项目难点</h2><p>项目困难主要出现在 APP 降维，也就是判断哪些 APP 与性别相关，这是一个相关性分析的问题。网上找了很多资料，算法描述也有，不过没有找到合适的 Python 实现。Spark 版本的倒是很多，可是不想在一个小项目里面使用两种技术栈。</p><h2>进度</h2><p>目前使用上海数据建模，只使用 APP 信息，未加入机型信息，预测准确度大约为79%。<br>后面会加入机型信息，并使用特征提取对 APP 信息进行降维，希望能提高准确率。</p><h2>说明</h2><p>由于公司政策原因，代码不能放入 github，后续会把思路和核心代码写出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;项目描述&lt;/h2&gt;&lt;p&gt;公司组织的一个机器学习的小比赛，&lt;s&gt; 数据&lt;a href=&quot;&quot;&gt;下载地址&lt;/a&gt;&lt;/s&gt; 。大意是根据用户所安装的 APP (加密)预测用户的性别，训练数据标记 label (性别)，典型的监督学习方案。&lt;/p&gt;&lt;h2&gt;数据描述&lt;/h2&gt;&lt;p&gt;下载之后，解压成为文本文件。 数据格式如下：&lt;br&gt;每一行代表一个用户的数据，一共120万个样本用户数据&lt;br&gt;每一行都有5列，每一列以制表符 tab 分割（\t)。&lt;br&gt;第一列是用户编号（已经脱敏，转化成1 ~1,200,000的编号)&lt;br&gt;第二列是用户的性别 （male/female)&lt;br&gt;第三列是用户的移动设备类型&lt;br&gt;第四列是用户的 APP 列表，每个 APP 已经脱敏，以数字编号代替 APP 名称。多个 APP 之间以逗号（,)作为分隔符&lt;br&gt;第五列是用户所在区域。&lt;/p&gt;&lt;p&gt;其中移动设备类型/APP 列表/区域是特征数据。性别是结果数据。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://lz5z.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="scikit-learn" scheme="https://lz5z.com/tags/scikit-learn/"/>
    
      <category term="性别预测" scheme="https://lz5z.com/tags/%E6%80%A7%E5%88%AB%E9%A2%84%E6%B5%8B/"/>
    
      <category term="APP" scheme="https://lz5z.com/tags/APP/"/>
    
  </entry>
  
  <entry>
    <title>再不学 flex 就不会写布局了</title>
    <link href="https://lz5z.com/FlexLayoutLearning/"/>
    <id>https://lz5z.com/FlexLayoutLearning/</id>
    <published>2017-04-19T20:35:52.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>如何居中的问题</h2><p>块状元素居中是一个老生常谈的话题，之前面试的时候考官也曾问到过这个。下面写几种常见的块状元素居中的方式。</p><a id="more"></a><p>假如想要 con 在 box 中居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3>绝对布局，使用 margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ebebeb</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.con</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>相对布局，计算 left 和 top</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ebebeb</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.con</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>父容器宽高不确定或者不容易确定，综合相对布局 + 绝对布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ebebeb</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.con</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>使用 flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ebebeb</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.con</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>flex + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ebebeb</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.con</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 flex 布局的优势不可谓不明显：</p><ul><li>免去了很多计算。最后两个使用 flex 布局的例子中，无论父元素还是子元素的宽度和高度发生改变，都能依然能保持居中；而前面三种方法中，则需要都要改变其他值，才能保持居中。</li><li>使用 flex 布局的语义化要比前面几种都好，前面三种方法给了一大堆数字，不去认真看一看、算一算，很难确定是否是居中，这对代码阅读者也是非常不友好。</li><li>flex 对响应式布局的支持更好。虽然前面几种方法也能实现响应式布局，但是实现起来比较麻烦，不如 flex 来得实在。</li><li>flex 支持行内元素。</li></ul><h2>什么是 flex 布局</h2><p>传统布局的核心是盒子模型，依赖 display 属性 + position 属性 + float 属性。可以看出来传统布局非常容易实现像 word 左对齐，右对齐这样的功能，可以说，传统布局更适合于文字排版。</p><p>flex 是 flexible Box 的缩写，可以看做弹性的盒子模型。</p><h3>flex 用法</h3><p>使用 flex 首先要设置父元素 <code>display: flex</code>。任何元素都可以指定为 flex 布局：</p><p>块状元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p><h2>flex 两个基本概念</h2><p>flex 的核心的概念就是 <strong>容器</strong> 和 <strong>轴</strong>。容器包括外层的 <strong>父容器</strong> 和内层的 <strong>子容器</strong>，轴包括 <strong>主轴</strong> 和 <strong>交叉轴</strong>，如下图所示：</p><img src="/assets/img/flex-layout.png" alt="我是一只的图片"><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置叫做 main start，结束位置叫做 main end；交叉轴同理，<br>子容器默认沿主轴排列。单个子容器占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><p>容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。</p><h2>父容器</h2><p>父容器一共有6个属性: <strong>flex-direction, flex-wrap, flex-flow, justify-content, align-items, align-content</strong></p><h3>flex-direction 属性决定主轴的方向</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">flex-direction: row</td><td style="text-align:left">（默认值）主轴为水平方向，起点在左端</td><td style="text-align:left"><img src="/assets/img/flex-direction-row.png" alt="flex-direction-row"></td></tr><tr><td style="text-align:left">flex-direction: row-reverse</td><td style="text-align:left">主轴为水平方向，起点在右端</td><td style="text-align:left"><img src="/assets/img/flex-direction-row-reverse.png" alt="flex-direction-row-reverse"></td></tr><tr><td style="text-align:left">flex-direction: column</td><td style="text-align:left">主轴为垂直方向，起点在上沿</td><td style="text-align:left"><img src="/assets/img/flex-direction-column.png" alt="flex-direction-column"></td></tr><tr><td style="text-align:left">flex-direction: column-reverse</td><td style="text-align:left">主轴为垂直方向，起点在下沿</td><td style="text-align:left"><img src="/assets/img/flex-direction-column-reverse.png" alt="flex-direction-column-reverse"></td></tr></tbody></table><h3>flex-wrap 决定子容器是否换行排列</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">flex-wrap: nowrap</td><td style="text-align:left">（默认）不换行</td><td style="text-align:left"><img src="/assets/img/flex-wrap-nowrap.png" alt="flex-wrap-nowrap"></td></tr><tr><td style="text-align:left">flex-wrap: wrap</td><td style="text-align:left">换行，第一行在上方</td><td style="text-align:left"><img src="/assets/img/flex-wrap-wrap.png" alt="flex-wrap-wrap"></td></tr><tr><td style="text-align:left">flex-wrap: wrap-reverse</td><td style="text-align:left">换行，第一行在下方</td><td style="text-align:left"><img src="/assets/img/flex-wrap-wrap-reverse.png" alt="flex-wrap-wrap-reverse"></td></tr></tbody></table><h2>flex-flow</h2><p>flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap</p><h3>justify-content 设置子容器在主轴上的对齐方式</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">justify-content: flex-start</td><td style="text-align:left">（默认）起始端对齐</td><td style="text-align:left"><img src="/assets/img/flex-start.png" alt="flex-start"></td></tr><tr><td style="text-align:left">justify-content: flex-end</td><td style="text-align:left">末尾段对齐</td><td style="text-align:left"><img src="/assets/img/flex-end.png" alt="flex-end"></td></tr><tr><td style="text-align:left">justify-content: center</td><td style="text-align:left">居中对齐</td><td style="text-align:left"><img src="/assets/img/flex-center.png" alt="flex-center"></td></tr><tr><td style="text-align:left">justify-content: space-around</td><td style="text-align:left">子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。</td><td style="text-align:left"><img src="/assets/img/flex-space-around.png" alt="space-around"></td></tr><tr><td style="text-align:left">justify-content: space-between</td><td style="text-align:left">子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。</td><td style="text-align:left"><img src="/assets/img/flex-space-between.png" alt="space-between"></td></tr></tbody></table><h3>align-items 设置子容器沿交叉轴的对齐方式</h3><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">align-items: flex-start</td><td style="text-align:left">交叉轴的起点对齐</td><td style="text-align:left"><img src="/assets/img/align-flex-start.png" alt="flex-start"></td></tr><tr><td style="text-align:left">align-items: flex-end</td><td style="text-align:left">交叉轴的终点对齐</td><td style="text-align:left"><img src="/assets/img/align-flex-end.png" alt="flex-start"></td></tr><tr><td style="text-align:left">align-items: center</td><td style="text-align:left">交叉轴的中点对齐</td><td style="text-align:left"><img src="/assets/img/align-center.png" alt="align-center"></td></tr><tr><td style="text-align:left">align-items: baseline</td><td style="text-align:left">基线对齐（首行文字对齐）所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。</td><td style="text-align:left"><img src="/assets/img/align-baseline.png" alt="align-baseline"></td></tr><tr><td style="text-align:left">align-items: stretch</td><td style="text-align:left">（默认）如果子容器未设置高度或设为auto，子容器沿交叉轴方向的尺寸拉伸至与父容器一致</td><td style="text-align:left"><img src="/assets/img/align-stretch.png" alt="align-stretch"></td></tr></tbody></table><h2>子容器</h2><p>子容器一共有6个属性： <strong>order, flex-grow, flex-shrink, flex-basis, flex, align-self</strong></p><h3>order 改变子容器的排列顺序</h3><p>默认值为 0，可以为负值，数值越小排列越靠前。order 只能为整数。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">order: -1</td><td style="text-align:left"><img src="/assets/img/flex-order.png" alt="flex-order"></td></tr></tbody></table><h3>flex-grow 定义子容器如何瓜分剩余空间</h3><p>默认值为 0，就是即使存在剩余空间，也不瓜分。如果定义了非 0 值，则按照比例瓜分。flex-grow 只能为整数。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">flex-grow: 1</td><td style="text-align:left"><img src="/assets/img/flex-grow.png" alt="flex-grow"></td></tr></tbody></table><h3>flex-shrink 定义了子容器的缩小比例。</h3><p>默认为1，即如果空间不足，则子容器将缩小。如果所有子容器的 flex-shrink 都为1，当空间不足时，都将等比例缩小。如果某个子容器的 flex-shrink 为0，其他子容器都为1，则空间不足时，前者不缩小。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">flex-shrink: 0</td><td style="text-align:left"><img src="/assets/img/flex-shrink.png" alt="flex-shrink"></td></tr></tbody></table><h3>flex-basis 用来改变子容器占据主轴空间的大小</h3><p>表示在不伸缩的情况下子容器占据主轴空间的大小，默认为 auto，表示子容器本来的大小。</p><h3>flex</h3><p>flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto</p><h3>align-self 用来覆盖父容器的 align-items 属性</h3><p>align-self 属性允许单个子容器有与其他子容器不一样的对齐方式，默认值为auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。改属性的取值与 align-items 相同。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">align-self: flex-end</td><td style="text-align:left"><img src="/assets/img/flex-align-self.png" alt="flex-align-self"></td></tr></tbody></table><h2>参考资料</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout" target="_blank" rel="noopener">MDN CSS Flexible Box Layout</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;如何居中的问题&lt;/h2&gt;&lt;p&gt;块状元素居中是一个老生常谈的话题，之前面试的时候考官也曾问到过这个。下面写几种常见的块状元素居中的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="https://lz5z.com/categories/css/"/>
    
    
      <category term="css" scheme="https://lz5z.com/tags/css/"/>
    
      <category term="flex" scheme="https://lz5z.com/tags/flex/"/>
    
      <category term="居中" scheme="https://lz5z.com/tags/%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的作用域和声明提升</title>
    <link href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    <id>https://lz5z.com/JavaScript中的作用域和声明提升/</id>
    <published>2017-04-03T20:19:35.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一个小问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'World'</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>猜猜弹框中会输出 ‘Hello’ 还是 ‘World’。揭晓答案： ‘undefined’。这里是一个 JavaScript 的小陷阱–JavaScript 变量提升（Hoisting）。</p><a id="more"></a><h2>JavaScript Scoping</h2><p>在 ES6 之前，JavaScript 没有块状作用域（block-level scope），只有函数级作用域（function-level scope）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级作用域</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Leo'</span></span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  name = <span class="string">'Jack'</span> <span class="comment">// 这里的 name 是全局变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jack</span></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Leo'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Jack'</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// Jack    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Leo</span></span><br></pre></td></tr></table></figure><p>如果在声明一个变量的时候没有使用 var 关键字，那么变量将成为一个全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)()</span><br><span class="line">alert(a) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><p>在 setTimeout 中的函数是在全局作用域中执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">20</span>,</span><br><span class="line">  doCalculate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + <span class="keyword">this</span>.b) <span class="comment">// 3</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">obj.doCalculate() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>为了避免对全局作用域的污染， 所以一般情况下我们尽可能少的声明全局变量。</p><p>关于 ES6 中 使用 let 和 const 声明块级作用域的内容，可以参考 <a href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84let%E5%92%8Cconst/">JavaScript 中的 let 和 const</a>。</p><p>关于 ES5 中严格模式的内容可以参考 <a href="https://lz5z.com/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">JavaScript 严格模式</a>。</p><p>关于 JavaScript 中 this 的详细用法可以参考 <a href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84this/">JavaScript 中 的this</a>。</p><h2>JavaScript Hoisting</h2><p>在 JavaScript 中，函数、变量的声明都会被提升（hoisting）到该函数或变量所在的 scope 的顶部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a </span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line">b = a = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 10</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中，如果声明一个变量，但是为对其进行赋值，那么 JS 引擎会默认让其等于 undefined。所以上述例子中可以看到变量 b 在声明后，被提升到作用域顶部，和 a 一样，获得了 undefined 的值。</p><p>除了变量声明会提升，函数声明也会提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">'+'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：函数声明可以提升，但是函数表达式不能提升。</p><p>函数声明： <code>function fun(arguments) {}</code><br>函数表达式： <code>var fun = function (arguments) {}</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 报错：Uncaught TypeError: add is not a function</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">'+'</span>))  </span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>函数声明会覆盖变量声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>)  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> test) <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p>如果变量已经赋值，则无法别覆盖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">'test'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> test) <span class="comment">// 'string'</span></span><br><span class="line">test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> test) <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><h2>优先级</h2><p>在 JavaScript 中，一个变量以四种方式进入作用域 scope：</p><ol><li>语言内置：所有的作用域中都有 this 和 arguments 关键字（global 没有 arguments）;</li><li>形式参数：函数的参数在函数作用域中都是有效的;</li><li>函数声明：形如 <code>function foo() {}</code>;</li><li>变量声明：形如 <code>var bar</code>;</li></ol><p>函数声明和变量声明总是会被移动（即 hoisting）到它们所在的作用域的顶部。而变量的解析顺序（优先级），与变量进入作用域的 4 种方式的顺序一致，如果一个变量的名字与函数的名字相同，那么函数的名字会覆盖变量的名字，无论其在代码中的顺序如何，但是名字的初始化却是按其在代码中书写的顺序进行的，不受以上优先级的影响。</p><p>而变量的解析顺序（优先级），与变量进入作用域的 4 种方式的顺序一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. var 声明并且赋值高于函数声明</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'test'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> test) <span class="comment">// 'string'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数声明高于形参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// 'function'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 形参高于语言内置变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">arguments</span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">100</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="comment">/*--对比以下--*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>) <span class="comment">// [object Arguments]</span></span><br><span class="line">&#125;</span><br><span class="line">test1(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 形参优先级高于 var 声明不赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">arguments</span></span><br><span class="line">&#125;</span><br><span class="line">test() <span class="comment">// [Object Arguments]</span></span><br></pre></td></tr></table></figure><p>变量声明（赋值） &gt; 形参 &gt; 语言内置变量 &gt; 变量声明不赋值 &gt; 函数外部作用域的其他所有声明</p><p>总结变量优先级正好验证了作用域链式查找，局部作用域 -&gt; 上一级局部作用域 -&gt; 全局作用域 -&gt; TypeError。</p><p>最后看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arguments</span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">typeof</span> <span class="built_in">arguments</span>) <span class="comment">// 'function'</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">20</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">arguments</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  alert(<span class="built_in">arguments</span>) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2>参考文章</h2><p><a href="http://enml.github.io/site/2014/06/13/js-resolution/" target="_blank" rel="noopener">javascript变量声明优先级</a><br><a href="https://github.com/creeperyang/blog/issues/16" target="_blank" rel="noopener">深入理解JS中声明提升、作用域（链）和 this 关键字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先看一个小问题：&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;Hello&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&#39;World&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;猜猜弹框中会输出 ‘Hello’ 还是 ‘World’。揭晓答案： ‘undefined’。这里是一个 JavaScript 的小陷阱–JavaScript 变量提升（Hoisting）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Scoping" scheme="https://lz5z.com/tags/Scoping/"/>
    
      <category term="Hoisting" scheme="https://lz5z.com/tags/Hoisting/"/>
    
  </entry>
  
  <entry>
    <title>PostCSS 初识</title>
    <link href="https://lz5z.com/PostCSS%E5%88%9D%E8%AF%86/"/>
    <id>https://lz5z.com/PostCSS初识/</id>
    <published>2017-03-29T18:20:33.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>背景</h2><p>今天在吃早饭的时候就被同事@，说有一块页面效果在测试服务器的部署效果跟本地不一样：代码在本地运行没有问题，部署后发现有一个分割线的位置明显不对。来到公司后看了同事的演示，觉得可能是 css 代码压缩时出现了问题。</p><a id="more"></a><p>通过 chrome 查看相关 css，发现了问题所在，有一段代码是这样写的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clz_editor_container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -moz-box;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">-webkit-flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">-ms-flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩后在 chrome 中代码变成了这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clz_editor_container</span><span class="selector-attr">[data-v-5fd4dedf]</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">-ms-flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而实际浏览器中前两句都没有生效。</p><p>因为在代码压缩时，相同的代码会默认选择比较靠后的，因此 <code>display: -ms-flexbox; -ms-flex-direction: column;</code>，而 <code>-ms-flexbox</code> 和 <code>-ms-flex-direction</code> 是为了兼容 IE 浏览器而存在的， 所以这两句 css 都没有生效。</p><p>而没有压缩的代码在浏览器中运行时，浏览器自动选择了合适的 css 语句所以没有出现问题。</p><p>解决方案很简单啦，这应该是同事写代码粗心导致的，直接把 <code>display: flex; flex-direction: column;</code>加上就行了。而且 idea 里面自动代码兼容性补全功能，所以用 idea 写出的代码应该不会出现这个问题。</p><p>然后有同事说应该有一些工具能够自动补全的，于是 google 了一下，发现这种问题早就有非常好的解决方案，那就是 PostCSS 的插件 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">autoprefixer</a>。</p><h2>解决方案</h2><p>首先安装 webpack 插件 postcss-loader 和 autoprefixer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i autoprefixer postcss-loader --save-dev</span><br></pre></td></tr></table></figure><p>然后修改 webpack 配置文件，在插件系统中更改 LoaderOptionsPlugin，在 options 中增加 postcss</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">    minimize: process.env.NODE_ENV === <span class="string">'production'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        postcss:[autoprefixer()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在所有 css 相关的 loader 中增加 postcss-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">    loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        loaders: &#123;</span><br><span class="line">            js: <span class="string">'...'</span>,</span><br><span class="line">            css: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                use: <span class="string">'css-loader!postcss-loader'</span>,</span><br><span class="line">                fallback: <span class="string">'vue-style-loader'</span></span><br><span class="line">            &#125;),</span><br><span class="line">            less: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">'vue-style-loader'</span>,</span><br><span class="line">                use: <span class="string">'css-loader!postcss-loader!less-loader'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: <span class="string">'css-loader!postcss-loader'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: <span class="string">'css-loader!postcss-loader!less-loader'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 postcss-loader 应该放在 less-loader 和 css-loader 之间，处理顺序为:<br>less-loader -&gt; postcss-loader -&gt; css-loader -&gt; style-loader</p><p>修改前面出问题的 css 为原生</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clz_editor_container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新打包压缩后的 css 如下</p><img src="/assets/img/postcss-css.png" alt="css文件"><p>重新打开查看效果，问题解决。</p><p>注意如果你在 css 中使用 <code>@import</code> 引入其它 css 文件，而被引入的文件在 webpack 打包后又没有加入浏览器前缀的话，建议在 css-loader 中加入 <code>importLoaders=1</code> 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    loader: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: <span class="string">'css-loader?importLoaders=1!postcss-loader'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><a href="http://postcss.org/" target="_blank" rel="noopener">PostCSS</a></h2><p>PostCSS 是什么？官方给出的定义是： PostCSS 是一个用 JavaScript 转化 CSS 的工具。准确的说，PostCSS 是一个平台，通过一些插件，能做很多事情：</p><p>（1） 增加代码可读性<br>比如刚才我们用的 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">autoprefixer</a>，通过给 css 添加供应商前缀，让我们的 css 代码更加优雅。</p><p>（2） 使用未来 CSS 的语法特性<br>通过使用 <a href="http://cssnext.io/" target="_blank" rel="noopener">cssnext</a> 插件，可以允许我们使用最新的 css 语法，而不用等待浏览器支持。</p><p>（3）global css 终结者<br>PostCSS 通过 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noopener">CSS Modules</a> 对 css 命名做模块化处理，一般为添加前缀和后缀，让我们写 css 的时候不必担心命名太通用，只要觉得有意义即可。</p><p>（4）避免 css errors<br>通过使用 <a href="https://stylelint.io/" target="_blank" rel="noopener">stylelint</a> 来避免 css errors。</p><p>（4）更强大的栅格系统<br><a href="http://lostgrid.org" target="_blank" rel="noopener">LostGrid</a> 通过 calc() 轻松创建强大的栅格系统。</p><p>（5）<a href="http://postcss.parts/" target="_blank" rel="noopener">更多插件</a> 更多功能</p><h2>PostCSS webpack</h2><p>在 webpack 中使用 PostCSS 的一般方式</p><ol><li>安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install postcss-loader --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 postcss.config.js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-smart-import'</span>)(&#123; <span class="comment">/* ...options */</span> &#125;),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'precss'</span>)(&#123; <span class="comment">/* ...options */</span> &#125;),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123; <span class="comment">/* ...options */</span> &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过在不同路径下创建不同的 config 来实现配置覆盖的功能，在根目录下创建的 postcss.config.js 会被子目录中的配置文件覆盖。</p><ol start="3"><li>添加 PostCSS Loader 到 webpack.config.js 中，记得要把它放在 css-loader 和 style-loader 后面，如果有其它 loader，如 sass-loader 或者 less-loader， 要放在它们前面。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果不想使用 postcss.config.js 的话，也可以把插件直接写入到 webpack.config.js 中</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css/</span>,</span><br><span class="line">      use: […&#123;</span><br><span class="line">        loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          plugins: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'precss'</span>),</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">            ];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>demo</h2><p>假如有 style.css 如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"> <span class="attribute">--base-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.8s</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--base-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 配置文件下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssnext = <span class="built_in">require</span>(<span class="string">'cssnext'</span>);</span><br><span class="line"><span class="keyword">var</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>);</span><br><span class="line"><span class="keyword">var</span> px2rem = <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>);</span><br><span class="line"><span class="keyword">var</span> Ex = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/style.css'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"./dist/[name].css"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      loader: Ex.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: <span class="string">'css-loader!postcss-loader'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> Ex(&#123;</span><br><span class="line">      filename: <span class="string">'./dist/style.css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        postcss: [autoprefixer(&#123;<span class="attr">browsers</span>: [<span class="string">'last 2 versions'</span>]&#125;), </span><br><span class="line">          cssnext(), px2rem(&#123;<span class="attr">remUnit</span>: <span class="number">100</span>&#125;)]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 webpack 命令后，dist 文件夹下面的 style.css 如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.1rem</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: all <span class="number">0.8s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.8s</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共使用了三个插件，cssnext 解析 css 自定义属性和 val() 函数，autoprefixer 添加浏览器前缀，postcss-px2rem 完成 px 到 rem 单位的转化。</p><h2>参考资料</h2><ol><li>参考 <a href="http://postcss.org/" target="_blank" rel="noopener">PostCSS</a> 官方网站，了解 PostCSS 的更多内容。</li><li><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">autoprefixer</a></li><li><a href="http://cssnext.io/" target="_blank" rel="noopener">cssnext</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;今天在吃早饭的时候就被同事@，说有一块页面效果在测试服务器的部署效果跟本地不一样：代码在本地运行没有问题，部署后发现有一个分割线的位置明显不对。来到公司后看了同事的演示，觉得可能是 css 代码压缩时出现了问题。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="webpack" scheme="https://lz5z.com/tags/webpack/"/>
    
      <category term="CSS" scheme="https://lz5z.com/tags/CSS/"/>
    
      <category term="PostCSS" scheme="https://lz5z.com/tags/PostCSS/"/>
    
  </entry>
  
  <entry>
    <title>webpack 从入门到放弃</title>
    <link href="https://lz5z.com/webpack/"/>
    <id>https://lz5z.com/webpack/</id>
    <published>2017-03-11T18:06:04.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>简介</h2><p>Webpack + ES6 已经成为目前最流行的前端解决方案，本文是 Webpack2 学习教程。</p><p>在 「<a href="https://webpack.github.io/docs/what-is-webpack.html" target="_blank" rel="noopener">What is webpack</a>」一文中作者讲述了自己为什么要开发出 webpack。</p><ol><li>切分代码依赖树到不同的代码块，按需加载</li><li>保持更少的初始化加载时间</li><li>把任何静态资源都视为模块</li><li>把任何第三方类库也当作模块</li><li>在模块打包中每一部分都允许自定义</li><li>更加适合大型项目</li></ol><a id="more"></a><h2>使用</h2><h3>安装</h3><p>新建 webpack-demo 文件夹，安装 webpack 到 dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir webpack-demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm init -y</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm i webpack --save-dev</span></span><br></pre></td></tr></table></figure><h3>命令行打包</h3><p>新建一个 hello.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello webpack'</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>在命令行中输入下面内容进行打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> webpack hello.js hello.bundle.js</span></span><br></pre></td></tr></table></figure><p>打开打包后的文件发现里面注入了很多 webpack 所需的一些内置函数，比如 <strong><code>__webpack_require__</code></strong>，除此之外，webpack 还对我们写的代码进行编号，比如刚才我们写的 hello function 在 hello.bundle.js 中的编号就是 <code>/* 0 */</code>。</p><h3>引入css文件</h3><p>新建 style.css 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 hello.js 中引入该文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./style.css'</span>)</span><br></pre></td></tr></table></figure><p>再次使用刚才的命令打包，发现命令行报错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>in ./style.css</span><br><span class="line">Module parse failed: D:\webpack-demo\style.css Unexpected token (1:11)</span><br><span class="line">You may need an appropriate loader to handle this file type.</span><br><span class="line">| html, body &#123;</span><br><span class="line">|       background-color: gray;</span><br><span class="line"> @ ./hello.js 2:0<span class="string">-22</span></span><br></pre></td></tr></table></figure><p>错误提示很明显：模块解析错误，你可能需要一个合适的 loader 去处理这种类型的文件。</p><p>webpack 默认不支持 css 文件类型，所以我们来安装 css-loader 和 style-loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i css-loader style-loader --save-dev</span></span><br></pre></td></tr></table></figure><p>css-loader 是使 webpack 可以处理 css 文件；style-loader 把 css-loader 处理完的代码，新建一个 style 标签，插入到 HTML 代码中。</p><p>然后将这两个 loader 引入 hello.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'style-loader!css-loader!./style.css'</span>)</span><br></pre></td></tr></table></figure><p>再次运行打包命令就可以在 hello.bundle.js 中找到下面这句话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.push([<span class="built_in">module</span>.i, <span class="string">"body &#123;\r\n\tbackground-color: gray;\r\n&#125;"</span>, <span class="string">""</span>]);</span><br></pre></td></tr></table></figure><p>为了查看效果，我们新建 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./hello.bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 index.html 查看效果，发现 style-loader 在 head 中插入了一个 style 标签将 css 插入 html 中。</p><h2>webpack <a href="https://webpack.js.org/configuration/" target="_blank" rel="noopener">配置文件</a></h2><p>在命令行中输入 <code>webpack</code> 命令，webpack 会自动寻找 webpack.config.js 文件，并按照里面的配置对项目进行打包。还可以通过 <code>--config</code> 参数指定 webpack 配置文件。</p><p>webpack.config.js 使用 CommonJS 规范，下面是一个最基础的配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/script/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'./dist/js'</span>,</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 参数表明我们的打包是从哪个文件开始的，<code>output</code> 参数定义打包后的文件如何存储。</p><p>如果需要使用一些 webpack 的参数，可以使用 npm 脚本来实现，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"webpack --display-modules --sort-modules-by size"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我们分析 webpack 打包后文件常用的方式，把每个 modules 显示出来，并且按照文件大小排序。</p><h2>webpack 几个重要概念</h2><h3><a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener">entry</a></h3><p>webpack 根据 entry 创建所有应用程序依赖图表，entry 告诉 webpack 从哪里开始，并遵循着依赖关系图打包。</p><p>entry 有以下几种写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: <span class="string">'./src/app.js'</span></span><br><span class="line">entry: [<span class="string">'./src/app.js'</span>, <span class="string">'./src/vendors.js'</span>]</span><br><span class="line">entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/app.js'</span></span><br><span class="line">&#125;</span><br><span class="line">entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">&#125;</span><br><span class="line">entry: &#123;</span><br><span class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</span><br><span class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定多入口主要为了解决两种场景，一个是将业务代码和框架代码分割，一个是为了处理多页面应用。使用 <a href="https://github.com/webpack/docs/wiki/list-of-plugins#commonschunkplugin" target="_blank" rel="noopener">CommonsChunkPlugin</a> 插件可以将公共的类库代码打包成一个 common 模块。这样在多页面程序中可以把共用代码缓存起来，方便其他页面使用。</p><h3><a href="https://webpack.js.org/concepts/output/" target="_blank" rel="noopener">output</a></h3><p>output 参数告诉 webpack 如何把编译后的文件写入到磁盘里，无论有多少个 entry 都只有一个 output 配置。一般形式的写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/build'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output.path 是一个绝对路径，filename 指生产打包文件后的名称</p><p>假如 entry 为多入口，使用上述写法只会生产一个 bundle.js，不符合我们代码分割的需求，那么我们可以用一些占位符来表示输出的结果。一共有四种占位符：[id], [name], [hash], [chunkhash]。注意 [hash] 指的是本次打包的 hash，这个 hash 在 webpack 打包时日志的第一行显示。而 [chunkhash] 是每一个 chunk 自己的 hash 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'[name]-[chunkhash].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/build'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash 值由 md5 算法生成，可以当做每个文件的版本号，这点对于我们管理产品时每次只上线被更改的文件非常有用。如果觉得默认 hash 值太长了，可以通过 [chunkhash:8] 来指定 hash 位数。</p><p>通常我们上线产品会使用 cdn 加速静态资源文件的获取，我们可以把 cdn 写入到 output.publicPath 中。publicPath 表示如果产品上线，js 的路径就会自动加上 publicPath。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'[name]-[chunkhash].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/build'</span>,</span><br><span class="line">    publicPath: <span class="string">'http://cdn.example.com/'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><a href="https://webpack.js.org/concepts/loaders/" target="_blank" rel="noopener">loaders</a></h3><p>webpack 中把所有的资源都当做一个模块，无论这个文件是代码文件，还是图片文件，只要有对应的 loader 均可以在 webpack 中转换使用，这也是 webpack 最大的优势所在。</p><p>前面「引入css文件」中已经展示了如何使用 loader，通常配置方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">            use: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 说明了当前 loader 能处理那些类型的文件的正则匹配，use 则指定了 loader 的类型。</p><p>注：这里说一下 webpack1 与 webpack2 的区别，在 webpack1 中，使用 module.loaders 声明 loader，而 webpack2 中使用功能更为强大的 module.rules。 为了兼容旧版，module.loaders 语法仍然有效，旧的属性名依然可以被解析。</p><p>loader 还可以在使用的时候传入相关的参数，比如我们使用 css-loader 时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">'style-loader'</span>, </span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    importLoaders: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在 webpack 1 中，loader 可以链式调用，上一个 loader 的输出被作为输入传给下一个 loader，通常被用 ! 连写，如 <code>loader: &quot;style-loader!css-loader!less-loader&quot;</code>。这一写法在 webpack 2 中只在使用旧的选项 module.loaders 时才有效。使用 rule.use 配置选项，use 可以设置为一个 loader 数组。使用 module.rules 时，如果只有一个 loader，既可以用 loader 又可以用 use，但是如果是多 loader，则只能使用 use。</p><h4>处理 ES6 语法</h4><p>首先安装 babel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel-loader babel-core --save-dev</span></span><br></pre></td></tr></table></figure><p>修改 webpack 配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: path.resolve(__dirname, <span class="string">'node_modules/'</span>),</span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'src/'</span>),</span><br><span class="line">        loader: <span class="string">"babel-loader"</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里一定要加上 exclude 或者 include，因为 babel-loader 处理的速度非常慢。<br>然后还需要指定所用 ECMAScript 的版本，假如使用 ES6 语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel-preset-es2015 --save-dev</span></span><br></pre></td></tr></table></figure><p>告诉 webpack babel 使用哪个版本的 preset 有三种方式</p><p>(1) 在 webpack 中声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">            presets: [<span class="string">"es2015"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： 如果 loader 需要传参数的话，既可以写成 query 的形式，也可以写成像 url 传参一样的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"babel-loader?presets=es2015"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>但是如果为多 loader 的话，只能用 use + options 的形式。</p><p>(2) 在根目录创建 .babelrc 文件，文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 在 package.json 中指定 preset</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"babel"</span>: &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><a href="https://webpack.js.org/concepts/plugins/" target="_blank" rel="noopener">plugins</a></h3><p>插件是 wepback 的支柱功能。在你使用 webpack 配置时，webpack 自身也构建于同样的插件系统上！插件目的在于解决 loader 无法实现的其他事，在<a href="https://webpack.js.org/plugins/" target="_blank" rel="noopener">这个页面</a>你可以看到一些 webpack 常用的插件。</p><p>由于 plugin 可以传递参数，你必须在 wepback 配置中，向 plugins 属性传入 new 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">//通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">//访问内置的插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><h3>html-webpack-plugin 使用</h3><p>下面我们以最常用的 <strong><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a></strong> 为例，讲解插件的用法。</p><p>首先使用 npm 安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i html-webpack-plugin --save-dev</span></span><br></pre></td></tr></table></figure><p>然后在 webpack.config.js 配置文件中使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/script/main.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name]-[chunkhash:8].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/build'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index-[hash].html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>html-webpack-plugin</strong> 插件还能接受一些其它参数，比如<code>title</code>、<code>inject: (true | 'head' | 'body' | false)</code>、<code>favicon</code>、<code>minify</code>、<code>hash</code>、<code>cache</code>等。</p><p>还可以设置一些自定义的参数，在 html 文件中通过类似 js 模板语言的方式进行引用。<br>比如在 webpack 配置文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'index.html'</span>,</span><br><span class="line">        date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后在 index.html 中使用 <code>&lt;%= htmlWebpackPlugin.options.date %&gt;</code> 对 date 进行引用，这样就给了我们更大的自由度，用相同的 html 模板生成不同的 html 文件。</p><p>通过加上 minify 来实现对 html 文件的压缩，minify 传入一个 <a href="https://github.com/kangax/html-minifier#options-quick-reference" target="_blank" rel="noopener">html-minify</a> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'index.html'</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            collapseInlineTagWhitespace: <span class="literal">true</span>,</span><br><span class="line">            collapseWhitespace: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对于一个多页面应用程序，需要生成多少个页面，就 new 多少个 htmlWebpackPlugin 实例。假如不同的页面依赖不同的 chunks， 那么我们可以使用 chunks 参数指定当前页面所使用的 chunks。也可以使用 excludeChunks 来指定排除了某些 chunks 以后的全部 chunks。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        a: <span class="string">'./src/script/a.js'</span>,</span><br><span class="line">        b: <span class="string">'./src/script/b.js'</span>,</span><br><span class="line">        c: <span class="string">'./src/script/c.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'js/[name]-[chunkhash:8].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/build'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'a.html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            title: <span class="string">'page a'</span>,</span><br><span class="line">            chunks: [<span class="string">'a'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'b.html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            title: <span class="string">'page b'</span>,</span><br><span class="line">            chunks: [<span class="string">'b'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'c.html'</span>,</span><br><span class="line">            template: <span class="string">'index.html'</span>,</span><br><span class="line">            title: <span class="string">'page c'</span>,</span><br><span class="line">            chunks: [<span class="string">'c'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 html 模板文件为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行<code>npm run webpack</code>后生成 3 个 html 文件，分别引入其所需要的依赖。</p><h2>webpack 处理资源文件</h2><h3>样式文件 less/sass</h3><p>假如有这么一段 less</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layer</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    &gt; div &#123;</span><br><span class="line">        <span class="selector-tag">width</span>: 400<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">height</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-tag">gray</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先安装 less 和 less-loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install less less-loader --save-dev</span></span><br></pre></td></tr></table></figure><p>在 webpack 配置文件中加入 less-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">"style-loader"</span>,</span><br><span class="line">            <span class="string">"css-loader"</span>,</span><br><span class="line">            <span class="string">"less-loader"</span></span><br><span class="line">       ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>loader 的执行顺序为从后往前执行，所以其顺序为 less-loader -&gt; css-loader -&gt; style-loader。 如果需要引入 postcss-loader 的话，应该放在 less-loader 和 css-loader 中间。</p><h3>图片文件</h3><p>图片文件一般使用 <a href="https://github.com/webpack-contrib/file-loader" target="_blank" rel="noopener">file-loader</a> 配合 <a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="noopener">url-loader</a>，如果有压缩需求的话，可以使用 <a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="noopener">image-webpack-loader</a></p><p>安装两个 loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i file-loader url-loader --save-dev</span></span><br></pre></td></tr></table></figure><p>url-loader 的功能与 file-loader 十分相似，不同的是 url-loader 可以指定一个 limit 参数， 当图片或者文件的大小大于 limit 的时候，url-loader 把资源直接交给 file-loader 处理，而当资源小于 limit 的时候，url-loader 会把图片转为 base64 的编码，并直接打包到引用的文件中。</p><p>file-loader 打包的文件通过 http 请求获取，url-loader 打包的文件通过 base64 的方式获取，这两个方法各有各的优势。通过 http 载入的图片可以享受到浏览器的图片缓存，当图片重复使用次数比较多的时候具有一定的便利。base64 的方式引入图片可以降低 http 请求的次数，但是也会带来一定程度的代码冗余。</p><p>(1) 使用 file-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.(ico|jpe?g|png|svg|gif)$/i</span>,</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 使用 url-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.(ico|jpe?g|png|svg|gif)$/i</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">            name: <span class="string">'assets/[name]-[hash].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) image-webpack-loader 可以对图片文件进行压缩，并且配合 url-loader 和 file-loader 共同使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.(ico|jpe?g|png|svg|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">'url-loader?limit=10000&amp;name=assets/[name]-[hash].[ext]'</span>,</span><br><span class="line">            <span class="string">'image-webpack-loader?options=&#123;&#125;'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loader 的参数也可以通过 options 传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.(ico|jpe?g|png|svg|gif)$/i</span>,</span><br><span class="line">use: [</span><br><span class="line">    &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: <span class="number">10000</span>,</span><br><span class="line">            name: <span class="string">'assets/[name]-[hash].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">        options: &#123;&#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image-webpack-loader 可以针对不同的图片类型就行压缩，详细的信息可以在<a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="noopener">官网</a>里面查询。</p><p>注：在 image-webpack-loader 实际使用过程中，必须传入一个 options 参数，否则会报错，使用的时候注意一下。</p><blockquote><p>ERROR in Error: Child compilation failed:<br>Module build failed: TypeError: Cannot read property ‘bypassOnDebug’ of null</p></blockquote><h2>总结</h2><p>本文只是 webpack 打包的一些知识，只涉及到一些基本使用，关于 webpack 在项目中的实际应用，以及打包的一些技巧和优化，会在下一节中讲起。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;简介&lt;/h2&gt;&lt;p&gt;Webpack + ES6 已经成为目前最流行的前端解决方案，本文是 Webpack2 学习教程。&lt;/p&gt;&lt;p&gt;在 「&lt;a href=&quot;https://webpack.github.io/docs/what-is-webpack.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is webpack&lt;/a&gt;」一文中作者讲述了自己为什么要开发出 webpack。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;切分代码依赖树到不同的代码块，按需加载&lt;/li&gt;&lt;li&gt;保持更少的初始化加载时间&lt;/li&gt;&lt;li&gt;把任何静态资源都视为模块&lt;/li&gt;&lt;li&gt;把任何第三方类库也当作模块&lt;/li&gt;&lt;li&gt;在模块打包中每一部分都允许自定义&lt;/li&gt;&lt;li&gt;更加适合大型项目&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="webpack" scheme="https://lz5z.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中的各种单位</title>
    <link href="https://lz5z.com/css%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%8D%95%E4%BD%8D/"/>
    <id>https://lz5z.com/css中的各种单位/</id>
    <published>2017-02-23T14:15:49.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇到 css 中需要使用单位的情况，都草草用 px 或者百分比糊弄过去，导致当需要做一个响应式的页面的时候，要重新补一下 css 单位的技术债。</p><a id="more"></a><h2>px</h2><p>px 是 css 中最常用的字体大小单位。<br>px 就是表示 pixel，像素，是屏幕上显示数据的最基本的点；还有一个看起来很像的单位 pt，pt 就是 point，是印刷行业常用单位，等于1/72英寸，一般在打印的时候使用。<br>像素 px 是相对于显示器屏幕分辨率而言的，所以一般把它看做一个基础单位，很多其它单位都是以 px 为参照的。</p><h2>em rem</h2><p>em 指的是相对于当前对象内文本的字体大小，比如设置 body 的字体大小(font-size)为 14px，而对 body 内所有的 div 设置字体大小为 1.5em，那么 div 内字体大小就是 14px * 1.5 = 21px</p><p>通常写 html 的时候会发生很多嵌套，每个节点都从父节点继承字体大小，这样很难控制每个层级的字体大小。rem (roo em) 应运而生，rem 是指相对于根节点字体大小，通常根节点是指 html 元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">14px</span>; &#125; </span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.5rem</span>; &#125;</span><br></pre></td></tr></table></figure><p>这样所有 div 中字体的大小都是 21px 了。</p><h2>百分比</h2><p>css 中的百分比是一种相对值，使用百分比的关键是找到它的参照物。</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">参照</th></tr></thead><tbody><tr><td style="text-align:center">width &amp; height</td><td style="text-align:center">宽和高在使用百分比值时，其参照一般都是父元素的 content 的宽和高。</td></tr><tr><td style="text-align:center">margin &amp; padding</td><td style="text-align:center">margin 和 padding，其任意方向的百分比值，参照都是包含块的宽度。</td></tr><tr><td style="text-align:center">border-radius</td><td style="text-align:center">为一个元素的border-radius定义的百分比值，参照物是这个元素自身的尺寸。border-radius:50%;</td></tr><tr><td style="text-align:center">font-size</td><td style="text-align:center">参照是直接父元素的 font-size。</td></tr><tr><td style="text-align:center">line-height</td><td style="text-align:center">参照是元素自身的font-size</td></tr><tr><td style="text-align:center">vertical-align</td><td style="text-align:center">参照是元素自身的line-height</td></tr><tr><td style="text-align:center">bottom、left、right、top</td><td style="text-align:center">参照是元素的包含块。left和right是参照包含块的宽度，bottom和top是参照包含块的高度。</td></tr><tr><td style="text-align:center">transform: translate</td><td style="text-align:center">参照是元素自己的边界框的尺寸</td></tr></tbody></table><h2>vh vm</h2><p>移动互联网时代各种设备大小不一，响应式的布局变得更加流行，而响应式布局很大程度上依赖比例规则。</p><p>vh 和 vm 也是相对长度，不过其参照是显示窗口的宽度或高度，一般来说 100 vh = viewport 的高度，100vm = viewport 的宽度。</p><p>下面一段话是响应式的，你可以缩放浏览器大小来查看效果。</p><!DOCTYPE html><html><body><div class="css-vm-test">缩放浏览器大小来查看效果</div></body><style>.css-vm-test{font-size:3vw;color:red}</style></html><h2>vmin 和 vmax</h2><p>vmin 和 vmax 的出现主要是为了移动设备横竖屏切换。vmax 是相对于 viewport 宽度或者高度中比较大的一个，vmin 则是比较小的那个。比如手机屏幕宽度为1100px，高度为700px，那么 100vmin = 700px, 100vmax = 1100px。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前遇到 css 中需要使用单位的情况，都草草用 px 或者百分比糊弄过去，导致当需要做一个响应式的页面的时候，要重新补一下 css 单位的技术债。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://lz5z.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://lz5z.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0 组件通信</title>
    <link href="https://lz5z.com/vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>https://lz5z.com/vue2组件通信/</id>
    <published>2017-02-17T10:46:29.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 采用基于组件的开发方式，那么组件之间的通信必不可少：比如父组件要给子组件传递数据，子组件将它内部发生的事情告知给父组件，因此定义一个良好的接口尽可能将组件解耦显得尤为重要，这保证不同的组件可以在相对独立的环境中开发测试，而且更方便阅读理解以及组件复用。</p><p>Vue 父子组件之间通信主要采取两种方式，通常可以总结为 <strong>props down</strong>、<strong>events up</strong>，父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息，这点跟 React 一模一样。</p><a id="more"></a><p>Vue2.0 废除了 <code>events</code>、<code>$dispatch</code>、<code>$broadcast</code> 几个事件，官方推荐使用 <a href="https://github.com/vuejs/vue/issues/2873" target="_blank" rel="noopener">全局事件驱动 或者 vuex</a>代替，目前只剩下 <code>vm.$on</code>、<code>vm.$once</code>、<code>vm.$off</code>、<code>vm.$emit</code> 几个事件。</p><h2>props down</h2><p>Vue 组件之间的作用域是相互隔离的，父组件向子组件传值只能通过 props 的方式，子组件不能直接调用父组件的数据。在子组件中，如果需要调用父组件传来的参数，必须显式的声明 props。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'message'</span>],</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>父组件向子组件传值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><h3>单向数据流</h3><p>props 传递值只能父组件向子组件传递，不能反回来，每当父组件更新时，子组件中的 props 会自动更新。如果在子组件中更改 props，Vue 控制台会给出 warning。因此如果需要在子组件中更改 props 通常会把其作为初始值赋值给某个变量，然后变量的值，或者在计算属性中定义一个基于 props 的值。</p><h2>events up</h2><p>如果子组件需要把信息传达给父组件，可以使用 <code>v-on</code> 绑定自定义事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们给 button-counter 绑定了一个自定义事件 <code>increment</code>，v-on 绑定事件还可以简写为 <code>@increment=&quot;&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#counter-event-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal() &#123;</span><br><span class="line">      <span class="keyword">this</span>.total += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>button-counter 组件的模板中包含一个 button，其 click 事件会触发($emit)自定义事件 <code>increment</code>，因此每次在子组件中点击一次 button，父组件中都会调用 incrementTotal() 方法。</p><h2>非父子组件通信</h2><p>上面讲的两种方法都父子组件之间的通信，有时候非父子关系的组件也需要通信。在 Vue1.0 时代，可以通过 $dispatch 和 $broadcast 来解决，首先 dispatch 到根组件，然后再 broadcast 到子组件。Vue2.0 中官方推荐用 event bus 或者 vuex 解决，event bus 的本质是一个发布者订阅者模式。</p><ul><li>使用一个空的 Vue 实例作为中央事件总线<br><code>var bus = new Vue()</code></li><li>触发组件 A 中的事件(发布消息)<br><code>bus.$emit('id-selected', 1)</code></li><li>在组件 B 创建的钩子中监听事件（订阅消息）<br><code>bus.$on('id-selected', function (id) {})</code></li></ul><p>下面是 <a href="https://stackoverflow.com/questions/38064054/vue-js-global-event-bus" target="_blank" rel="noopener">stackoverflow</a> 上面的一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Display</span>&gt;</span><span class="tag">&lt;/<span class="name">Display</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Increment</span>&gt;</span><span class="tag">&lt;/<span class="name">Increment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'Increment'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;button @click="increment"&gt;+&lt;/button&gt;`</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> increment = <span class="keyword">this</span>.count++</span><br><span class="line">      bus.$emit(<span class="string">'inc'</span>, increment)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'Display'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h3&gt;Clicked: &#123;&#123;count&#125;&#125; times&lt;/h3&gt;`</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   bus.$on(<span class="string">'inc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.count = num</span><br><span class="line">   &#125;.bind(<span class="keyword">this</span>))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> el: <span class="string">"#example"</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2>全局状态管理 <a href="https://vuex.vuejs.org" target="_blank" rel="noopener">Vuex</a></h2><p>Vuex 是 Vue 组件的一个状态管理器，相当于一个只为 Vue 服务的 <a href="http://redux.js.org/" target="_blank" rel="noopener">Redux</a>。下面一个图能很好的反映出 Vuex 是如何让组件之间通信的。</p><img src="/assets/img/vuex.png" alt="vuex" width="50%"><p>下面是 Vuex 官网上给出的一个 <a href="https://jsfiddle.net/n9jmu5v7/341/" target="_blank" rel="noopener">计数器的例子</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrement"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment: <span class="function"><span class="params">state</span> =&gt;</span> state.count++,</span><br><span class="line">    decrement: <span class="function"><span class="params">state</span> =&gt;</span> state.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count() &#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      store.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement() &#123;</span><br><span class="line">      store.commit(<span class="string">'decrement'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击查看效果</p><!DOCTYPE html><html lang="en"><body><div id="app"><p>{{ count }}</p><p><button @click="increment">+</button> <button @click="decrement">-</button></p></div></body><script src="https://unpkg.com/vue/dist/vue.js"></script><script src="https://unpkg.com/vuex@2.0.0"></script><script type="text/javascript">const store = new Vuex.Store({  state: {    count: 0  },  mutations: {    increment: state => state.count++,    decrement: state => state.count--  }})const app = new Vue({  el: '#app',  computed: {    count() {      return store.state.count    }  },  methods: {    increment() {      store.commit('increment')    },    decrement() {      store.commit('decrement')    }  }})</script></html><p>在 Vuex 中，store 是组件状态的一个容器，上面的 store 中定义了一个初始的 state 对象，和两个 mutations 函数。我们可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更。要注意的是，我们不能直接更改 store 中的状态，改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。</p><h2>总结</h2><ol><li>父组件向子组件传递信息使用 props down</li><li>子组件向父组件传递信息使用 event up</li><li>其它关系类型组件通信使用 global event bus</li><li>大型 SPA 组件之间通信使用 Vuex 管理组件状态</li></ol><p>如果想要在 vue2 中使用 dispatch 和 broadcast，可以参考 <a href="https://lz5z.com/vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-%E4%BD%BF%E7%94%A8dispatch%E5%92%8Cbroadcast/">vue2 组件通信——使用 dispatch 和 broadcast</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 采用基于组件的开发方式，那么组件之间的通信必不可少：比如父组件要给子组件传递数据，子组件将它内部发生的事情告知给父组件，因此定义一个良好的接口尽可能将组件解耦显得尤为重要，这保证不同的组件可以在相对独立的环境中开发测试，而且更方便阅读理解以及组件复用。&lt;/p&gt;&lt;p&gt;Vue 父子组件之间通信主要采取两种方式，通常可以总结为 &lt;strong&gt;props down&lt;/strong&gt;、&lt;strong&gt;events up&lt;/strong&gt;，父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息，这点跟 React 一模一样。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://lz5z.com/categories/Vue/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="https://lz5z.com/tags/Vue/"/>
    
      <category term="Vuex" scheme="https://lz5z.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>跳槽小记</title>
    <link href="https://lz5z.com/%E8%B7%B3%E6%A7%BD%E5%B0%8F%E8%AE%B0/"/>
    <id>https://lz5z.com/跳槽小记/</id>
    <published>2017-02-15T13:26:28.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<img src="/assets/img/跳槽.png" alt="跳槽"><h2>面试经历</h2><p>一共去金山面了三次试，一次是后台开发，两次是前台开发。去年11月份的时候第一次去金山面试服务器开发的职位，很多问题都没有答上来，就惨淡离去了。后来又有一个前端开发的岗位，抱着试一试的态度就去了。</p><a id="more"></a><h3>第一次前端面试</h3><p>刚开始跟第一个面试官聊得挺不错，技术问题讨论完了，面试官问我能否带项目，我表示自己暂时没有那个能力。面试官又问及学习能力，我表示自己平时一直坚持学习新知识，也有读一些书，然后这个面试官就出去了。出去以后听到外面有人在讨论，我隐约听到刚才的面试官说：「他完全不符合这个岗位的要求』。我想，看来这次又没戏了，然后安慰自己：没关系，回去继续学习就好了，反正知识都是自己的。</p><p>过了一会，进来了两个人，一个是项目组的经理，另外一个不知道是什么职位。经理首先跟我说，他们不是进来面试的，就是想跟我聊一下。那就聊呗。原来他们是想招一个有三五年经验的可以直接带项目的人，目前有一个项目的重构工作要做，不过看我表现还行，就想看下我有没有这个能力在短时间内成长为这样的角色。这个时候我内心是窃喜的，对于一个只有一年多工作经验的新人来说，能有这样一个锻炼的机会是多么宝贵，可是又觉得压力挺大，毕竟之前都是在 leader 手下工作，只是做一下 task，框架设计类的工作都是 leader 做好的，我只在里面添加功能而已。</p><p>后面一直聊，关于能否胜任这个职位，我始终都没有给经理一个准确的答复，只表示这对我是一个很大的挑战，也是我努力的方向。我想，后来没有拿到这个职位主要也是因为这个原因吧。不过职位是双向选择的，即使我愿意，他们也肯定会把我跟其他应聘者比较，最终选出合适的人选。</p><p>跟这个经理聊完已经快要六点了，这个时候我又累又渴，聊了这么久口干舌燥。经理出去后，HR 助理过来说 HR 还在面试别人，等下会过来，让我再稍等一会。那天好像有很多实习生过来，所以就把我排在了最后。</p><p>终于等到了 HR，HR 看起来也很疲倦，我就首先向她慰问，表示辛苦了。然后 HR 简单地聊了几句，就结束了，整个过程不到五分钟。</p><p>第二天 HR 助理打来电话，说我跟职位要求不是特别符合，不过有另外一个部门的职位问我愿不愿意试一下。我说愿意啊，然后答应过几天再去面试。感觉好累啊。</p><h3>第二次面试</h3><p>再一次去面试就轻松多了，跟第一个面试官简单聊了几个技术问题，写了几行代码他就出去了。第二个面试官是经理，也没有多聊，问了一些 HTTP 的问题，就 OK 了，两个面试加一起半个小时不到。</p><p>然后 HR 助理过来说之前也跟 HR 聊过了，让我先回去等通知，我就回去了。</p><p>第二天收到了 offer，工资比我要的低了一点，不过总体还算满意，就答应了。</p><h2>为什么跳槽</h2><p>首先我的老东家 OOCL 真是一家挺不错的公司，尤其在培养人方面非常舍得投入。而且各种分享，演讲都非常多。入职的时候跟 OOCL 签的培训协议，如果干不满两年，需要赔偿 X 美金（按月递减）的违约金。违约金还挺多的，不过个人觉得非常值，比在社会上报那些乱七八糟的培训班强多了。工作前三个月半封闭脱产培训，请的中科院的老师，讲课深入浅出，在那几个月内我也进步很大。最后离职的时候由于我只工作了一年半，赔偿了一部分钱。除了培训以外，OOCL 整个福利待遇在珠海来说也都算不错，每年两次调薪，竞争力还是比较大。</p><p>OOCL 这么好你为啥要走呢？</p><p>OOCL 是一个船运公司，有非常复杂的业务。在 OOCL 的时间大部分都在搞业务，而且做的东西很杂，感觉学了很多东西，又样样都不精通。去面试后端的时候，关于缓存，高并发之类的问题都没能答上来。而在互联网公司会觉得自己跟用户更近一些，业务方面也会很好理解。专职做前端或者后端会让自己在某个领域更精通一些，我还是希望成为某个领域的砖家，在金山这个理想实现起来会更快一些。</p><h2>金山怎么样啊？</h2><p>今天是入职第二天，说实话给不了太多的评价，只能从外部简单对比一下 OOCL 和金山。</p><h3>穿着</h3><p>OOCL 是香港的公司，感觉大家更 formal 一些，邮件、IM 基本都是英文，穿着也不会太随意。金山是典型的互联网公司，穿拖鞋短裤是家常便饭。</p><h3>食堂</h3><p>OOCL 没有食堂，不过培训的时候有中餐可以吃，质量参差不齐，好坏看运气。金山的食堂真心不错，荤素搭配，米面汤粉都有，而且三餐免费，赞。</p><h3>办公环境</h3><p>办公环境的话 OOCL 就略胜一筹了，安静整洁，空调全年恒温。金山要乱一些，平时很多人说话，甚至还有人戴着耳机听歌的时候跟着吹口哨<img src="/assets/img/我也是醉了.jpg" alt="醉了">。还有一个要吐槽金山的是，新到职，没有新电脑用，为什么大家都有 mac 用，我只能用 win？</p><h3>加班</h3><p>OOCL 是不加班的，即使有项目特别紧的时候加班，也会把加班的时间补给你，也就是可以在项目没那么紧的时候多休几天假，这点很人性化。金山据说加班挺严重的，目前还不知道如何。</p><h3>待遇</h3><p>其实这次跳槽，没有涨多少工资，感觉待遇差不太多。不知道这边工资上升空间大不大。不过金山住房公积金交 12%，这点不错。</p><h3>技术</h3><p>技术上其实 OOCL 算是一个比较敢尝新的公司，除了公司主要业务网站一直坚持 JavaEE 的技术栈以外，很多新的业务都是用比较新的技术做的。比如我去年就接触了 MEAN、Hadoop、Scala、Spark、HBase、Hive、Impala、机器学习等很多比较新潮的技术，虽然很多都是浅尝辄止。也是前面几个月维护一个 Node.JS 的项目让我对 JavaScript 生态产生了兴趣，最终转入前端行业的。金山这边似乎也是比较愿意接受吸纳新技术，就我在的项目组而言，已经开始完全用 ES6 开发产品，对 React 和 Vue 也采取乐观的态度。</p><h2>最后</h2><p>今年我的目标是丰富自己前端技术栈，提高自己独立开发的能力，弥补自己 CSS 方面的劣势。无论如何，希望今后能过得更好，技术要来越好，钱越来越多。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/assets/img/跳槽.png&quot; alt=&quot;跳槽&quot;&gt;&lt;h2&gt;面试经历&lt;/h2&gt;&lt;p&gt;一共去金山面了三次试，一次是后台开发，两次是前台开发。去年11月份的时候第一次去金山面试服务器开发的职位，很多问题都没有答上来，就惨淡离去了。后来又有一个前端开发的岗位，抱着试一试的态度就去了。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="跳槽" scheme="https://lz5z.com/tags/%E8%B7%B3%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS 学习——组件2</title>
    <link href="https://lz5z.com/ReactJS%E2%80%94%E7%BB%84%E4%BB%B62/"/>
    <id>https://lz5z.com/ReactJS—组件2/</id>
    <published>2017-02-13T19:35:03.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>组件列表</h2><p>使用循环的方式创建组件列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">      &#123;number&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;&#123;listItems&#125;&lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意上面代码中的 <code>key</code>，它是一个 string 类型的属性，在创建 lists 元素的时候，你需要添加这个属性，如果不添加会有 warning。</p><h2>Keys</h2><p>React 元素可以具有一个特殊的属性 key，这个属性不是给用户用的，而是给 React 自己用的。如果我们动态地创建 React 元素，而且 React 元素内包含数量或顺序不确定的子元素时，我们就需要提供 key 这个特殊的属性。</p><p>为什么需要给每一个元素一个标识呢？我们知道当组件的属性发生了变化，其 render 方法会被重新调用，组件会被重新渲染。比如元素里面 <code>[{name: 'Leo'}] =&gt; [{name: 'Jack'}]</code> 那么有可能是删除了 Leo，然后为 Jack 新建了一个，也有可能是更改了 name 属性，因此为数组中的元素传一个唯一的 key（比如用户的 ID），就很好地解决了这个问题。React 比较更新前后的元素 key 值，如果相同则更新，如果不同则销毁之前的，重新创建一个元素。</p><h3>Keys 的用法</h3><p>Keys 只能被定义在循环里面</p><p>以下用法都是错误的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = props.value;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Wrong! There is no need to specify the key here:</span></span><br><span class="line">    &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class="line">      &#123;value&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function NumberList(props) &#123;</span></span><br><span class="line"><span class="regexp">  const numbers = props.numbers;</span></span><br><span class="line"><span class="regexp">  const listItems = numbers.map((number) =&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Wrong! The key should have been specified here:</span></span><br><span class="line"><span class="regexp">    &lt;ListItem value=&#123;number&#125; /</span>&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const numbers = [1, 2, 3, 4, 5];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;NumberList numbers=&#123;numbers&#125; /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面是正确的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Correct! There is no need to specify the key here:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// Correct! Key should be specified inside the array.</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const numbers = [1, 2, 3, 4, 5];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;NumberList numbers=&#123;numbers&#125; /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;组件列表&lt;/h2&gt;&lt;p&gt;使用循环的方式创建组件列表&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; listItems = numbers.map(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;number&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;li&amp;gt;&amp;#123;number&amp;#125;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/li&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;ReactDOM.render(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;  &amp;lt;ul&amp;gt;&amp;#123;listItems&amp;#125;&amp;lt;/u&lt;/span&gt;l&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;root&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://lz5z.com/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://lz5z.com/tags/ES6/"/>
    
      <category term="React" scheme="https://lz5z.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Fetch API 使用</title>
    <link href="https://lz5z.com/FetchAPI/"/>
    <id>https://lz5z.com/FetchAPI/</id>
    <published>2017-02-12T16:25:06.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>在上一章学习 <a href="https://lz5z.com/ReactJS%E2%80%94%E7%BB%84%E4%BB%B6/">React 组件</a>的时候，想增加 React 对 Ajax 支持的内容，却发现网上的教程竟然用 jQuery 完成 Ajax 请求，个人觉得为了发送一个简单的请求引入 jQuery 库杀鸡焉用宰牛刀啊。其实 W3C 已经有了更好的替代品，那就是： <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">Fetch API</a>。</p><a id="more"></a><h2><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a></h2><p>Fetch API 的出现与 JavaScript 异步编程模型 Promise 息息相关，在 Fetch API 出现之前，JavaScript 通过 XMLHttpRequest(XHR) 来执行异步请求，XHR 将输入、输出和事件模型混杂在一个对象里，这种设计并不符合职责分离的原则。而且，基于事件的模型与 Promise 以及基于 Generator 的异步编程模型不太搭。</p><p>Fetch API 提供了对 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Headers" target="_blank" rel="noopener">Headers</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Request" target="_blank" rel="noopener">Request</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="noopener">Response</a> 三个对象的封装，以及一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch" target="_blank" rel="noopener">fetch()</a> 函数用来获取网络资源，并且在离线用户体验方面，由于 ServiceWorkers 的介入，Fetch API 也能提供强大的支持。</p><h3>兼容性</h3><p>fetch() 方法被定义在 window 对象中，你可以直接在控制台中输入 fetch() 查看浏览器是否支持，gitHub 上有基于低版本浏览器的<a href="https://github.com/github/fetch" target="_blank" rel="noopener">兼容实现</a>。</p><h3>简单示例</h3><p>fetch() 方法接受一个参数——资源的路径。无论请求成功与否，它都返回一个 promise 对象，resolve 对应请求的 Response 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = <span class="built_in">document</span>.querySelector(<span class="string">'.my-image'</span>);</span><br><span class="line">fetch(<span class="string">'https://lz5z.com/assets/img/avatar.png'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.ok) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(response);</span><br><span class="line">    <span class="keyword">return</span> response.blob();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">    myImage.src = objectURL;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>点击查看<a href="/assets/demo/fetch-demo/index.html">效果</a></p><p>在获取请求的 Response 对象后，通过该对象的 json() 方法可以将结果作为 JSON 对象返回，response.json() 同样会返回一个 Promise 对象，因此可以继续链接一个 then() 方法。相比传统的 XHR 的基于事件类型的编程方式，四不四简单很多哈。</p><h3>Request 对象</h3><p>Fetch API 引入了3个接口，它们分别是 Headers，Request 以及 Response 。他们直接对应了相应的 HTTP 概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证 cookies 不能被第三方获取。</p><p>通过 Request 构造器函数创建一个新的请求对象，这也是建议标准的一部分。 第一个参数是请求的 url，第二个参数是一个选项对象，用于配置请求。然后将 Request 对象传递给 fetch() 方法，用于替代默认的 url 字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不缓存响应结果， 方法为 GET</span></span><br><span class="line"><span class="keyword">let</span> req = <span class="keyword">new</span> Request(url, &#123;<span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">cache</span>: <span class="string">'reload'</span>&#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除此之外，还可以基于 Request 对象创建新对象，比如将一个 GET 请求创建成为一个 POST 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> postReq = <span class="keyword">new</span> Request(req, &#123;<span class="attr">method</span>: <span class="string">'POST'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(postReq.method); <span class="comment">//"POST"</span></span><br></pre></td></tr></table></figure><h3>Headers 对象</h3><p>每个 Request 对象都有一个 header 属性，在 Fetch API 中它对应了一个 Headers 对象。 我们可以使用 Headers 对象构建 Request 对象。而在 Response 对象中也有一个 header 属性，但是响应头是只读的。</p><p>Headers 接口是一个简单的多映射的名-值表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headers = <span class="keyword">new</span> Headers();</span><br><span class="line">headers.append(<span class="string">'Accept'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"><span class="keyword">let</span> request = <span class="keyword">new</span> Request(url, &#123;<span class="attr">headers</span>: headers&#125;);</span><br><span class="line">fetch(request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以传一个多维数组或者 json：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reqHeaders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>,</span><br><span class="line">  <span class="string">"Content-Length"</span>: content.length.toString(),</span><br><span class="line">  <span class="string">"X-Custom-Header"</span>: <span class="string">"ProcessThisImmediately"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//操作 Headers 中的内容</span></span><br><span class="line">reqHeaders.has(<span class="string">"Content-Type"</span>) <span class="comment">//true</span></span><br><span class="line">reqHeaders.get(<span class="string">"Content-Type"</span>) <span class="comment">//"text/plain"</span></span><br><span class="line">reqHeaders.set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">reqHeaders.delete(<span class="string">"X-Custom-Header"</span>);</span><br></pre></td></tr></table></figure><h3>Response 对象</h3><p>构建 Respondse 对象有什么用呢？通常 Response 的内容在服务端生成，但是 Fetch API 是浏览器里面的内容啊。</p><p>对了，就是为了离线应用，通过 Service Worker 浏览器能够获取请求头的内容，然后通过在浏览器中构建响应头来替换来自服务器的响应头以达到构建离线应用的目的（这方面内容以后再说）。</p><p>构建方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">new</span> Response(</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">photos</span>: &#123;<span class="attr">photo</span>: []&#125;&#125;),</span><br><span class="line">    &#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">headers</span>: headers&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3>steam 支持</h3><p>Request 和 Response 对象中的 body 只能被读取一次，它们有一个属性叫 bodyUsed，读取一次之后设置为 true，就不能再读取了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="keyword">new</span> Response(<span class="string">"one time use"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">//false</span></span><br><span class="line">res.text().then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">//"one time use"</span></span><br><span class="line">  <span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样设计的目的是为了之后兼容基于流的 API，让应用只能消费一次 data，这样就允许了 JavaScript 处理大文件例如视频，并且可以支持实时压缩和编辑。</p><h3>clone 支持</h3><p>如何让 body 能经得起多次读取呢？Fetch API 提供了一个 clone() 方法。调用这个方法可以得到一个克隆对象。不过要记得，clone() 必须要在读取之前调用，也就是先 clone() 再读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = <span class="keyword">new</span> Response(<span class="string">"many times use"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> clone = sheep.clone();</span><br><span class="line"><span class="built_in">console</span>.log(res.bodyUsed); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2>总结</h2><p>虽然 Fetch API 提供了更加简洁的接口，Promise 形式的编程体验，但是它也不是完美的，最大的问题就是不能中断一个请求，并且无法检测一个请求的进度，这些在 XHR 中早就有很好的解决方案。也行 Fetch API 需要更多的时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;在上一章学习 &lt;a href=&quot;https://lz5z.com/ReactJS%E2%80%94%E7%BB%84%E4%BB%B6/&quot;&gt;React 组件&lt;/a&gt;的时候，想增加 React 对 Ajax 支持的内容，却发现网上的教程竟然用 jQuery 完成 Ajax 请求，个人觉得为了发送一个简单的请求引入 jQuery 库杀鸡焉用宰牛刀啊。其实 W3C 已经有了更好的替代品，那就是： &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fetch API&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="W3C" scheme="https://lz5z.com/tags/W3C/"/>
    
      <category term="Fetch API" scheme="https://lz5z.com/tags/Fetch-API/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS 学习——组件</title>
    <link href="https://lz5z.com/ReactJS%E2%80%94%E7%BB%84%E4%BB%B6/"/>
    <id>https://lz5z.com/ReactJS—组件/</id>
    <published>2017-02-08T17:02:15.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>ReactJS 组件</h1><p>React 提倡<a href="https://facebook.github.io/react/docs/react-component.html" target="_blank" rel="noopener">组件化</a>的开发方式，每个组件只关心自己部分的逻辑，使得应用更加容易维护和复用。</p><p>React 还有一个很大的优势是基于组件的状态更新视图，对于测试非常友好。</p><a id="more"></a><h2>数据模型</h2><h3>state</h3><p>React 每一个组件的实质是状态机（State Machines），在 React 的每一个组件里，通过更新 this.state，再调用 render() 方法进行渲染，React 会自动把最新的状态渲染到网页上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">enable</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">enable</span>: !<span class="keyword">this</span>.state.enable&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> disabled=&#123;<span class="keyword">this</span>.state.enable&#125; /&gt; </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;click <span class="keyword">this</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过在组件的 constructor 中给 this.state 赋值，来设置 state 的初始值，每当 state 的值发生变化， React 重新渲染页面。</p><p>注意：</p><p>(1) <strong>请不要直接编辑 this.state</strong>，因为这样会导致页面不重新渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span>;</span><br></pre></td></tr></table></figure><p>使用 this.setState() 方法来改变它的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure><p>(2) <strong>this.state</strong> 的更新可能是异步的(this.props 也是如此)</p><p>React 可能会批量地调用 this.setState() 方法，this.state 和 this.props 也可能会异步地更新，所以你不能依赖它们目前的值去计算它们下一个状态。</p><p>比如下面更新计数器的方法会失败：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二种形式的 setState() 方法接收的参数为一个函数而不是一个对象。函数的第一个参数为 previous state，第二个参数为当前的 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>实现一个计数器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">counter</span>: <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">      counter: prevState.counter + <span class="built_in">parseInt</span>(props.increment)</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.state.counter&#125;&lt;<span class="regexp">/h1&gt; </span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;click this&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;HelloMessage increment="1" /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3>props</h3><p>React 的数据流是单向的，是自上向下的层级传递的，props 可以对固定的数据进行传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>state vs props</h3><p>state 和 props 看起来很相似，其实是完全不同的东西。</p><p>一般来说，this.props 表示那些一旦定义，就不再改变的特性，比如购物车里的商品名称、价格，而 this.state 是会随着用户互动而产生变化的特性，比如用户购买商品的个数。</p><h2>获取 DOM</h2><p>在 React 中，我们可以通过 this.refs 方便地获取 DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.refs.myInput.value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=<span class="string">"myInput"</span> /&gt; </span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;click <span class="keyword">this</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2>生命周期</h2><p>React 组件的生命周期分为三类：</p><p>(1) 挂载(Mounting): 已插入真实 DOM</p><p>componentWillMount()： 在初次渲染之前执行一次，最早的执行点<br>componentDidMount()： 在初次渲染之后执行</p><p>getInitialState() –&gt; componentWillMount() –&gt; render() –&gt; componentDidMount()</p><p>(2) 更新(Updating): 正在被重新渲染</p><p>componentWillReceiveProps()： 在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。<br>shouldComponentUpdate()： 在接收到新的 props 或者 state，将要渲染之前调用。<br>componentWillUpdate()： 在接收到新的 props 或者 state 之前立刻调用。<br>componentDidUpdate()： 在组件的更新已经同步到 DOM 中之后立刻被调用。</p><p>componentWillReceiveProps() –&gt; shouldComponentUpdate() –&gt; componentWillUpdate –&gt; render() –&gt; componentDidUpdate()</p><p>(3) 移除(Unmounting): 已移出真实 DOM</p><p>componentWillUnmount()： 在组件从 DOM 中移除的时候立刻被调用。</p><p>下面举 React 官网的一个输出时间的例子，在 Clock 渲染之前设置一个定时器，每隔一秒更新一下 this.state.date 的值，并在组件移除的时候清除定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//组件初次渲染之后执行</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//组件移除的时候执行</span></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//渲染</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2>事件</h2><p>React 内建的跨浏览器的<a href="https://facebook.github.io/react/docs/events.html" target="_blank" rel="noopener">事件系统</a>，我们可以在组件里添加属性来绑定事件和相应的<a href="https://facebook.github.io/react/docs/handling-events.html" target="_blank" rel="noopener">处理函数</a>。这种事件绑定方法极大的方便了事件操作，不用再像以前先定位到 DOM 节点，再通过 addEventListener 绑定事件，还要用 removeEventListener 解绑。当组件注销时，React 会自动帮我们解绑事件。</p><p>React 处理事件与 DOM 处理事件非常相似，有以下两点不同：</p><ul><li>React 事件用驼峰命名法，而不是全小写</li><li>通过 JSX 语法传递函数作为事件处理器，而不是字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is:'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>另外一个不同的是 React 不支持向事件处理函数 <code>return false</code>，一般 HTML 事件函数中，可以通过 <code>return false</code> 来阻止默认行为，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span> onclick=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span><br><span class="line">  Click me</span><br><span class="line">&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>Vue 阻止浏览器默认行为的方式最简单，用一个装饰符就可以搞定 <code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code>。</p><p>而在 React 中，必须调用 preventDefault 方法才能完成以上功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里的 <code>e</code> 是 React 封装过后的，因此不用担心游览器差异带来的影响。☺</p><h2>条件渲染</h2><p>假设 Greeting 组件根据状态选择渲染 UserGreeting 和 GuestGreeting 中的一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class LoginControl extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  constructor(props) &#123;</span></span><br><span class="line"><span class="xml">    super(props);</span></span><br><span class="line"><span class="xml">    this.handleLogoutClick = this.handleLogoutClick.bind(this);</span></span><br><span class="line"><span class="xml">    this.state = &#123;isLoggedIn: false&#125;;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  handleLogoutClick() &#123;</span></span><br><span class="line"><span class="xml">    this.setState(&#123;isLoggedIn: !this.state.isLoggedIn&#125;);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const isLoggedIn = this.state.isLoggedIn;</span></span><br><span class="line"><span class="xml">    let button = null;</span></span><br><span class="line"><span class="xml">    if (isLoggedIn) &#123;</span></span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>行内条件判断</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">'React'</span>, <span class="string">'Re: React'</span>, <span class="string">'Re:Re: React'</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其它类型的逻辑判断，像三元运算符，<code>if else</code> React 也均支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;<span class="regexp">/b&gt; logged in.</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3>阻止组件渲染</h3><p>通过在组件内部 <code>return null</code> 可以达到阻止组件渲染的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"warning"</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2>最后</h2><p>第一章 <a href="https://lz5z.com/ReactJS%E2%80%94%E5%85%A5%E9%97%A8/">React 入门</a> 和本章 React 组件都是比较基础的内容，后面会学习全新的程序设计模式 Flux 和 Redux 来管理应用的状态，很多函数式编程的思想正好努力学习一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;ReactJS 组件&lt;/h1&gt;&lt;p&gt;React 提倡&lt;a href=&quot;https://facebook.github.io/react/docs/react-component.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;组件化&lt;/a&gt;的开发方式，每个组件只关心自己部分的逻辑，使得应用更加容易维护和复用。&lt;/p&gt;&lt;p&gt;React 还有一个很大的优势是基于组件的状态更新视图，对于测试非常友好。&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://lz5z.com/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://lz5z.com/tags/ES6/"/>
    
      <category term="React" scheme="https://lz5z.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS 学习——入门</title>
    <link href="https://lz5z.com/ReactJS%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <id>https://lz5z.com/ReactJS—入门/</id>
    <published>2017-02-05T14:45:55.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>ReactJS 简介</h1><p><a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 首次被提出是在2014年的 F8 大会上，当期的主题为 “Rethinking Web App Development at Facebook”，这也是 React 名字的由来。</p><p>React 以组件化的开发方式，专注于 MVC 架构中的 View，即视图， 这使得React很容易和开发者已有的开发栈进行融合。React 推荐将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体 UI 的构建。</p><a id="more"></a><h1>ReactJS 原理</h1><p>Web 开发的最终目的是把数据反映到 UI 上，这时就需要对 DOM 进行操作，复杂或者频繁的 DOM 操作通常是性能瓶颈产生的原因。React 为此引入了虚拟 DOM（Virtual DOM） 的机制：开发者操作虚拟 DOM，React 在必要的时候将它们渲染到真正的 DOM 上。</p><h2>Virtual DOM</h2><p>基于 React 进行开发时所有的 DOM 构造都是通过虚拟 DOM 进行，每当数据变化时，React 都会重新构建整个 DOM 树，然后 React 将当前整个 DOM 树和上一次的 DOM 树进行对比，得到 DOM 结构的区别，然后仅仅将需要变化的部分更新到实际的浏览器。</p><p>同时 React 能够批处理虚拟 DOM 的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从 A 变成 B，然后又从 B 变成 A，React 会认为 UI 不发生任何变化。尽管每一次都需要构造完整的虚拟 DOM 树，但是因为虚拟 DOM 是内存数据，性能是极高的，而对实际 DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。</p><h2>Hello World</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@latest/dist/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@latest/dist/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/babel-standalone@6.15.0/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      ReactDOM.render(</span></span><br><span class="line"><span class="javascript">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span></span><br><span class="line"><span class="undefined">      );</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的 Hello World 的例子中，引入了三个库文件，react.js，react-dom.js 和 babel.js，它们必须首先加载。在之前的版本中，需要加载 “JSXTransformer.js”，后来 React 官方不再维护这个库，由 babel 对 JSX 语法进行编译。<br>ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。</p><h2>create-react-app</h2><p>一般我们启动一个 React 项目会使用 React 脚手架工具 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">create-react-app</a>,它会帮助你创建一个基于 webpack、Babel 和 ESLint 的单页面项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn global add create-react-app</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> create-react-app react-demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> react-demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn start</span></span><br></pre></td></tr></table></figure><p>项目启动后会有一个 “Welcome to React” 的页面自动打开。</p><p>打开 package.json 文件，发现并没有找到 webpack、Babel 等 package 相关的依赖，所有的工作都是 “react-scripts” 帮助我们做的，这样极大地降低了初学者入门学习 React 的成本。</p><h2><a href="https://facebook.github.io/react/docs/introducing-jsx.html" target="_blank" rel="noopener">JSX</a></h2><p>HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">'Leo'</span>, <span class="string">'Jack'</span>, <span class="string">'John'</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    names.map(<span class="function">(<span class="params">name</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。</p><p>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;, </span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;world&lt;/</span>h1&gt;</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &#123;arr&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>ReactDOM.render 方法也可以写在函数中，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t0 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(),</span><br><span class="line">  delta = t - t0;</span><br><span class="line">  <span class="comment">//在虚拟DOM上创建元素</span></span><br><span class="line">  <span class="keyword">let</span> el = React.createElement(<span class="string">"p"</span>,<span class="literal">null</span>,delta);</span><br><span class="line">  <span class="comment">//渲染到真实DOM</span></span><br><span class="line">  ReactDOM.render(el,<span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;,<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h2>React 组件</h2><p>定义 React 组件有三种方法，第一种是 JavaScript 函数，第二种是用 ES6 classes 的方式，一个是用 React.createClass(已经过时)</p><h3>JavaScript 函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloMessage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage name=<span class="string">"Leo"</span>/&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意这里调用属性的时候没有 this。</p><h3>React.Component</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name=<span class="string">"Leo"</span>/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3>React.createClass</h3><p>React.createClass(meta) 方法用于生成组件类，参数 meta 是一个实现预定义接口的 JavaScript 对象，用来对 React 组件原型进行扩展。<br>在 meta 中，至少需要实现一个 render() 方法，而这个方法， 必须而且只能返回一个有效的 React 元素。这意味着，如果你的组件是由多个元素构成的，那么你必须在外边包一个顶层元素，然后返回这个顶层元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;this.props.name&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage name=<span class="string">"Leo"</span>/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>组件名必须以大写字母开头</li><li>组件类只能包含一个顶层标签</li><li>获取属性的值用的是 this.props.属性名</li><li>为元素添加 css 的 class 时，要用 className，for 属性需要写成 htmlFor， 因为 class 和 for 是 ES6 关键字</li></ol><h2>内联 css</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloMessage = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>"<span class="attr">red</span>",<span class="attr">fontSize:</span> "<span class="attr">44px</span>"&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          Hello &#123;this.props.name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>内联 css 的写法与用 JavaScript 直接操作样式相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).style.paddingLeft=<span class="string">'104px'</span>;</span><br></pre></td></tr></table></figure><h3>组件组合</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Name name=&#123;<span class="keyword">this</span>.props.name&#125; /&gt;</span><br><span class="line">        &lt;Link site=&#123;<span class="keyword">this</span>.props.site&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/Name组件</span></span><br><span class="line"><span class="regexp">class Name extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;&#123;this.props.name&#125;&lt;/</span>h1&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//L****ink组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a href=&#123;<span class="keyword">this</span>.props.site&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.site&#125;</span><br><span class="line">      &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;WebSite name="Leo" site="https:/</span><span class="regexp">/lz5z.com" /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1>最后</h1><p>ReactJS 入门暂时就到这里，后面会有更加详细的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;ReactJS 简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React&lt;/a&gt; 首次被提出是在2014年的 F8 大会上，当期的主题为 “Rethinking Web App Development at Facebook”，这也是 React 名字的由来。&lt;/p&gt;&lt;p&gt;React 以组件化的开发方式，专注于 MVC 架构中的 View，即视图， 这使得React很容易和开发者已有的开发栈进行融合。React 推荐将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体 UI 的构建。&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://lz5z.com/categories/React/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://lz5z.com/tags/ES6/"/>
    
      <category term="React" scheme="https://lz5z.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Yarn 管理 JavaScript 模块</title>
    <link href="https://lz5z.com/Yarn%E7%AE%A1%E7%90%86JavaScript%E6%A8%A1%E5%9D%97/"/>
    <id>https://lz5z.com/Yarn管理JavaScript模块/</id>
    <published>2017-02-01T19:42:03.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> 简介</h1><p>Yarn 是 Facebook 开发的一款新的 JavaScript 包管理工具， 作为 NPM 的替代产品，主要是为了解决下面两个问题：</p><ul><li>安装的时候无法保证速度/一致性</li><li>安全问题，因为 NPM 安装时允许运行代码</li></ul><a id="more"></a><h1>Yarn vs NPM</h1><h2>速度快</h2><p>相比于 NPM，Yarn 的速度更快，Yarn 会把使用过的模块在本地缓存一份，如果下次还要用到相同版本的模块，那么将会直接使用本地的而不是访问网络重新获取一份。而 NPM 使用的时候，如果不全局安装那么每个项目都要重新下载一次包，浪费时间和资源。</p><h2>安全性</h2><p>Yarn 在安装模块之前会验证文件完整性。</p><h2>并行安装</h2><p>每当 NPM 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 NPM 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。</p><h2>输出清晰</h2><p>NPM 安装包的时候输出惨不忍睹，而 Yarn 的输出就清晰多了。</p><img src="/assets/img/yarn.png" alt="yarn"><h1>使用</h1><h2>常用命令对照表</h2><table><thead><tr><th style="text-align:left">作用</th><th style="text-align:left">NPM 命令</th><th style="text-align:left">Yarn 命令</th></tr></thead><tbody><tr><td style="text-align:left">初始化</td><td style="text-align:left">npm init</td><td style="text-align:left">yarn init</td></tr><tr><td style="text-align:left">安装 package.json 中的包</td><td style="text-align:left">npm install</td><td style="text-align:left">yarn</td></tr><tr><td style="text-align:left">安装某个包</td><td style="text-align:left">npm install xxx --save</td><td style="text-align:left">yarn add xxx</td></tr><tr><td style="text-align:left">删除某个包</td><td style="text-align:left">npm uninstall xxx --save</td><td style="text-align:left">yarn remove xxx</td></tr><tr><td style="text-align:left">开发模式下安装某个包</td><td style="text-align:left">npm install xxx --save-dev</td><td style="text-align:left">yarn add xxx -dev</td></tr><tr><td style="text-align:left">更新</td><td style="text-align:left">npm update --save</td><td style="text-align:left">yarn upgrade</td></tr><tr><td style="text-align:left">全局安装</td><td style="text-align:left">npm install xxx –global</td><td style="text-align:left">yarn global add xxx</td></tr><tr><td style="text-align:left">清除缓存</td><td style="text-align:left">npm cache clean</td><td style="text-align:left">yarn cache clean</td></tr><tr><td style="text-align:left">查看模块信息</td><td style="text-align:left">npm info xxx</td><td style="text-align:left">yarn info xxx</td></tr><tr><td style="text-align:left">运行script</td><td style="text-align:left">npm run</td><td style="text-align:left">yarn run</td></tr><tr><td style="text-align:left">测试</td><td style="text-align:left">npm test</td><td style="text-align:left">yarn test</td></tr></tbody></table><h2><a href="https://yarnpkg.com/docs/configuration/#toc-use-yarn-lock-to-pin-your-dependencies" target="_blank" rel="noopener">yarn.lock</a> 文件</h2><p>在使用 NPM 管理 JavaScript 模块的时候，可以用比较宽松的方式定义某个模块的版本信息，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*: 任意版本</span><br><span class="line">~<span class="number">1.1</span><span class="number">.0</span>: &gt;=<span class="number">1.1</span><span class="number">.0</span> &amp;&amp; <span class="xml"><span class="tag">&lt; <span class="attr">1.2.0</span></span></span></span><br><span class="line"><span class="xml">^1.1.0: &gt;=1.1.0 &amp;&amp; <span class="tag">&lt; <span class="attr">2.0.0</span></span></span></span><br><span class="line"><span class="xml">&gt;= 1.0.0: &gt;= 1.0.0</span></span><br><span class="line"><span class="xml">3.x: 任意 3 版本</span></span><br></pre></td></tr></table></figure><p>理想状态下使用<a href="http://deadhorse.me/nodejs/2014/04/27/semver-in-nodejs.html" target="_blank" rel="noopener">语义化</a>版本发布补丁不会包含大的变化，但不幸的很多时候并非如此。NPM 的这种策略可能导致两台拥有相同 package.json 文件的电脑安装了不同版本的包，这可能导致一些错误。很多模块的安装错误和环境问题都是由于这个原因导致。</p><p>为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新） yarn.lock 文件，这样你就可以保证其它电脑也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。</p><p>在 npm 中同样可以使用 <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="noopener">npm shrinkwrap</a> 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取 yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。</p><h2><a href="https://yarnpkg.com/en/docs/cli/install" target="_blank" rel="noopener">yarn install</a></h2><p>npm install 命令会根据 package.json 安装依赖以及允许你添加新的模块； yarn install 仅会按照 yarn.lock 或 package.json 里面的依赖顺序来安装模块。</p><h2><a href="https://yarnpkg.com/en/docs/cli/add" target="_blank" rel="noopener">yarn add [–dev]</a></h2><p>与 npm install 类似，yarn add 允许你添加与安装模块，添加依赖的同时也会将依赖写入 package.json，类似 npm 的 --save 参数；Yarn 的 --dev 参数则是添加开发依赖，类似 npm 的 --save-dev 参数。</p><h2><a href="https://yarnpkg.com/en/docs/cli/global" target="_blank" rel="noopener">yarn global</a></h2><p>不像 npm 添加 -g 或 --global 可以进行全局安装，Yarn 使用的是 global 前缀（yarn global add xxx）。global 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove。</p><h2><a href="https://yarnpkg.com/en/docs/cli/why" target="_blank" rel="noopener">yarn why</a></h2><p>该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你知道为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你找出。<br><img src="/assets/img/yarn_why.png" alt="yarn_why"></p><h1>总结</h1><p>相比 NPM，Yarn 可以方便生成锁文件，安装模块时非常迅速并且会将依赖自动添加进 package.json，模块可以并行安装。不过个人认为，Yarn 的优势不是绝对的，毕竟 NPM 久经考验，或许不久的将来，NPM 也会拥有这些特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;&lt;a href=&quot;https://yarnpkg.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yarn&lt;/a&gt; 简介&lt;/h1&gt;&lt;p&gt;Yarn 是 Facebook 开发的一款新的 JavaScript 包管理工具， 作为 NPM 的替代产品，主要是为了解决下面两个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;安装的时候无法保证速度/一致性&lt;/li&gt;&lt;li&gt;安全问题，因为 NPM 安装时允许运行代码&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Yarn" scheme="https://lz5z.com/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Gulp 快速入门</title>
    <link href="https://lz5z.com/Gulp%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://lz5z.com/Gulp快速入门/</id>
    <published>2017-01-18T16:09:35.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<img src="/assets/img/自动化.jpg" alt="自动化"> [图片摘自「程序员的那些事」]<h2>什么是 gulp</h2><p>简单的讲，gulp 是一个构建工具，一个基于流的构建工具，一个 nodejs 写的构建工具，使用 gulp 的目的就是为了自动化构建，提高程序员工作效率😂。</p><a id="more"></a><h2>入门指南</h2><ol><li>全局安装 gulp：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --global gulp</span></span><br></pre></td></tr></table></figure><ol start="2"><li>作为项目的开发依赖（devDependencies）安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev gulp</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在项目根目录下创建一个名为 gulpfile.js 的文件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="comment">// 默认task</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>运行 gulp：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gulp</span></span><br></pre></td></tr></table></figure><p>默认的名为 default 的任务（task）将会被运行。</p><p>想要单独执行特定的任务（task），请输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gulp &lt;task&gt; &lt;othertask&gt;。</span></span><br></pre></td></tr></table></figure><h2>tasks 依赖</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="comment">// task1</span></span><br><span class="line">gulp.task(<span class="string">'task1'</span>, () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'task1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task2</span></span><br><span class="line">gulp.task(<span class="string">'task2'</span>, () =&gt; &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'task2'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在执行 default 之前先执行 task1 和 task2</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'task1'</span>, <span class="string">'task2'</span>], () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出顺序为：</p><blockquote><p>task1<br>Hello World<br>task2</p></blockquote><h2>流式处理</h2><p>(1) 在项目根目录下创建 src 文件目录，里面创建 index.js<br>(2) 在项目根目录下创建 dist 文件目录<br>(3) 安装 gulp-uglify</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install gulp-uglify --save-dev</span></span><br></pre></td></tr></table></figure><p>(4) 使用 gulp 压缩 index.js 并将结果输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="comment">// 压缩js</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, () =&gt; &#123;</span><br><span class="line">gulp.src(<span class="string">'src/*.js'</span>)</span><br><span class="line">.pipe(uglify())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'dist'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(5) 运行 “gulp” 命令后发现在 dist 目录下生产了压缩后的 index.js</p><p>(6) 解释</p><p>gulp.src 是输入； gulp.dest 是输出<br>pipe 是管道的意思，也是 stream 里核心概念，pipe 将上一个的输出作为下一个的输入。src 里所有 js，经过处理1，处理2，变成输出结果，中间的处理 pipe 可以1步，也可以是n步。第一步处理的结果是第二步的输入，以此类推，就像生产线一样，每一步都是一个 task 是不是很好理解呢？</p><p>每个独立操作单元都是一个 task，使用 pipe 来组装 tasks，于是 gulp 就变成了基于 task 的组装工具。</p><h2>gulp.src()</h2><p>在上面的例子中，gulp.src() 函数用字符串匹配一个文件或者文件的编号（被称为“glob”）,然后创建一个对象流来代表这些文件，接着传递给 uglify() 函数，它接受文件对象之后返回有新压缩源文件的文件对象，最后那些输出的文件被输入 gulp.dest()函数，并保存下来。</p><p>gulp.src() 可以接收以下类型的参数：</p><blockquote><p>js/app.js 精确匹配文件<br>js/<em>.js 仅匹配 js 目录下的所有后缀为 .js 的文件<br>js/</em>/.js 匹配 js 目录及其子目录下所有后缀为 .js 的文件<br>!js/app.js 从匹配结果中排除 js/app.js，这种方法在你想要匹配除了特殊文件之外的所有文件时非常好用<br>*.+(js|css) 匹配根目录下所有后缀为 .js 或者 .css 的文件</p></blockquote><p>假如 js 目录下包含了压缩和未压缩的 JavaScript 文件，现在我们想要创建一个任务来压缩还没有被压缩的文件，我们需要先匹配目录下所有的 JavaScript 文件，然后排除后缀为 .min.js 的文件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src([<span class="string">'js/**/*.js'</span>, <span class="string">'!js/**/*.min.js'</span>])</span><br></pre></td></tr></table></figure><h2>babel</h2><p>babel 用于转化 JavaScript 代码，比如将 ES6 的语法转化成 ES5，或者将 JSX 语法转化为 JavaScript 语法。</p><p>假如上文中提到的 index.js 里面的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">import</span> express, &#123; Router &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> bodyParser <span class="keyword">from</span> <span class="string">'body-parser'</span>;</span><br><span class="line"><span class="comment">// 定义app和router</span></span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> router = Router();</span><br><span class="line"><span class="comment">//中间件</span></span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"><span class="comment">//路由</span></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="string">'/'</span>, router);</span><br><span class="line"><span class="comment">//启动app</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server listening at port 3000...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 babel 转化为 ES5 语法：</p><p>(1) 安装 babel-core babel-preset-es2015</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-core babel-preset-es2015</span></span><br></pre></td></tr></table></figure><p>(2) 创建 <strong>.babelrc</strong> 文件， 配置如下</p><blockquote><p>{<br>“presets”: [“es2015”]<br>}</p></blockquote><p>(3) 手动使用 babel 转译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> babel src -d lib</span></span><br></pre></td></tr></table></figure><p>(4) 安装 gulp-babel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  npm install --save-dev gulp-babel</span></span><br></pre></td></tr></table></figure><p>(5) 编写 gulpfile</p><p>在根目录新建一个 gulpfile.babel.js 文件。<br>gulp 原生并不支持 ES6 语法，但是我们可以告诉 gulp 使用 babel 将 gulpfile 转换为 ES5，方法就是将 gulpfile 命名为 <strong>gulpfile.babel.js</strong>。</p><p>(6) 使用 ES6 编写 <strong>gulpfile.babel.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">'gulp'</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">'gulp-babel'</span>;</span><br><span class="line"><span class="comment">// 语法转化+压缩</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, () =&gt; &#123;</span><br><span class="line">gulp.src(<span class="string">'src/*.js'</span>)</span><br><span class="line">.pipe(babel())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'lib'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打开 lib 目录下的 index.js 文件，就可以查看 babel 编译后的 ES5 语法的文件了。</p><h2>gulp-watch</h2><p>开始工作以后，每次改动 index.js 都要手动 gulp 一下实在太麻烦了，使用 gulp-watch 可以监听文件变化，当文件被修改之后，自动将文件转换。</p><p>(1) 安装 gulp-watch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install gulp-watch --save-dev</span></span><br></pre></td></tr></table></figure><p>(2) 新增 task</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'watch'</span>, () =&gt; &#123;</span><br><span class="line">gulp.src(<span class="string">'src/*.js'</span>)</span><br><span class="line">.pipe(watch(<span class="string">'src/*.js'</span>), &#123;</span><br><span class="line">verbose: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.pipe(babel())</span><br><span class="line">.pipe(gulp.dest(<span class="string">'lib'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(3) 启动 watch task</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gulp watch</span></span><br></pre></td></tr></table></figure><p>修改 index.js 后 lib/index.js 也会随之改变。(≧∀≦)ゞ</p><h2>查看全部 tasks</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gulp -T</span></span><br><span class="line">[16:06:54] Requiring external module babel-register</span><br><span class="line">[16:06:54] ├── default</span><br><span class="line">[16:06:54] └── watch</span><br></pre></td></tr></table></figure><h2>gulp 顺序执行</h2><p>默认的，task 将以最大的并发数执行，也就是说，gulp 会一次性运行所有的 task 并且不做任何等待。如果你想要创建一个序列化的 task 队列，并以特定的顺序执行，需要做两件事：</p><ol><li>给出一个提示，来告知 task 什么时候执行完毕，</li><li>并且再给出一个提示，来告知一个 task 依赖另一个 task 的完成。</li></ol><p>假如我想要 task1 执行完成后再执行 task2， 可以用以下三种方式：</p><h3>直接返回一个流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'task1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.watch(<span class="string">'src/*.js'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//只要加一个return就好了</span></span><br></pre></td></tr></table></figure><h3>返回一个promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'task1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  <span class="comment">// do async stuff</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">  &#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3>使用回调callback</h3><p>task 的执行函数其实都有个回调，我们只需要在异步队列完成的时候调用它就好了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'task1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do async stuff</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;, <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以只要依赖的任务是上面三种情况之一，就能保证当前任务在依赖任务执行完成后再执行。这边需要注意的是依赖的任务相互之间还是并行的。需要他们按顺序的话。记得给每个依赖的任务也配置好依赖关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'one'</span>, () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// two 依赖 one</span></span><br><span class="line">gulp.task(<span class="string">'two'</span>, [<span class="string">'one'</span>], () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// default 依赖 one，two</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'one'</span>, <span class="string">'two'</span>], () =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'default'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/assets/img/自动化.jpg&quot; alt=&quot;自动化&quot;&gt; [图片摘自「程序员的那些事」]&lt;h2&gt;什么是 gulp&lt;/h2&gt;&lt;p&gt;简单的讲，gulp 是一个构建工具，一个基于流的构建工具，一个 nodejs 写的构建工具，使用 gulp 的目的就是为了自动化构建，提高程序员工作效率😂。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Gulp" scheme="https://lz5z.com/tags/Gulp/"/>
    
      <category term="Babel" scheme="https://lz5z.com/tags/Babel/"/>
    
      <category term="streaming" scheme="https://lz5z.com/tags/streaming/"/>
    
  </entry>
  
  <entry>
    <title>机器学习常用算法——随机森林</title>
    <link href="https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%80%94%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>https://lz5z.com/机器学习常用算法—随机森林/</id>
    <published>2017-01-10T21:27:24.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>随机森林</h1><p>随机森林（Random Forest，简称RF），通过集成学习的思想将多棵决策树集成的一种算法，它的基本单元是<a href="https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91/">决策树</a>。从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出。</p><img src="/assets/img/randforest.png" alt="随机森林"><a id="more"></a><h2>随机森林构建</h2><h3>随机采样</h3><p>首先是两个随机采样的过程，random forest 对输入的数据要进行行、列的采样。</p><p>对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为 N 个，那么采样的样本也为 N 个，这选择好了的 N 个样本用来训练一个决策树，作为决策树根节点处的样本，同时使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现 over-fitting。</p><p>对于列采样，从 M 个 feature 中，选择 m 个 (m &lt;&lt; M)，即：当每个样本有M个属性时，在决策树的每个节点需要分裂时，随机从这 M 个属性中选取出 m 个属性，满足条件 m &lt;&lt; M。</p><h3>完全分裂</h3><p>对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个分类。分裂的办法是：采用上面说的列采样的过程从这m个属性中采用某种策略（比如说信息增益）来选择1个属性作为该节点的分裂属性。</p><p>决策树形成过程中每个节点都要按完全分裂的方式来分裂，一直到不能够再分裂为止（如果下一次该节点选出来的那一个属性是刚刚其父节点分裂时用过的属性，则该节点已经达到了叶子节点，无须继续分裂了）。</p><h2>随机森林的优点</h2><ol><li>比较适合做多分类问题，训练和预测速度快，在数据集上表现良好；</li><li>对训练数据的容错能力强，是一种有效地估计缺失数据的一种方法，当数据集中有大比例的数据缺失时仍然可以保持精度不变和能够有效地处理大的数据集；</li><li>能够处理很高维度的数据，并且不用做特征选择，即：可以处理没有删减的成千上万的变量；</li><li>能够在分类的过程中可以生成一个泛化误差的内部无偏估计；</li><li>能够在训练过程中检测到特征之间的相互影响以及特征的重要性程度；</li><li>不会出现过度拟合；</li><li>实现简单并且容易实现并行化。</li></ol><h1>例子</h1><p>假设有一组相亲网站提供的数据，抽取特征后发现是否相亲有四个因素组成： 年龄，是否有房，收入，是否公务员</p><blockquote><p>age, house, income, governor, go_date<br>30, 1, 80, 1, 1<br>28, 0, 30, 0, 0<br>29, 0, 80, 1, 1<br>32, 1, 40, 1, 1<br>32, 0, 100, 1, 1<br>40, 1, 30, 1, 0<br>28, 1, 40, 1, 1<br>57, 0, 80, 1, 0<br>45, 0, 78, 0, 0<br>34, 0, 70, 1, 0<br>…</p></blockquote><p>那么假如有一个新的会员注册后，填写了信息如下，</p><blockquote><p>年龄： 33<br>是否有房： 无<br>收入： 80<br>是否公务员： 是</p></blockquote><p>那么请问这位会员是否能得到相亲的机会？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataset = genfromtxt(<span class="string">'data.csv'</span>, delimiter=<span class="string">","</span>)</span><br><span class="line">x = dataset[<span class="number">1</span>:, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">y = dataset[<span class="number">1</span>:, <span class="number">4</span>]</span><br><span class="line">clf = RandomForestClassifier(n_jobs=<span class="number">2</span>, oob_score=<span class="keyword">True</span>)</span><br><span class="line">clf = clf.fit(x, y)</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">print(clf.predict_proba([[<span class="number">33</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">1</span>]]))</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Leo555/scikit-learn_demo/tree/master/06Random_Forest" target="_blank" rel="noopener">代码地址</a></p><h1>参考文献</h1><ul><li><a href="http://www.cnblogs.com/maybe2030/p/4585705.html" target="_blank" rel="noopener">[Machine Learning &amp; Algorithm] 随机森林（Random Forest）</a></li><li><a href="http://blog.csdn.net/u011301133/article/details/52562874" target="_blank" rel="noopener">sklearn中随机森林的参数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;随机森林&lt;/h1&gt;&lt;p&gt;随机森林（Random Forest，简称RF），通过集成学习的思想将多棵决策树集成的一种算法，它的基本单元是&lt;a href=&quot;https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91/&quot;&gt;决策树&lt;/a&gt;。从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出。&lt;/p&gt;&lt;img src=&quot;/assets/img/randforest.png&quot; alt=&quot;随机森林&quot;&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://lz5z.com/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://lz5z.com/tags/Algorithm/"/>
    
      <category term="Machine Learning" scheme="https://lz5z.com/tags/Machine-Learning/"/>
    
      <category term="scikit-learn" scheme="https://lz5z.com/tags/scikit-learn/"/>
    
      <category term="RandomForestClassifier" scheme="https://lz5z.com/tags/RandomForestClassifier/"/>
    
  </entry>
  
  <entry>
    <title>机器学习常用算法——决策树</title>
    <link href="https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>https://lz5z.com/机器学习常用算法—决策树/</id>
    <published>2017-01-07T21:27:24.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>决策树</h1><p>决策树是一个非参数的监督式学习方法，主要用于分类和回归，算法的目标是通过推断数据特征，学习决策规则从而创建一个预测目标变量的模型。决策树（decision tree）是一个树结构（可以是二叉树或非二叉树）。其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p><img src="/assets/img/决策树.png" alt="决策树"><a id="more"></a><p>决策树（Decision Tree）是一种简单但是广泛使用的分类器。通过训练数据构建决策树，可以高效的对未知的数据进行分类。决策数有两大优点：</p><ol><li>决策树模型可以读性好，具有描述性，有助于人工分析；</li><li>效率高，决策树只需要一次构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。</li></ol><p>决策树既可以做分类，也可以做回归。</p><ol><li>分类树的输出是样本的类标。</li><li>回归树的输出是一个实数 (例如房子的价格，病人呆在医院的时间等)。</li></ol><h2>分类</h2><p>以文章开始的图片为例子，假设银行贷款前需要审查用户信息，来确定是否批准贷款，构造数据 data.scv 如下:</p><blockquote><p>house, married, income, give_loan<br>1, 1, 80, 1<br>1, 0, 30, 1<br>1, 1, 30, 1<br>0, 1, 30, 1<br>0, 1, 40, 1<br>0, 0, 80, 1<br>0, 0, 78, 0<br>0, 0, 70, 1<br>0, 0, 88, 1<br>0, 0, 45, 0<br>0, 1, 87, 1<br>0, 0, 89, 1<br>0, 0, 100, 1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataset = genfromtxt(<span class="string">'data.csv'</span>, delimiter=<span class="string">","</span>)</span><br><span class="line">x = dataset[<span class="number">1</span>:, <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">y = dataset[<span class="number">1</span>:, <span class="number">3</span>]</span><br><span class="line">clf = tree.DecisionTreeClassifier()</span><br><span class="line">clf = clf.fit(x, y)</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">print(clf.predict([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>]])) <span class="comment"># [ 0.] 说明此用户不满足贷款条件</span></span><br></pre></td></tr></table></figure><h2>回归</h2><p>回归和分类不同的是向量 y 可以是浮点数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line">X = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line">y = [<span class="number">0.5</span>, <span class="number">2.5</span>]</span><br><span class="line">clf = tree.DecisionTreeRegressor()</span><br><span class="line">clf = clf.fit(X, y)</span><br><span class="line">clf.predict([[<span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>scikit-learn 官网给出的例子是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 创建随机数据集</span></span><br><span class="line">rng = np.random.RandomState(<span class="number">1</span>)</span><br><span class="line">X = np.sort(<span class="number">5</span> * rng.rand(<span class="number">80</span>, <span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line">y = np.sin(X).ravel()</span><br><span class="line">y[::<span class="number">5</span>] += <span class="number">3</span> * (<span class="number">0.5</span> - rng.rand(<span class="number">16</span>))</span><br><span class="line"><span class="comment"># 训练决策树回归模型</span></span><br><span class="line">regr_1 = DecisionTreeRegressor(max_depth=<span class="number">2</span>)</span><br><span class="line">regr_2 = DecisionTreeRegressor(max_depth=<span class="number">5</span>)</span><br><span class="line">regr_1.fit(X, y)</span><br><span class="line">regr_2.fit(X, y)</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">X_test = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.01</span>)[:, np.newaxis]</span><br><span class="line">y_1 = regr_1.predict(X_test)</span><br><span class="line">y_2 = regr_2.predict(X_test)</span><br><span class="line"><span class="comment"># 结果展示</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X, y, c=<span class="string">"darkorange"</span>, label=<span class="string">"data"</span>)</span><br><span class="line">plt.plot(X_test, y_1, color=<span class="string">"cornflowerblue"</span>, label=<span class="string">"max_depth=2"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.plot(X_test, y_2, color=<span class="string">"yellowgreen"</span>, label=<span class="string">"max_depth=5"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">"data"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"target"</span>)</span><br><span class="line">plt.title(<span class="string">"Decision Tree Regression"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2>决策树的使用</h2><ol><li>如果数据量大，决策树容易过拟合。样本和特征的比例非常重要。如果决策树样本少，特征多，非常可能过拟合。</li><li>可以考虑事先做维度约减(PCA，ICA)，以产生一个特征之间区别性大的决策树</li><li>通过 export 将你的训练的决策树可视化，使用 max_depth =3 作为一个初始的树的深度，有一个数据拟合决策树模型的大概感觉，然后逐渐增加深度<br>数据的样本量的增加将加深决策树的深度，使用 max_depth 控制决策树的尺寸以防止过拟合</li><li>使用 min_samples_split 或者 min_samples_leaf 来控制叶节点的样本数量。一个非常小的数量往往意味着过拟合，而一个较大的数可以防止过拟合。可以将 min_samples_leaf=5 作为一个初始值。如果样本数据变化巨大，可以采用一个浮点数。两者的区别在于 min_samples_leaf 保证了叶节点最小的数量，min_samples_split 能够建立任意数量的叶子节点，在文学上用到也更多</li><li>如果样本是有权重的，可以使用 min_weight_fraction_leaf 来实现基于权重的预修剪规则来优化决策树结构</li><li>决策树内部使用 np.float32 向量，如果样本不是这个形式的，将产生一个数据集的样本</li><li>如果数据矩阵 X 是非常稀疏的，建议在拟合和预测之前转换为稀疏矩阵 csc_matrix。稀疏矩阵将比稠密矩阵快数量级的速度</li></ol><p><a href="https://github.com/Leo555/scikit-learn_demo/tree/master/03DecisionTree" target="_blank" rel="noopener">代码地址</a></p><h1>参考文献</h1><ul><li><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/19/decision-tree.html" target="_blank" rel="noopener">算法杂货铺——分类算法之决策树(Decision tree)</a></li><li><a href="http://blog.csdn.net/gamer_gyt/article/details/51242815" target="_blank" rel="noopener">《机器学习实战》基于信息论的三种决策树算法(ID3,C4.5,CART)</a></li><li><a href="http://python.jobbole.com/86911/" target="_blank" rel="noopener">Scikit-learn中的决策树</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;决策树&lt;/h1&gt;&lt;p&gt;决策树是一个非参数的监督式学习方法，主要用于分类和回归，算法的目标是通过推断数据特征，学习决策规则从而创建一个预测目标变量的模型。决策树（decision tree）是一个树结构（可以是二叉树或非二叉树）。其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个类别。使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。&lt;/p&gt;&lt;img src=&quot;/assets/img/决策树.png&quot; alt=&quot;决策树&quot;&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://lz5z.com/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://lz5z.com/tags/Algorithm/"/>
    
      <category term="Machine Learning" scheme="https://lz5z.com/tags/Machine-Learning/"/>
    
      <category term="scikit-learn" scheme="https://lz5z.com/tags/scikit-learn/"/>
    
      <category term="DecisionTreeClassifier" scheme="https://lz5z.com/tags/DecisionTreeClassifier/"/>
    
      <category term="DecisionTreeRegressor" scheme="https://lz5z.com/tags/DecisionTreeRegressor/"/>
    
  </entry>
  
  <entry>
    <title>机器学习常用算法——逻辑回归</title>
    <link href="https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%80%94%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>https://lz5z.com/机器学习常用算法—逻辑回归/</id>
    <published>2017-01-06T21:27:24.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>逻辑回归</h1><p>首先，逻辑回归是一个分类算法而不是一个回归算法，该算法可根据已知的一系列因变量估计离散数值（比方说二进制数值 0 或 1 ，是或否，真或假），它通过将数据拟合进一个 <strong>逻辑函数</strong> 来预估一个事件出现的概率。因为它预估的是概率，所以它的输出值大小在 0 和 1 之间（正如所预计的一样）。</p><img src="/assets/img/逻辑回归.jpg" alt="线性回归"> [比利时的人口增长数量图]<a id="more"></a><p>逻辑函数由于它的S形，有时也被称为sigmoid函数。</p><p>通过一个简单的例子来理解这个算法。<br>假设你的朋友让你解开一个谜题。这只会有两个结果：你解开了或是你没有解开（离散值）。想象你要解答很多道题来找出你所擅长的主题。这个研究的结果就会像是这样：假设题目是一道十年级的三角函数题，你有 70% 的可能会解开这道题。然而，若题目是个五年级的历史题，你只有 30% 的可能性回答正确。这就是逻辑回归能提供给你的信息。</p><h2>用途</h2><p>逻辑回归主要用于分类，比如邮件分类，是否肿瘤、癌症诊断，用户性别判断，预测用户购买产品类别，判断评论是正面还是负面等。</p><p>逻辑回归的数学模型和求解都相对比较简洁，实现相对简单。通过对特征做离散化和其他映射，逻辑回归也可以处理非线性问题，是一个非常强大的分类器。因此在实际应用中，当我们能够拿到许多低层次的特征时，可以考虑使用逻辑回归来解决我们的问题。</p><h2>加载数据(Data Loading)</h2><p>我们假设输入是一个特征矩阵或者 csv 文件，我们使用 NumPy 来载入 csv 文件。<br>以下是从 UCI 机器学习数据仓库中下载的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">url = <span class="string">"http://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data"</span></span><br><span class="line">raw_data = urllib.request.urlopen(url)</span><br><span class="line"><span class="comment"># 把CSV文件转化为numpy matrix</span></span><br><span class="line">dataset = np.loadtxt(raw_data, delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># 训练集和结果</span></span><br><span class="line">X = dataset[:, <span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line">y = dataset[:, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h2>数据归一化(Data Normalization)与标准化</h2><p>数据归一化是指把数字变成（0,1）之间的小数。</p><p>数据的标准化是将数据按比例缩放，使之落入一个小的特定区间。</p><p>大多数机器学习算法中的梯度方法对于数据的缩放和尺度都是很敏感的，在开始跑算法之前，我们应该进行归一化或者标准化的过程，这使得特征数据缩放到 0-1 范围中。scikit-learn 提供了归一化和标准化的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">normalized_X = preprocessing.normalize(X)</span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">standardized_X = preprocessing.scale(X)</span><br></pre></td></tr></table></figure><h2>特征选择(Feature Selection)</h2><p>在解决一个实际问题的过程中，选择合适的特征或者构建特征的能力特别重要。这成为特征选择或者特征工程。<br>特征选择时一个很需要创造力的过程，更多的依赖于直觉和专业知识，并且有很多现成的算法来进行特征的选择。<br>下面的树算法(Tree algorithms)计算特征的信息量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesClassifier</span><br><span class="line">model = ExtraTreesClassifier()</span><br><span class="line">model.fit(X, y)</span><br><span class="line"><span class="comment"># 显示每个属性相对重要性</span></span><br><span class="line">print(model.feature_importances_)</span><br></pre></td></tr></table></figure><h3>关于特征提取</h3><p>机器学习是一个过程，这样的过程包括数据处理 + 模型训练，而特征提取是数据处理中不可或缺的一环。</p><p>比如预测什么样的生活方式特征是引发冠心病 (CHD) 的危险因素？给定具有吸烟状态、饮食、锻炼、饮酒和 CHD 状态度量的患者样本，可以使用这四个生活方式变量建立一个模型，用于预测患者样本中 CHD 的存在性。然后可使用此模型为每个因子推导几率比估计值，从而获知某些信息，例如吸烟者比非吸烟者在何种程度上更易患 CHD。</p><h2>算法选择–逻辑回归</h2><p>大多数问题都可以归结为二元分类问题。这个算法的优点是可以给出数据所在类别的概率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">expected = y</span><br><span class="line">predicted = model.predict(X)</span><br><span class="line"><span class="comment"># 模型拟合概述</span></span><br><span class="line">print(metrics.classification_report(expected, predicted))</span><br><span class="line">print(metrics.confusion_matrix(expected, predicted))</span><br></pre></td></tr></table></figure><h2>最后</h2><p>以上 <strong>加载数据</strong> -&gt; <strong>数据归一化</strong> -&gt; <strong>特征选择</strong> -&gt; <strong>算法选择</strong> 既是机器学习的一般代码逻辑。如果选择其它算法，只需要更改最后一步算法选择即可。</p><p><a href="https://github.com/Leo555/scikit-learn_demo/tree/master/02LogisticRegression" target="_blank" rel="noopener">代码地址</a></p><h1>参考文献</h1><ul><li><a href="http://tech.meituan.com/intro_to_logistic_regression.html" target="_blank" rel="noopener">Logistic Regression 模型简介</a></li><li><a href="http://www.ibm.com/support/knowledgecenter/zh/SSLVMB_22.0.0/com.ibm.spss.statistics.help/spss/regression/idh_lreg.htm" target="_blank" rel="noopener">Logistic 回归</a></li><li><a href="http://blog.jasonding.top/2015/04/17/Machine%20Learning%20Experiments/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C%E3%80%91scikit-learn%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92" target="_blank" rel="noopener">scikit-learn的主要模块和基本使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;逻辑回归&lt;/h1&gt;&lt;p&gt;首先，逻辑回归是一个分类算法而不是一个回归算法，该算法可根据已知的一系列因变量估计离散数值（比方说二进制数值 0 或 1 ，是或否，真或假），它通过将数据拟合进一个 &lt;strong&gt;逻辑函数&lt;/strong&gt; 来预估一个事件出现的概率。因为它预估的是概率，所以它的输出值大小在 0 和 1 之间（正如所预计的一样）。&lt;/p&gt;&lt;img src=&quot;/assets/img/逻辑回归.jpg&quot; alt=&quot;线性回归&quot;&gt; [比利时的人口增长数量图]
    
    </summary>
    
      <category term="Machine Learning" scheme="https://lz5z.com/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://lz5z.com/tags/Algorithm/"/>
    
      <category term="Machine Learning" scheme="https://lz5z.com/tags/Machine-Learning/"/>
    
      <category term="scikit-learn" scheme="https://lz5z.com/tags/scikit-learn/"/>
    
      <category term="LogisticRegression" scheme="https://lz5z.com/tags/LogisticRegression/"/>
    
  </entry>
  
  <entry>
    <title>机器学习常用算法——线性回归</title>
    <link href="https://lz5z.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E2%80%94%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>https://lz5z.com/机器学习常用算法—线性回归/</id>
    <published>2017-01-05T21:27:24.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>上次的 ITA 项目开始接触机器学习相关的知识，从本文开始，我将学习并介绍机器学习最常用的几种算法，并使用 <a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a> 相关模型完成相关算法的 demo。</p><h1>线性回归</h1><img src="/assets/img/线性回归.jpg" alt="线性回归"><a id="more"></a><p>线性回归，是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。我们通过拟合最佳直线来建立自变量和因变量的关系，这条最佳直线叫做回归线，并且用 <code>Y= a*x + b</code>这条线性等式来表示。</p><p>理解线性回归可以想象一下一般人身高与体重之间的关系，在不能准确测试体重的情况下，按照身高进行排序，也能大体得出体重的大小。这是现实生活中使用线性回归的例子。<br>在这个例子中，Y 是体重（因变量），x 是身高（自变量），a 和 b 分别为斜率和截距，可以通过最小二乘法获得。</p><h2>身高体重</h2><h3>准备数据</h3><p>自己伪造了一些数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runplt</span><span class="params">()</span>:</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.title(<span class="string">u'Height-Weight'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">u'Height'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">u'Weight'</span>)</span><br><span class="line">    plt.axis([<span class="number">150</span>, <span class="number">190</span>, <span class="number">40</span>, <span class="number">90</span>])</span><br><span class="line">    plt.grid(<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> plt</span><br><span class="line"></span><br><span class="line">plt = runplt()</span><br><span class="line">x = [[<span class="number">155</span>], [<span class="number">157</span>], [<span class="number">166</span>], [<span class="number">177</span>], [<span class="number">187</span>]]</span><br><span class="line">y = [[<span class="number">55</span>], [<span class="number">60</span>], [<span class="number">63</span>], [<span class="number">70</span>], [<span class="number">79</span>]]</span><br><span class="line">plt.plot(x, y, <span class="string">'k.'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/assets/img/线性回归_1.png" alt="线性回归"><h3>创建并拟合模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(x, y)</span><br><span class="line">print(<span class="string">'预测身高180同学的体重：$%.2f'</span> % model.predict(np.array([<span class="number">180</span>]).reshape(<span class="number">-1</span>, <span class="number">1</span>))[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>上述代码中 sklearn.linear_model.LinearRegression 类是一个估计器（estimator）。估计器依据观测值来预测结果。在 scikit-learn 里面，所有的估计器都带有:</p><ul><li>fit()</li><li>predict()</li></ul><p>fit() 用来分析模型参数，predict() 是通过 fit()算出的模型参数构成的模型，对解释变量进行预测获得的值。<br>因为所有的估计器都有这两种方法，所有 scikit-learn 很容易实现不同的模型。</p><h2>线性回归分类</h2><p>线性回归的两种主要类型是一元线性回归和多元线性回归。一元线性回归的特点是只有一个自变量。多元线性回归则存在多个自变量。找最佳拟合直线的时候，你可以拟合到多项或者曲线回归。这些就被叫做多项或曲线回归。</p><h3>一元线性回归</h3><p>一元线性回归模型是 <code>Y= a*x + b</code>，求解一元线性回归模型的本质就是求解参数 a 和 b 的过程，最常用的方法为最小二乘法。</p><h4>残差预测值</h4><p>模型的残差是训练样本点与线性回归模型的纵向距离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 残差预测值</span></span><br><span class="line">y2 = model.predict(x)</span><br><span class="line">plt.plot(x, y, <span class="string">'k.'</span>)</span><br><span class="line">plt.plot(x, y2, <span class="string">'g-'</span>)</span><br><span class="line"><span class="keyword">for</span> idx, x <span class="keyword">in</span> enumerate(x):</span><br><span class="line">    plt.plot([x, x], [y[idx], y2[idx]], <span class="string">'r-'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="/assets/img/线性回归_2.jpg" alt="线性回归"></p><p>我们可以通过残差之和最小化实现最佳拟合，也就是说模型预测的值与训练集的数据最接近就是最佳拟合。对模型的拟合度进行评估的函数称为残差平方和（residual sum of squares）成本函数。就是让所有训练数据与模型的残差的平方之和最小化，如下所示：<br><img src="/assets/img/线性回归_3.png" alt="线性回归"></p><p>其中， yi 是观测值， f(xi)f(xi) 是预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(<span class="string">'残差平方和: %.2f'</span> % np.mean((model.predict(x) - y) ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>残差平方和: 2.05</p><h4>模型评估</h4><p>使用线性回归得出模型后，我们可以用 R 方（r-squared）评估模型的效果。R方也叫确定系数（coefficient of determination），表示模型对现实数据拟合的程度。</p><p>一元线性回归中R方等于皮尔逊积矩相关系数（Pearson product moment correlation coefficient或Pearson’s r）的平方。这种方法计算的R方一定介于0～1之间的正数。其他计算方法，包括scikit-learn中的方法，不是用皮尔逊积矩相关系数的平方计算的，因此当模型拟合效果很差的时候R方会是负值。</p><img src="/assets/img/线性回归_4.png" alt="线性回归"><p>LinearRegression的score方法可以计算R方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 测试集</span></span><br><span class="line">x_test = [[<span class="number">156</span>], [<span class="number">163</span>], [<span class="number">166</span>], [<span class="number">170</span>], [<span class="number">188</span>]]</span><br><span class="line">y_test = [[<span class="number">56</span>], [<span class="number">63</span>], [<span class="number">63</span>], [<span class="number">72</span>], [<span class="number">80</span>]]</span><br><span class="line">print(<span class="string">'R方： '</span>, model.score(x_test, y_test))</span><br></pre></td></tr></table></figure><p>R 方： 0.898422638707</p><p>R 方是 0.898 说明测试集里面大多数的数据都可以通过模型解释</p><h3>多元回归</h3><p>多元回归即存在多个自变量，比如影响体重的因素不仅仅有身高，还有胸围，假设 x 中的第一个参数为身高，第二个参数为胸围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="comment">## 伪造数据</span></span><br><span class="line">x = [[<span class="number">155</span>, <span class="number">80</span>], [<span class="number">157</span>, <span class="number">82</span>], [<span class="number">166</span>, <span class="number">85</span>], [<span class="number">177</span>, <span class="number">90</span>], [<span class="number">187</span>, <span class="number">97</span>]]</span><br><span class="line">y = [[<span class="number">55</span>], [<span class="number">60</span>], [<span class="number">63</span>], [<span class="number">70</span>], [<span class="number">79</span>]]</span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(x, y)</span><br><span class="line"><span class="comment">## 伪造测试集</span></span><br><span class="line">x_test = [[<span class="number">156</span>, <span class="number">80</span>], [<span class="number">163</span>, <span class="number">83</span>], [<span class="number">166</span>, <span class="number">84</span>], [<span class="number">170</span>, <span class="number">87</span>], [<span class="number">188</span>, <span class="number">99</span>]]</span><br><span class="line">y_test = [[<span class="number">56</span>], [<span class="number">63</span>], [<span class="number">63</span>], [<span class="number">72</span>], [<span class="number">80</span>]]</span><br><span class="line">predictions = model.predict(x_test)</span><br><span class="line"><span class="keyword">for</span> i, prediction <span class="keyword">in</span> enumerate(predictions):</span><br><span class="line">    print(<span class="string">'Predicted: %.2f, Target: %s'</span> % (prediction, y_test[i]))</span><br><span class="line">print(<span class="string">'R-squared: %.2f'</span> % model.score(x_test, y_test))</span><br></pre></td></tr></table></figure><p>Predicted: 56.05, Target: [56]<br>Predicted: 60.03, Target: [63]<br>Predicted: 61.30, Target: [63]<br>Predicted: 65.56, Target: [72]<br>Predicted: 82.42, Target: [80]<br>R-squared: 0.83</p><h3>多项式回归</h3><p>上面两个例中，都假设自变量和响应变量的关系是线性的。真实情况未必如此，现实世界中的曲线关系都是通过增加多项式实现的，其实现方式和多元线性回归类似。在 scikit-learn 中，我们使用 <strong>PolynomialFeatures</strong> 构建多项式回归模型。下面比较多项式回归和线性回归的区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="comment"># 建立线性回归，并用训练的模型绘图</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(x, y)</span><br><span class="line">xx = np.linspace(<span class="number">150</span>, <span class="number">190</span>, <span class="number">100</span>)</span><br><span class="line">yy = model.predict(xx.reshape(xx.shape[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">plt = runplt()</span><br><span class="line">plt.plot(x, y, <span class="string">'k.'</span>)</span><br><span class="line">plt.plot(xx, yy)</span><br><span class="line"><span class="comment"># degree=3表示多项式最高项为3</span></span><br><span class="line">polynomial_featurizer = PolynomialFeatures(degree=<span class="number">3</span>)</span><br><span class="line">x_train_polynomial = polynomial_featurizer.fit_transform(x)</span><br><span class="line">x_test_polynomial = polynomial_featurizer.transform(x_test)</span><br><span class="line">model_polynomial = LinearRegression()</span><br><span class="line">model_polynomial.fit(x_train_polynomial, y)</span><br><span class="line">xx_polynomial = polynomial_featurizer.transform(xx.reshape(xx.shape[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">plt.plot(xx, model_polynomial.predict(xx_polynomial), <span class="string">'r-'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">print(x)</span><br><span class="line">print(x_train_polynomial)</span><br><span class="line">print(x_test)</span><br><span class="line">print(x_test_polynomial)</span><br><span class="line">print(<span class="string">'1 r-squared'</span>, model.score(x_test, y_test))</span><br><span class="line">print(<span class="string">'2 r-squared'</span>, model_polynomial.score(x_test_polynomial, y_test))</span><br></pre></td></tr></table></figure><img src="/assets/img/线性回归_5.jpg" alt="线性回归"><h3>拟合过度</h3><p>我们不断改变 polynomial_featurizer = PolynomialFeatures(degree=3) 中 degree 的参数，当 degree = 5 的时候曲线经过所有的点，这种情况就成为拟合过度（over-fitting）。当模型出现拟合过度的时候，并没有从输入和输出中推导出一般的规律，而是记忆训练集的结果，这样在测试集的测试效果就不好了。</p><img src="/assets/img/线性回归_6.jpg" alt="线性回归"><p><a href="https://github.com/Leo555/scikit-learn_demo/tree/master/01LinearRegression" target="_blank" rel="noopener">代码地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;上次的 ITA 项目开始接触机器学习相关的知识，从本文开始，我将学习并介绍机器学习最常用的几种算法，并使用 &lt;a href=&quot;http://scikit-learn.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scikit-learn&lt;/a&gt; 相关模型完成相关算法的 demo。&lt;/p&gt;&lt;h1&gt;线性回归&lt;/h1&gt;&lt;img src=&quot;/assets/img/线性回归.jpg&quot; alt=&quot;线性回归&quot;&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://lz5z.com/categories/Machine-Learning/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="Algorithm" scheme="https://lz5z.com/tags/Algorithm/"/>
    
      <category term="Machine Learning" scheme="https://lz5z.com/tags/Machine-Learning/"/>
    
      <category term="scikit-learn" scheme="https://lz5z.com/tags/scikit-learn/"/>
    
      <category term="LinearRegression" scheme="https://lz5z.com/tags/LinearRegression/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据类型</title>
    <link href="https://lz5z.com/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://lz5z.com/JavaScript数据类型/</id>
    <published>2016-12-27T14:02:32.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 语言可以识别 7 中不同的数据类型，除 Object 外，其它均为基本数据类型，Object 为引用数据类型。</p><ul><li>Undefined, 只有一个值，即特殊值 undefined，使用 var/let/const 声明但未初始化的值。</li><li>Null，只有一个值，即特殊值 null，null 值表示一个空对象指针。</li><li>Boolean，布尔型，true 和 false。</li><li>Number, 整数和浮点数。</li><li>String, 字符串，由零个或者多个 16 位 Unicode 字符串组成的字符序列。</li><li>Symbol, ES6 新增类型，它的实例是唯一且不可改变的。</li><li>Object, 一组数据和功能的集合。可以通过 new 加对象名称创建。</li></ul><a id="more"></a><h3>Undefined 类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message <span class="comment">// 变量声明之后默认取得了 undefined 值</span></span><br><span class="line">message == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">message === <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3>Null 类型</h3><p>Null 类型只有一个值 null，null 表示一个空指针对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "objec"</span></span><br></pre></td></tr></table></figure><p>如果定义变量准备在将来保存对象，最好讲该变量初始化为 null，这样可以通过检查 null 来判断是否已经保存了一个对象的引用。</p><p>实际上，undefined 值派生自 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>null vs undefined</p><p>尽管 null 和 undefined 之间的相等操作符（==）返回 true，不过它们的用途完全不同，如前所述，无论什么情况下，没有必要把一个变量的值设为 undefined，而如果一个变量将来要保存对象，应该将其显式地设为 null。</p><h3>Boolean 类型</h3><p>对于任何数据类型，调用 Boolean() 函数，总是会返回一个 Boolean 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'/t'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3>Number 类型</h3><p>(1) 整数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span></span><br><span class="line"><span class="keyword">var</span> octalNum = <span class="number">070</span> <span class="comment">// 八进制的 56</span></span><br><span class="line"><span class="keyword">var</span> hexNum = <span class="number">0xA</span> <span class="comment">// 十六进制的 10</span></span><br><span class="line"></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>(2) 浮点数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3e-17</span> <span class="comment">// 0.000...03</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> <span class="comment">// 0.30000000000000004 浮点数最高精度为 17 位小数</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ECMAScript 最小数：Number.MIN_VALUE，在大多数浏览器中为 5e-324。<br>ECMAScript 最大数：Number.MAX_VALUE，在大多数浏览器中为 1.7976931348623157e+308。</p><p>如果计算超过 JavaScript 数值范围，会自动转为特殊的 Infinity 值，负数则为 -Infinity。Infinity 不能参与数值计算。通过 isFinite() 函数判断参数是否位于最大值和最小值之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>(3) NaN （Not a Number）</p><p>NaN 用来表示本来要返回数值的操作数未返回数值的情况，避免抛出错误。</p><p>NaN 的设计有两个特点：</p><p>1.任何涉及 NaN 的操作都返回 NaN<br>2.NaN与任何值都不相等，包括 NaN 本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>/<span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span>/<span class="number">10</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>针对这两个特点，ECMAScript 设计了 isNaN() 函数。这个函数帮助我们判断参数是否 “不是数值”。isNaN() 接受参数后，会尝试将这个值转换为数值，如果这个值不能被转换为数值，则返回 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">10</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'10'</span>) <span class="comment">// false 可以转换为数值 10</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'blue'</span>) <span class="comment">// true 不能转换为数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>) <span class="comment">// false 可以转换为数值 1</span></span><br></pre></td></tr></table></figure><p>(4) 数值转换</p><p>Number() 函数转换规则如下：</p><p>1.如果是 Boolean 值，返回 1 或者 0。<br>2.数字直接返回。<br>3.null 返回 0。<br>4.undefined 返回 NaN。<br>5.字符串：如果是十进制整数，八进制整数或者十六进制整数返回十进制整数，空字符串返回 0，其它均返回 NaN。<br>6.如果是对象，调用对象的 valueOf() 方法，然后按照前面的转换规则转换，如果转换值为 NaN，则调用对象的 toString() 方法。</p><p>parseInt()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1234blue'</span>) <span class="comment">// 1234</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xA'</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">22.5</span>) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">070</span>) <span class="comment">// 56</span></span><br></pre></td></tr></table></figure><p>parseInt() 解析八进制字面量的字符串时，ES3 和 ES5 存在区别，在 ES3 中 ‘070’ 被当做八进制字面量，ES5 则当做 ‘70’。<br>因此 parseInt 可以接收第二个参数，表示以多少进制解析第一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0xAF'</span>, <span class="number">16</span>) <span class="comment">// 175</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'070'</span>) <span class="comment">// 70</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'070'</span>, <span class="number">8</span>) <span class="comment">// 56</span></span><br></pre></td></tr></table></figure><h3>Symbol 类型</h3><p>Symbol 是 ES6 新增的数据类型，用来解决对象中属性名重复的问题，Symbol 表示独一无二的值，通过 Symbol 函数生成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"foo"</span>) !== <span class="built_in">Symbol</span>(<span class="string">"foo"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">typeof</span> foo === <span class="string">"symbol"</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> bar === <span class="string">"symbol"</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[foo] = <span class="string">"foo"</span></span><br><span class="line">obj[bar] = <span class="string">"bar"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [ foo, bar ]</span></span><br></pre></td></tr></table></figure><h3>Object 类型</h3><p>Object 对象是一组数据和功能的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>关于 Object 对象的详细内容，可以参考 <a href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84Object%E5%AF%B9%E8%B1%A1/">深入学习JavaScript——Object对象</a> 和 <a href="https://lz5z.com/Object.defineProperty%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/">使用 Object.defineProperty 为对象定义属性</a>。</p><h3>如何判断数据类型</h3><p>(1) typeof 操作符</p><p>typeof 操作符返回值一共有7种：number，boolean，symbol，string，object，undefined，function。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">''</span> <span class="comment">// string 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// number 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// symbol 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">//boolean 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//undefined 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>() <span class="comment">// function 有效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>() <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回 function 类型。</li></ul><p>(2) instanceof</p><p>instanceof 用来判断 A 是否为 B 的实例，需要注意的是，instanceof 检测的是原型。</p><p>可以理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A, B) &#123;</span><br><span class="line">  <span class="keyword">var</span> L = A.__proto__</span><br><span class="line">  <span class="keyword">var</span> R = B.prototype</span><br><span class="line">  <span class="keyword">return</span> L === R    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> A() <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>[] 的 <code>__proto__</code> 指向了 Array.prototype，而 <code>Array.prototype.__proto__</code> 又指向了 Object.prototype，而 <code>Object.prototype.__proto__</code> 指向了 null，因此 []、Array、Object 在内部形成了一条原型链。instanceof 只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。</p><p>(3) constructor</p><p>当一个函数 F 被定义的时候，JS 引擎会自动帮其添加 prototype，并在 prototype 上添加一个 constructor 属性，并让其指向 F 的引用。</p><img src="/assets/img/js_constructor.png" alt="js_constructor"><p>当实例化 F 的时候，<code>var f = new F()</code>，F 原型上的 constructor 传递到了 f 上，因此 <code>f.constructor === F</code>。</p><p>F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.constructor === <span class="built_in">String</span></span><br><span class="line">(<span class="number">1</span>).constructor === <span class="built_in">Number</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>().constructor === <span class="built_in">Function</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Error</span>().constructor === <span class="built_in">Error</span></span><br><span class="line">[].constructor === <span class="built_in">Array</span></span><br><span class="line"><span class="built_in">document</span>.constructor === HTMLDocument</span><br><span class="line"><span class="built_in">window</span>.constructor === Window</span><br></pre></td></tr></table></figure><p>利用 constructor 判断数据类型存在的问题：</p><ol><li>null 和 undefined 是无效对象，因此没有 constructor 存在。</li><li>函数的 constructor 可以被重写，因此可能会出现判断错误。</li></ol><p>(4) toString</p><p>toString() 是 Object 的原型方式，调用该方法，默认返回当前对象的 <code>[[CLass]]</code>，其格式为 [object Xxx]，其中 Xxx 就是对象的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) <span class="comment">// [object Window]</span></span><br></pre></td></tr></table></figure><h2>引用数据类型 vs 基本数据类型</h2><p>基本数据类型复制相当于在内存中新开辟一块内存，引用数据类型的复制相当于在内存中创建了一个新的指针，指向存储在堆中的一个对象。</p><p>ECMAScript 中所有的函数都是 <strong>按值传递参数</strong> 的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另外一个变量一样。<br>在向参数传递基本数据类型的值时，被传递的值会被复制给一个局部变量（即命名参数，也就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">'Leo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setName(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// "Leo"</span></span><br></pre></td></tr></table></figure><h2>参考资料</h2><ul><li>《JavaScript高级程序设计》</li><li><a href="https://www.cnblogs.com/onepixel/p/5126046.html" target="_blank" rel="noopener">判断JS数据类型的4种方法</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types" target="_blank" rel="noopener">语法和数据类型</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 语言可以识别 7 中不同的数据类型，除 Object 外，其它均为基本数据类型，Object 为引用数据类型。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Undefined, 只有一个值，即特殊值 undefined，使用 var/let/const 声明但未初始化的值。&lt;/li&gt;&lt;li&gt;Null，只有一个值，即特殊值 null，null 值表示一个空对象指针。&lt;/li&gt;&lt;li&gt;Boolean，布尔型，true 和 false。&lt;/li&gt;&lt;li&gt;Number, 整数和浮点数。&lt;/li&gt;&lt;li&gt;String, 字符串，由零个或者多个 16 位 Unicode 字符串组成的字符序列。&lt;/li&gt;&lt;li&gt;Symbol, ES6 新增类型，它的实例是唯一且不可改变的。&lt;/li&gt;&lt;li&gt;Object, 一组数据和功能的集合。可以通过 new 加对象名称创建。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="数据类型" scheme="https://lz5z.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="typeof" scheme="https://lz5z.com/tags/typeof/"/>
    
  </entry>
  
  <entry>
    <title>async 和 defer 的区别</title>
    <link href="https://lz5z.com/async%E5%92%8Cdefer%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://lz5z.com/async和defer的区别/</id>
    <published>2016-12-26T15:43:58.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 中的 <code>&lt;script&gt;</code> 元素定义了6个属性：</p><ul><li>async：可选，表示立即下载脚本，但不应该妨碍页面中其它的操作，比如下载其它资源或者等待加载其它脚本，只对外部脚本文件有效。</li><li>charset：可选，src 属性指定的代码的字符集。多数浏览器会忽略它的值。</li><li>defer：可选，表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部脚本有效。</li><li>language：已废弃。</li><li>src：可选，表示要执行代码的外部文件。src 可以包含来自外部域的文件。</li><li>type：可选，可以看成 language 的替代属性。表示编写代码使用的脚本语言的内容类型（MIME），默认值为 text/javascript。</li></ul><p>要注意的是，带有 src 的 <code>&lt;script&gt;</code> 元素中不应该再包含额外的代码，如果包含了嵌入的代码，则只会下载外部文件，嵌入的代码不会执行。</p><a id="more"></a><h2>标签的位置</h2><p>按照惯例，所有的 <code>&lt;script&gt;</code> 都应该放入 <code>&lt;head&gt;</code> 中，但是这就意味着必须要等所有的 JavaScript 代码下载解析和执行完毕后才能开始呈现页面内容（浏览器在遇到 body 标签时，才开始呈现页面内容）。假如有很多 JavaScript 代码需要执行的话，就会导致浏览器窗口出现空白，因此比较好的做法是把 JavaScript 代码放在 <code>&lt;body&gt;</code> 的最后。</p><h2>延迟脚本 defer</h2><p>HTML4.01 中为 <code>&lt;script&gt;</code> 增加了 defer 属性，这个属性用来表明脚本执行的时候不会影响页面结构，也就是说脚本会延迟到整页面解析完毕后再运行。因此在 <code>&lt;script&gt;</code> 中设置 defer 属性，相当于告诉浏览器，立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"./b.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，虽然 <code>&lt;script&gt;</code> 放在了 head 中，但是其中包含的脚本将延迟到浏览器解析到 <code>&lt;/html&gt;</code> 标签才会开始执行。HTML5 规范要求脚本按照他们出现的先后顺序执行，因此第一个延迟脚本 a.js 会优先于 b.js 执行，而这两个脚本会先于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded" target="_blank" rel="noopener">DOMContentLoaded</a> 事件执行。在现实中，延迟脚本不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发之前执行，因此最好只包含一个延迟脚本。</p><p>defer 属性只适用于外部脚本文件，因此嵌入脚本的 defer 属性会被浏览器忽略，而且各个浏览器对 defer 属性的处理不尽相同，因此把延迟脚本放在页面底部仍是最佳选择。</p><blockquote><p>在 XHTML 文档中，要把 defer 属性设置为 defer=“defer”</p></blockquote><h2>异步脚本 async</h2><p>HTML5 为 <code>&lt;script&gt;</code> 元素定义了 async 属性。async 只适用于外部脚本文件，并且告诉浏览器立即下载文件。但与 defer 不同的是，标记为 async 的脚本并不能保证按照指定它们的先后顺序执行。例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scrpt</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrpt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scrpt</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrpt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，b.js 可能会在 a.js 之前执行，因此，确保两者之间互不依赖非常重要，指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步脚在页面其它内容。因此，建议异步脚本不要在加载期间修改 DOM。</p><p>异步脚本一定会在页面 <a href="https://developer.mozilla.org/en-US/docs/Web/Events/load" target="_blank" rel="noopener">load</a> 事件之前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p><h2>defer vs async</h2><p>下面这张图能很好地说明 defer 与 async 之间的关系：</p><img src="/assets/img/async_vs_defer.svg" alt="defer_vs_async"><p>从图中我们可以得出以下几点：</p><ul><li>defer 和 async 在下载时是一样的，都是异步的（相较 HTML 解析）。</li><li>defer 会在 HTML 解析完成后执行的，async 则是下载完成后执行。</li><li>defer 是按照加载顺序执行的，async 是哪个文件先加载完，哪个先执行。</li><li>async 在使用的时候，可以用于完全无依赖的脚本，比如百度分析或者 Google Analytics。</li></ul><h2>chrome 是怎么样做的</h2><p>上面提到的只是规范，但是各个厂商的实现可能有所不同，chrome 浏览器首先会请求 HTML 文档，然后对其中的各种资源（图片、CSS、视频等）调用相应的资源加载器进行<strong>异步网络请求</strong>，同时进行 DOM 渲染，直到遇到 <code>&lt;script&gt;</code> 标签的时候，主进程才会停止渲染等待此资源加载完毕然后调用 V8 引擎对 js 解析，继而继续进行 DOM 解析。可以理解为如果加了 async 属性就相当于单独开了一个进程去独立加载和执行，而 defer 是和将 <code>&lt;script&gt;</code> 放到 body 底部一样的效果。</p><p>为验证我们设计测试代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.css"</span> <span class="attr">ref</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.0/css/bootstrap.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.6/quill.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/react/16.3.2/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.5/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.16/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3>放在 head 中</h3><img src="/assets/img/async_vs_defer_script.png" alt="async_vs_defer_script"><p>可以看到几个资源是异步加载并且执行后才开始出现首屏效果，首屏时间接近 1000ms，还是比较慢的。</p><h3>放在 body 底部</h3><img src="/assets/img/async_vs_defer_body.png" alt="async_vs_defer_body"><p>放在 body 底部的时候，首屏出现的时间快了很多，大约在 500ms 左右，资源文件在 HTML 解析后按顺序加载执行。</p><h3>放在 head 中并且使用 defer</h3><img src="/assets/img/async_vs_defer_head_defer.png" alt="async_vs_defer_head_defer"><p>defer 为延迟执行，但是下载是可以异步下载的，首屏时间不到 600ms，但是慢于 script 放于 body 底部。</p><h3>放在 head 中并且使用 async</h3><img src="/assets/img/async_vs_defer_head_async.png" alt="async_vs_defer_head_async"><p>async 为异步代码，所有的代码都是在页面解析完成后执行，但是执行顺序并非按照代码书写顺序。</p><h3>defer vs async</h3><p>两个放在一起更能看出效果</p><img src="/assets/img/async_vs_defer.png" alt="async_vs_defer"><h2>参考资料</h2><ul><li>《JavaScript 高级程序设计》</li><li><a href="https://segmentfault.com/a/1190000006778717" target="_blank" rel="noopener">浅谈script标签的defer和async</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML 中的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素定义了6个属性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;async：可选，表示立即下载脚本，但不应该妨碍页面中其它的操作，比如下载其它资源或者等待加载其它脚本，只对外部脚本文件有效。&lt;/li&gt;&lt;li&gt;charset：可选，src 属性指定的代码的字符集。多数浏览器会忽略它的值。&lt;/li&gt;&lt;li&gt;defer：可选，表示脚本可以延迟到文档完全被解析和显示后再执行。只对外部脚本有效。&lt;/li&gt;&lt;li&gt;language：已废弃。&lt;/li&gt;&lt;li&gt;src：可选，表示要执行代码的外部文件。src 可以包含来自外部域的文件。&lt;/li&gt;&lt;li&gt;type：可选，可以看成 language 的替代属性。表示编写代码使用的脚本语言的内容类型（MIME），默认值为 text/javascript。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;要注意的是，带有 src 的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 元素中不应该再包含额外的代码，如果包含了嵌入的代码，则只会下载外部文件，嵌入的代码不会执行。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="async" scheme="https://lz5z.com/tags/async/"/>
    
      <category term="defer" scheme="https://lz5z.com/tags/defer/"/>
    
      <category term="script" scheme="https://lz5z.com/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>DOM 事件机制</title>
    <link href="https://lz5z.com/DOM%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://lz5z.com/DOM事件机制/</id>
    <published>2016-12-25T17:44:44.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>DOM 事件流（event flow）存在三个阶段：事件捕获 --&gt; 事件目标 --&gt; 事件冒泡。</p><p>事件捕获：当事件发生时（onclick, onmouseover……），浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。（IE10 及以下浏览器不支持捕获型事件）</p><p>事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。</p><a id="more"></a><h2>事件</h2><p>(1) onlick --&gt;事件冒泡，重写 onlick 会覆盖之前属性，没有兼容性问题。DOM0 级事件处理程序，每个元素都有自己的事件处理程序属性，这些属性通常全部小写，将这些属性的值全部设置为一个函数，就可以指定事件处理程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line"><span class="comment">// 绑定单击事件</span></span><br><span class="line">el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解绑单击事件，将 onclick 属性设为 null 即可</span></span><br><span class="line">el.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>(2) addEventListener(event, listener, useCapture)</p><p>参数定义：event—（事件名称，如 click，不带 on），listener—事件监听函数，useCapture—是否采用事件捕获进行事件捕捉，默认为 false，即采用事件冒泡方式。 IE8 及以下不支持，属于 DOM2 级的方法，<strong>可添加多个方法不被覆盖</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件类型没有 on，false 表示在事件第三阶段（冒泡）触发，true表示在事件第一阶段（捕获）触发。 如果handle是同一个方法，只执行一次。</span></span><br><span class="line">ele.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;, <span class="literal">false</span>) </span><br><span class="line"><span class="comment">// 解绑事件，参数和绑定一样</span></span><br><span class="line">ele.removeEventListener(event.type, handle, boolean)</span><br></pre></td></tr></table></figure><p>(3) attachEvent(event.type, handle) IE 特有，兼容 IE8 及以下，可添加多个事件处理程序，与 DOM 方法不同的是，多个事件的执行顺序与添加顺序相反，attachEvent 只支持冒泡阶段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 handle 是同一个方法，绑定几次执行几次，这点和 addEventListener 不同,事件类型要加 on, 例如 onclick 而不是 click</span></span><br><span class="line">ele.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;)</span><br><span class="line"><span class="comment">// 解绑事件，参数和绑定一样</span></span><br><span class="line">ele.detachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;)</span><br></pre></td></tr></table></figure><p>使用 attachEvent() 添加的事件可以通过 detachEvent() 来移除，条件是必须提供相同的参数，与 DOM 方法一样，这也意味着添加的匿名函数不能被移除。</p><p>(4) 默认事件行为：href=’’，submit表单提交等</p><ul><li>return false 阻止独享属性（通过on这种方式）绑定的事件的默认事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ele.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ……             <span class="comment">// 你的代码</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>   <span class="comment">// 通过返回false值阻止默认事件行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>event.preventDefault() 阻止通过 addEventListener() 添加的事件的默认事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> event = e || <span class="built_in">window</span>.event</span><br><span class="line">  ……</span><br><span class="line">  event.preventDefault()    <span class="comment">// 阻止默认事件</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><ul><li>event.returnValue = false 阻止通过 attachEvent() 添加的事件的默认事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> event = e || <span class="built_in">window</span>.event</span><br><span class="line">  ……</span><br><span class="line">  event.returnValue = <span class="literal">false</span>     <span class="comment">// 阻止默认事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2>DOM 中的事件对象</h2><table><thead><tr><th style="text-align:left">属性/方法</th><th style="text-align:left">类型</th><th style="text-align:left">读写</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Event.bubbles</td><td style="text-align:left">Boolean</td><td style="text-align:left">只读</td><td style="text-align:left">表示该事件是否在 DOM 中冒泡</td></tr><tr><td style="text-align:left">Event.cancelable</td><td style="text-align:left">Boolean</td><td style="text-align:left">只读</td><td style="text-align:left">表示这个事件是否可以取消</td></tr><tr><td style="text-align:left">Event.currentTarget</td><td style="text-align:left">Element</td><td style="text-align:left">只读</td><td style="text-align:left">当前注册事件的对象的引用，当前事件需要传递到的对象</td></tr><tr><td style="text-align:left">Event.defaultPrevented</td><td style="text-align:left">Boolean</td><td style="text-align:left">只读</td><td style="text-align:left">表示了是否已经执行过了 event.preventDefault()</td></tr><tr><td style="text-align:left">Event.eventPhase</td><td style="text-align:left">Integer</td><td style="text-align:left">只读</td><td style="text-align:left">指示事件流正在处理哪个阶段: 1.捕获 2.目标 3. 冒泡</td></tr><tr><td style="text-align:left">Event.target</td><td style="text-align:left">Element</td><td style="text-align:left">只读</td><td style="text-align:left">对事件起源目标的引用</td></tr><tr><td style="text-align:left">Event.timeStamp</td><td style="text-align:left">Number</td><td style="text-align:left">只读</td><td style="text-align:left">事件创建时的时间戳，毫秒级别</td></tr><tr><td style="text-align:left">Event.type</td><td style="text-align:left">String</td><td style="text-align:left">只读</td><td style="text-align:left">事件的类型（‘click’）</td></tr><tr><td style="text-align:left">event.preventDefault</td><td style="text-align:left">Function</td><td style="text-align:left">只读</td><td style="text-align:left">取消事件的默认行为，如果 cancelable 是 true，则可以使用这个方法</td></tr><tr><td style="text-align:left">event.stopImmediatePropagation</td><td style="text-align:left">Function</td><td style="text-align:left">只读</td><td style="text-align:left">取消事件的进一步捕获或者冒泡，同时阻止任何事件处理程序被调用（DOM3）</td></tr><tr><td style="text-align:left">event.stopPropagation</td><td style="text-align:left">Function</td><td style="text-align:left">只读</td><td style="text-align:left">取消事件的默认行为，如果 bubbles 是 true，则可以使用这个方法</td></tr></tbody></table><h3>target vs currnetTarget</h3><p>在事件处理程序的内部，对象的 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 this， currentTarget 和 target 包含相同的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.currentTarget === <span class="keyword">this</span> <span class="comment">// true</span></span><br><span class="line">  e.target === <span class="keyword">this</span> <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 click 事件的目标是按钮，因此这三个值是相等的，但如果事件处理程序存在于按钮的父节点中，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.target === <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>) <span class="comment">// true</span></span><br><span class="line">  e.currentTarget === <span class="built_in">document</span>.body <span class="comment">// true</span></span><br><span class="line">  <span class="keyword">this</span> === <span class="built_in">document</span>.body <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单击这个按钮时，this 和 currentTarget 都等于 document.body，因为事件处理程序是注册到这个元素上的。然而 target 元素却等于按钮元素，因为它是 click 事件的真正目标。</p><h2>IE 事件对象</h2><p>访问 IE 中的 event 对象时，如果使用 DOM0 级方法添加事件处理程序，event 对象作为 window 对象的一个属性存在。使用 attachEvent() 添加事件处理程序时，event 会作为参数传入，也可以从 window 对象中访问 event 对象，就像 DOM0 级方法一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onclick</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event</span><br><span class="line">  alert(event.type) <span class="comment">// 'click'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// attachEvent</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(event.type) <span class="comment">// 'click'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性/方法</th><th style="text-align:left">类型</th><th style="text-align:left">读写</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Event.cancelable</td><td style="text-align:left">Boolean</td><td style="text-align:left">读/写</td><td style="text-align:left">默认为 false，但将其设置为 true 就可以取消事件冒泡（与 DOM0 级的 stopPropagation()方法的作用相同）</td></tr><tr><td style="text-align:left">Event.returnValue</td><td style="text-align:left">Boolean</td><td style="text-align:left">读/写</td><td style="text-align:left">默认为 false，但将其设置为 true 就可以取消事件的默认行为（与 DOM 中的 preventDefault()方法的作用相同）</td></tr><tr><td style="text-align:left">Event.srcElement</td><td style="text-align:left">Element</td><td style="text-align:left">只读</td><td style="text-align:left">事件的目标（DOM 中的 target）</td></tr><tr><td style="text-align:left">Event.type</td><td style="text-align:left">String</td><td style="text-align:left">只读</td><td style="text-align:left">事件的类型</td></tr></tbody></table><p>事件处理程序的作用域是根据指定它的方式来确定的，所以其 this 也会有所不同，比较好的办法是用 event.srcElement。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span> <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.srcElement === <span class="keyword">this</span> <span class="comment">// false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>IE 事件中的 returnValue 相当于 DOM 中的 preventDefault() 方法，它们的作用都是取消事件的默认行为，不过这里不能确定事件的默认行为是否已经被取消。</p><p>cancelBubble 属性与 DOM 中的 stopPropagation() 方法作用相同，用来阻止事件冒泡，由于 IE 不支持事件捕获，因此只能阻止事件冒泡，而 stopPropagation() 同时可以取消事件冒泡和捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'myBtn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span> <span class="comment">// 阻止默认事件</span></span><br><span class="line">  <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span> <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>事件封装</h2><p>JavaScript 中实现事件绑定主要使用两个方法： <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">addEventListener</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent" target="_blank" rel="noopener">attachEvent</a>。</p><p>为了兼容浏览器，按照网上通用的方案对事件进行封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, eType, handle, bol</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (element.addEventListener) &#123;       <span class="comment">// 如果支持addEventListener</span></span><br><span class="line">   element.addEventListener(eType, handle, bol)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;      <span class="comment">// 如果支持attachEvent</span></span><br><span class="line">   element.attachEvent(<span class="string">'on'</span> + eType, handle)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// 否则使用兼容的onclick绑定</span></span><br><span class="line">   element[<span class="string">'on'</span> + eType] = handle</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件解绑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, eType, handle, bol</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">   element.removeEventListener(eType, handle, bol)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">   element.detachEvent(<span class="string">'on'</span> + eType, handle)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   element[<span class="string">'on'</span> + eType] = <span class="literal">null</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>阻止事件冒泡、事件捕获</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止默认事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventDefault</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.returnValue = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 阻止事件进一步传播</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">    event.stopPropagation() <span class="comment">// 阻止事件的进一步传播，包括（冒泡，捕获），无参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.cancelBubble = <span class="literal">true</span> <span class="comment">// true 为阻止冒泡</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 获取事件目标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTarget</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event.target || event.srcElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>事件流</h2><h3>事件冒泡</h3><p>HTML内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    父元素</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">      子元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#parent</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#child</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>)</span><br><span class="line"><span class="keyword">let</span> child = <span class="built_in">document</span>.getElementById(<span class="string">'child'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-body'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">parent.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-parent'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-child'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>通过 ‘addEventListener’ 方法，采用事件冒泡方式给 DOM 元素注册 click 事件，点击“子元素”，控制台依次输出 “click-child” --&gt; “click-parent” --&gt; “click-body”。</p><p>事件触发顺序是由内到外的，这就是事件冒泡，虽然只点击子元素，但是它的父元素也会触发相应的事件。</p><!DOCTYPE html><html><head><meta charset="utf-8"><title>DOM 事件</title><style>#parent{width:200px;height:200px;text-align:center;line-height:3;background:green}#child{width:100px;height:100px;margin:0 auto;background:orange}</style></head><body><div id="parent">父元素<div id="child">子元素</div></div><script type="text/javascript">let parent = document.getElementById('parent')    let child = document.getElementById('child')      document.body.addEventListener('click', function(e) {      console.log('click-body')    }, false)        parent.addEventListener('click', function(e) {      console.log('click-parent')    }, false)    child.addEventListener('click', function(e) {      console.log('click-child')    }, false)</script></body></html>（F12 打开控制台，点击查看效果）<p>如果点击子元素不想触发父元素的事件怎么办？<br>那就是停止事件传播—event.stopPropagation()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-child'</span>)</span><br><span class="line">  　e.stopPropagation()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><!DOCTYPE html><html><head><meta charset="utf-8"><title>DOM 事件</title><style>#parent2{width:200px;height:200px;text-align:center;line-height:3;background:green}#child2{width:100px;height:100px;margin:0 auto;background:orange}</style></head><body><div id="parent2">父元素<div id="child2">子元素</div></div><script type="text/javascript">let parent2 = document.getElementById('parent2')    let child2 = document.getElementById('child2')        parent2.addEventListener('click', function(e) {      console.log('click-parent')    }, false)    child2.addEventListener('click', function(e) {      console.log('click-child')      e.stopPropagation()    }, false)</script></body></html>（F12 打开控制台，点击查看效果）<h3>事件捕获</h3><p>修改上面事件冒泡的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>)</span><br><span class="line"><span class="keyword">let</span> child = <span class="built_in">document</span>.getElementById(<span class="string">'child'</span>)</span><br><span class="line"></span><br><span class="line">parent.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-parent---事件传播'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 新增事件捕获</span></span><br><span class="line">parent.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-parent--事件捕获'</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click-child'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><!DOCTYPE html><html><head><meta charset="utf-8"><title>DOM 事件</title><style>#parent3{width:200px;height:200px;text-align:center;line-height:3;background:green}#child3{width:100px;height:100px;margin:0 auto;background:orange}</style></head><body><div id="parent3">父元素<div id="child3">子元素</div></div><script type="text/javascript">let parent3 = document.getElementById('parent3')    let child3 = document.getElementById('child3')    parent3.addEventListener('click', function(e) {      console.log('click-parent---事件传播')    }, false)            // 新增事件捕获    parent3.addEventListener('click', function(e) {      console.log('click-parent--事件捕获')    }, true)    child3.addEventListener('click', function(e) {      console.log('click-child')    }, false)</script></body></html>（F12 打开控制台，点击查看效果）<p>父元素通过事件捕获的方式注册了 click 事件，所以在事件捕获阶段就会触发，然后到了目标阶段，即事件源，之后进行事件传播，parent 同时也用冒泡方式注册了 click 事件，所以这里会触发冒泡事件，最后到根节点。这就是整个事件流程。</p><h3>事件委托</h3><p>事件委托(事件代理)：利用事件冒泡的特性，将里层的事件委托给外层事件，根据 event 对象的属性进行事件委托，改善性能。<br>使用事件委托能够避免对特定的每个节点添加事件监听器；事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p><p>委托在 JQuery 中已经得到了实现，即通过 <strong>$(selector).on(event,childSelector,data,function,map)</strong> 实现委托，一般用于动态生成的元素，当然 JQuery 也是通过原生的 js 去实现的，下面举一个简单的栗子，如果要单独点击 table 里面的 td，普通做法是 for 循环给每个 td 绑定事件，td 少的话性能什么差别，td 如果多了，就不行了，我们使用事件委托:</p><p>HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"outside"</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"cursor: pointer;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table01<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table02<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table03<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table04<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table05<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table06<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table07<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table08<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table09<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>table10<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> out = <span class="built_in">document</span>.getElementById(<span class="string">'outside'</span>)</span><br><span class="line"><span class="keyword">if</span> (out.addEventListener) &#123;</span><br><span class="line">  out.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event</span><br><span class="line">    <span class="comment">// IE没有e.target，有e.srcElement</span></span><br><span class="line">    <span class="keyword">let</span> target = e.target || e.srcElement</span><br><span class="line">    <span class="comment">// 判断事件目标是否是td，是的话target即为目标节点td</span></span><br><span class="line">    <span class="keyword">if</span> (target.tagName.toLowerCase() == <span class="string">'td'</span>) &#123;</span><br><span class="line">      changeStyle(target)</span><br><span class="line">      <span class="built_in">console</span>.log(target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  out.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event</span><br><span class="line">    <span class="comment">// IE没有e.target，有e.srcElement</span></span><br><span class="line">    <span class="keyword">let</span> target = e.target || e.srcElement</span><br><span class="line">    <span class="comment">// 判断事件目标是否是td，是的话target即为目标节点td</span></span><br><span class="line">    <span class="keyword">if</span> (target.tagName.toLowerCase() == <span class="string">'td'</span>) &#123;</span><br><span class="line">      changeStyle(target)</span><br><span class="line">      <span class="built_in">console</span>.log(target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStyle</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  ele.innerHTML = <span class="string">'已点击'</span></span><br><span class="line">  ele.style.background = <span class="string">'#900'</span></span><br><span class="line">  ele.style.color = <span class="string">'#fff'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!DOCTYPE html><html><head><meta charset="utf-8"><title>DOM 事件</title></head><body><table id="outside" border="1" style="cursor:pointer"><tr><td>table01</td><td>table02</td><td>table03</td><td>table04</td><td>table05</td><td>table06</td><td>table07</td><td>table08</td><td>table09</td><td>table10</td></tr></table><script type="text/javascript">let out = document.getElementById('outside')    if (out.addEventListener) {      out.addEventListener('click', function(e) {        e = e || window.event          // IE 没有 e.target，有 e.srcElement        let target = e.target || e.srcElement          // 判断事件目标是否是td，是的话 target 即为目标节点 td        if (target.tagName.toLowerCase() == 'td') {          changeStyle(target)          console.log(target.innerHTML)        }      }, false)    } else {      out.attachEvent('onclick', function(e) {        e = e || window.event          // IE 没有 e.target，有 e.srcElement        let target = e.target || e.srcElement          // 判断事件目标是否是 td，是的话 target 即为目标节点 td        if (target.tagName.toLowerCase() == 'td') {          changeStyle(target)          console.log(target.innerHTML)        }      })    }    function changeStyle(ele) {      ele.innerHTML = '已点击'      ele.style.background = '#900'      ele.style.color = '#fff'    }</script></body></html>（点击查看效果）<h2>总结</h2><p>事件的三个阶段分别为：捕获，目标和冒泡，低版本 IE 不支持捕获。绑定事件的方法为 <strong>addEventListener</strong> 和 <strong>attachEvent</strong>。addEventListener 方法的第三个 boolean 型参数表示添加的事件为捕获或者冒泡，true 代表捕获，false 代表冒泡。</p><p>事件冒泡的优点为：</p><ol><li>可以大量节省内存占用，减少事件注册，比如在 table 上代理所有 td 的 click 事件。</li><li>可以实现为动态增加的 DOM 绑定事件的功能。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM 事件流（event flow）存在三个阶段：事件捕获 --&amp;gt; 事件目标 --&amp;gt; 事件冒泡。&lt;/p&gt;&lt;p&gt;事件捕获：当事件发生时（onclick, onmouseover……），浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。（IE10 及以下浏览器不支持捕获型事件）&lt;/p&gt;&lt;p&gt;事件冒泡：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://lz5z.com/tags/DOM/"/>
    
      <category term="HTML" scheme="https://lz5z.com/tags/HTML/"/>
    
      <category term="事件流" scheme="https://lz5z.com/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    
      <category term="事件委托/代理" scheme="https://lz5z.com/tags/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中 的 DOM 和 BOM</title>
    <link href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84DOM%E5%92%8CBOM/"/>
    <id>https://lz5z.com/JavaScript中的DOM和BOM/</id>
    <published>2016-12-24T13:23:25.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>JavaScript 与 ECMAScript 关系</h2><p>JavaScript = ECMAScript + DOM + BOM</p><p>1.ECMAScript 为 JavaScript 提供核心语言功能，是由欧洲计算机制造商协会（ECMA）39号技术委员会（TC39）制定的一种通用、跨平台、供应商中立的脚本语言和语义。ECMAScript 是一种由 ECMA 组织通过 ECMA-262 标准化的脚本程序设计语言。ECMA-262 标准没有参考 Web 浏览器，它规定了语言的语法、类型、语句、关键字、保留字、操作符、对象。</p><p>2.DOM (文档对象模型) 是针对 XML 但是经过扩展用于 HTML 的应用程序编程接口（API）。DOM 把 HTML 页面映射为一个多层节点结构，开发人员借助 DOM 提供的 API，可以轻松地删除，添加，替换或者修改节点。</p><p>3.BOM（浏览器对象模型）指的是由 Web 浏览器暴露的所有对象组成的表示模型。从根本上将 BOM 只处理浏览器窗口和框架，但是人们习惯把针对浏览器的 JavaScript 扩展也算作 BOM 的一部分，例如：浏览器弹出新窗口的功能；移动、缩放和关闭浏览器窗口的功能；navigator 对象；location 对象； screen 对象；cookies 支持；XMLHttpRequest 和 IE 的 ActiveXObject 对象。BOM 直到 HTML5 才有了规范可以遵守，在此之前每个浏览器都有自己不同的实现。</p><a id="more"></a><h3>DOM 级别</h3><p>DOM1 级由两个模块组成，DOM 核心（DOM Core）和 DOM HTML。其中，DOM Core 规定如何映射基于 XML 的文档结构，DOM HTML 模块则在 DOM Core 基础上加以扩展，添加了针对 HTML 的对象和方法。</p><p>DOM2 在原有的 DOM 基础上又扩充了鼠标和用户界面事件、范围、遍历（迭代 DOM 文档的方法）等细分模块，并且通过对象接口增加了对 CSS 的支持。DOM2 级引入的模块有：<br>- DOM 视图（DOM Views）：定义了追踪不同文档的视图接口。<br>- DOM 事件（DOM Events）：定义了事件和事件处理的接口。<br>- DOM 样式（DOM Style）：定义了基于 CSS 为元素样式的接口。<br>- DOM 遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。</p><p>DOM3 级进一步扩展 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存（DOM Load and Save）模块中定义，新增了 DOM 验证（DOM Validation）。DOM3 级也对 DOM Core 进行了扩展，开始支持 XML 1.0 规范。</p><blockquote><p>DOM0 级，DOM0 级标准本质上不存在，所谓 DOM0 只是 DOM 历史坐标中的一个参照点，具体来说，DOM0 级是指 Internet Explorer 4.0 和 Netscape Navigator 4.0 最初支持的 DHTML。</p></blockquote><p>可以通过以下代码确定浏览器是否支持 DOM 模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> supportsDOM2Core = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">'core'</span>, <span class="string">'2.0'</span>)</span><br><span class="line"><span class="keyword">var</span> supportsDOM3Core = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">'core'</span>, <span class="string">'3.0'</span>)</span><br><span class="line"><span class="keyword">var</span> supportsDOM2HTML = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">'HTML'</span>, <span class="string">'2.0'</span>)</span><br><span class="line"><span class="keyword">var</span> supportsDOM2Views = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">'Views'</span>, <span class="string">'2.0'</span>)</span><br><span class="line"><span class="keyword">var</span> supportsDOM2XML =  <span class="built_in">document</span>.implementation.hasFeature(<span class="string">'XML'</span>, <span class="string">'2.0'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;JavaScript 与 ECMAScript 关系&lt;/h2&gt;&lt;p&gt;JavaScript = ECMAScript + DOM + BOM&lt;/p&gt;&lt;p&gt;1.ECMAScript 为 JavaScript 提供核心语言功能，是由欧洲计算机制造商协会（ECMA）39号技术委员会（TC39）制定的一种通用、跨平台、供应商中立的脚本语言和语义。ECMAScript 是一种由 ECMA 组织通过 ECMA-262 标准化的脚本程序设计语言。ECMA-262 标准没有参考 Web 浏览器，它规定了语言的语法、类型、语句、关键字、保留字、操作符、对象。&lt;/p&gt;&lt;p&gt;2.DOM (文档对象模型) 是针对 XML 但是经过扩展用于 HTML 的应用程序编程接口（API）。DOM 把 HTML 页面映射为一个多层节点结构，开发人员借助 DOM 提供的 API，可以轻松地删除，添加，替换或者修改节点。&lt;/p&gt;&lt;p&gt;3.BOM（浏览器对象模型）指的是由 Web 浏览器暴露的所有对象组成的表示模型。从根本上将 BOM 只处理浏览器窗口和框架，但是人们习惯把针对浏览器的 JavaScript 扩展也算作 BOM 的一部分，例如：浏览器弹出新窗口的功能；移动、缩放和关闭浏览器窗口的功能；navigator 对象；location 对象； screen 对象；cookies 支持；XMLHttpRequest 和 IE 的 ActiveXObject 对象。BOM 直到 HTML5 才有了规范可以遵守，在此之前每个浏览器都有自己不同的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="DOM" scheme="https://lz5z.com/tags/DOM/"/>
    
      <category term="BOM" scheme="https://lz5z.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>Angular 双向绑定实现原理</title>
    <link href="https://lz5z.com/Angular%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    <id>https://lz5z.com/Angular双向绑定原理/</id>
    <published>2016-12-19T21:33:09.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>从一个 demo 讲起</h1><p>用 Angular + <a href="http://socket.io" target="_blank" rel="noopener">socket.io</a> 做了一个聊天 demo，消息通信没有问题，在 Angular 数据绑定的地方却栽了跟头：明明 model 已经发生了改变，在视图上就是看不到更新。</p><p>后来仔细研究，通过使用 “$scope.$apply()” 解决了这个问题。</p><p>之前对 Angular 数据双向绑定只有一个大概的印象，并没有深入地了解，正好趁这个机会好好学习一下数据绑定的过程。</p><a id="more"></a><h2>简化代码</h2><p>服务端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">let</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 接收事件</span></span><br><span class="line">    socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">        <span class="comment">// 发送事件</span></span><br><span class="line">        io.emit(<span class="string">'chat message'</span>, msg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listening on :3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">ng-app</span>=<span class="string">"chatApp"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Socket.IO demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-controller</span>=<span class="string">"ChatController"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">ng-repeat</span>=<span class="string">"item in chatMessage"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">ng-submit</span>=<span class="string">"submit()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">input</span> <span class="attr">id</span>=<span class="string">"m"</span> <span class="attr">ng-model</span>=<span class="string">"chatInput"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS 代码略。</p><p>JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">angular.module(<span class="string">'chatApp'</span>, [])</span><br><span class="line">    .controller(<span class="string">'ChatController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> socket = io();</span><br><span class="line">        $scope.chatMessage = [];</span><br><span class="line">        <span class="comment">// 接收事件</span></span><br><span class="line">        socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">            $scope.chatMessage.push(msg);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        $scope.submit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//发送事件</span></span><br><span class="line">            socket.emit(<span class="string">'chat message'</span>, $scope.chatInput);</span><br><span class="line">            $scope.chatInput = <span class="string">''</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;]);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Leo555/socket.io-demo" target="_blank" rel="noopener">完整demo地址</a></p><p><a href="http://socket.io" target="_blank" rel="noopener">socket.io</a> 通过 socket.emit() 发送事件，通过 socket.on() 监听事件。</p><p>上面代码似乎没有什么问题，可是运行的时候总是发生视图不更新的情况。<br>debug 发现 $scope.chatMessage 的值已经发生改变了，按理说 Angular 的 model 与 view 是双向绑定的，model 改变 view 也应该随之更新才对啊，为什么会出现这种情况呢？</p><h2>分析</h2><p>$scope.chatMessage 发生变化后，没有强制 $digest 循环，监视 chatMessage 的 $watch 没有执行，而我们自己执行一次 $apply，那么这些 $watch 就会看见这些变化，然后根据需要更新 DOM。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;从一个 demo 讲起&lt;/h1&gt;&lt;p&gt;用 Angular + &lt;a href=&quot;http://socket.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;socket.io&lt;/a&gt; 做了一个聊天 demo，消息通信没有问题，在 Angular 数据绑定的地方却栽了跟头：明明 model 已经发生了改变，在视图上就是看不到更新。&lt;/p&gt;&lt;p&gt;后来仔细研究，通过使用 “$scope.$apply()” 解决了这个问题。&lt;/p&gt;&lt;p&gt;之前对 Angular 数据双向绑定只有一个大概的印象，并没有深入地了解，正好趁这个机会好好学习一下数据绑定的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Angular" scheme="https://lz5z.com/tags/Angular/"/>
    
      <category term="socket.io" scheme="https://lz5z.com/tags/socket-io/"/>
    
      <category term="$digest" scheme="https://lz5z.com/tags/digest/"/>
    
      <category term="$apply" scheme="https://lz5z.com/tags/apply/"/>
    
      <category term="双向数据绑定" scheme="https://lz5z.com/tags/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>跨域实践</title>
    <link href="https://lz5z.com/%E8%B7%A8%E5%9F%9F%E5%AE%9E%E8%B7%B5/"/>
    <id>https://lz5z.com/跨域实践/</id>
    <published>2016-12-16T01:04:17.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>最近在 ITA 写了一个聊天机器人的 Flask 服务，自己写了一些 node 单元测试脚本跑没有问题，但是测试的同学也想覆盖到所有的 case，于是就帮忙写一个 html 页面去测试，然后就遇到了下面的问题：</p><blockquote><p>XMLHttpRequest cannot load <a href="http://localhost:8085/predict" target="_blank" rel="noopener">http://localhost:8085/predict</a>. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘null’ is therefore not allowed access.</p></blockquote><p>这个是典型的跨域问题(跨域是指：协议、域名、端口有任何一个不同，都被当做是不同的域)，想想之前也了解过跨域的知识，现在借着这个机会总结一下了。关于 GET 请求的跨域，使用 JSONP 是目前最好的解决方案，各大浏览器也基本都支持 JSONP，而 jQuery，AngularJS 等前端框架也都默认添加了对 JSONP 的封装，并且这次遇到的跨域问题是 POST 请求的，于是暂时先不写关于 JSONP 的相关知识。</p><a id="more"></a><h2>简化代码</h2><p>服务器代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">'Start server'</span>)</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># 路由</span></span><br><span class="line"><span class="meta">    @app.route('/predict', methods=['POST'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'result'</span></span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8085</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">ng-app</span>=<span class="string">"chatApp"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ajax.googleapis.com/ajax/libs/angularjs/1.6.0/angular.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"ChatController"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">ng-model</span>=<span class="string">"chat"</span> <span class="attr">placeholder</span>=<span class="string">"Enter content here"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">"onclick()"</span>&gt;</span>POST<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; result &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>– 原谅我用 Angular 做页面 ☹</p><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'chatApp'</span>, [])</span><br><span class="line">    .controller(<span class="string">'ChatController'</span>, [<span class="string">'$scope'</span>, <span class="string">'$http'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $http</span>) </span>&#123;</span><br><span class="line">        $scope.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            $http(&#123;</span><br><span class="line">                method: <span class="string">'POST'</span>,</span><br><span class="line">                url: <span class="string">'http://localhost:8085/predict'</span></span><br><span class="line">            &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                $scope.result = data;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;]);</span><br></pre></td></tr></table></figure><h2>解决方案</h2><p>要想解决跨域，必先理解跨域。那什么是跨域呢？<br>对于 web 开发来讲，由于浏览器的同源策略，我们需要经常使用一些 hack 的方法去跨域获取资源，直到 W3C 出了一个标准－<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS</a>－“跨域资源共享”（Cross-origin resource sharing），<br>它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</p><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。<br><strong>JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</strong></p><p>CORS 解决方案：</p><p>(1) 服务器代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response, request</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">'Start server'</span>)</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># post</span></span><br><span class="line"><span class="meta">    @app.route('/predict', methods=['POST'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.form.get(<span class="string">'content'</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            exp = <span class="string">'Missing content'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            exp = request.form.get(<span class="string">'content'</span>)</span><br><span class="line">        print(exp)</span><br><span class="line">        headers = &#123;<span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> Response(exp, headers=headers)</span><br><span class="line">    <span class="comment"># port=8085</span></span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8085</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>(2) main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'chatApp'</span>, [])</span><br><span class="line">    .controller(<span class="string">'ChatController'</span>, [<span class="string">'$scope'</span>, <span class="string">'$http'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $http</span>) </span>&#123;</span><br><span class="line">        $scope.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            $http(&#123;</span><br><span class="line">                method: <span class="string">'POST'</span>,</span><br><span class="line">                url: <span class="string">'http://localhost:8085/predict'</span>,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                data: <span class="string">'content= '</span> + $scope.chat</span><br><span class="line"></span><br><span class="line">            &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                $scope.result = data.data;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;]);</span><br></pre></td></tr></table></figure><p>此时再次发送 Ajax call就可以拿到结果了:</p><img src="/assets/img/cors-post.png" alt="cors-post"><p>注意到服务器端代码发生了一点改动，那就是在Response header中增加了一个参数 “Access-Control-Allow-Origin”，表示接受某域名的请求，“*” 表示允许所有的请求。<br>也可以使用确定的值，如： “<a href="http://api.abc.com" target="_blank" rel="noopener">http://api.abc.com</a>”。</p><p>于是代码中增加 <em><em>headers = {“Access-Control-Allow-Origin”: &quot;</em>&quot;}</em>* 后服务器就可以响应所有的请求了。</p><p>再看 Web 端的代码，我们在请求头里面添加了 “Content-Type”，为了能向服务端传递数据。这里使用的 “Content-Type” 为 “application/x-www-form-urlencoded” 表示以表单提交的形式传递参数。</p><p><strong>为什么要用表单的形式提交POST请求呢？</strong></p><h2>两种请求</h2><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>(1) 请求方法是以下三种方法中的一个：</p></blockquote><ul><li><strong>HEAD</strong></li><li><strong>GET</strong></li><li><strong>POST</strong><br>(2) HTTP的头信息不超出以下几种字段：</li><li><strong>Accept</strong></li><li><strong>Accept-Language</strong></li><li><strong>Content-Language</strong></li><li><strong>Last-Event-ID</strong></li><li><strong>Content-Type</strong> 其值仅限于 <strong>application/x-www-form-urlencoded、multipart/form-data、text/plain</strong></li></ul><p>上文中的请求属于简单请求。</p><h3>简单请求（simple request）</h3><p>对于简单的跨域请求，浏览器会自动在请求的头信息加上 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。</p><blockquote><p>// 请求<br>GET /cors HTTP/1.1<br>Origin: <a href="http://api.abc.com" target="_blank" rel="noopener">http://api.abc.com</a><br>Host: <a href="http://api.bcd.com" target="_blank" rel="noopener">api.bcd.com</a><br>Accept-Language: en-US<br>Connection: keep-alive<br>User-Agent: Mozilla/5.0…</p></blockquote><p>如果服务端许可本次请求，就会在返回的头信息多出关于 <strong>Access-Control</strong> 的信息，比如上述服务器返回的信息：</p><img src="/assets/img/cors-res-header.png" alt="cors-res-header"><h3>非简单请求（not-so-simple request）</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p><p>“预检”请求用的请求方法是 <strong>OPTIONS</strong>，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p><h2>非简单请求解决方案</h2><p>项目中使用的 Content-Type 为 <strong>application/json</strong>，属于非简单请求，将上述程序修改为</p><p>(1) main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'chatApp'</span>, [])</span><br><span class="line">    .controller(<span class="string">'ChatController'</span>, [<span class="string">'$scope'</span>, <span class="string">'$http'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope, $http</span>) </span>&#123;</span><br><span class="line">        $scope.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            $http(&#123;</span><br><span class="line">                method: <span class="string">'POST'</span>,</span><br><span class="line">                url: <span class="string">'http://localhost:8086/predict'</span>,</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                    <span class="string">'content'</span>: $scope.chat</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                $scope.result = data.data;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;]);</span><br></pre></td></tr></table></figure><p>服务器代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response, request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">'Start server'</span>)</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    <span class="comment"># 路由</span></span><br><span class="line"><span class="meta">    @app.route('/predict', methods=['POST', 'OPTIONS'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 返回头</span></span><br><span class="line">        headers = &#123;<span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</span><br><span class="line">                   <span class="string">"Access-Control-Allow-Headers"</span>: <span class="string">"Origin, X-Requested-With, Content-Type"</span>,</span><br><span class="line">                   <span class="string">"Access-Control-Allow-Methods"</span>: <span class="string">"POST, PUT, GET, OPTIONS, DELETE"</span>&#125;</span><br><span class="line">        <span class="comment"># preflight</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">'OPTIONS'</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(headers=headers)</span><br><span class="line">        <span class="comment"># request</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'content'</span> <span class="keyword">in</span> request.json:</span><br><span class="line">            exp = request.json.get(<span class="string">'content'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            exp = <span class="string">'Missing content'</span></span><br><span class="line">        print(exp)</span><br><span class="line">        <span class="keyword">return</span> Response(exp, headers=headers)</span><br><span class="line">    <span class="comment"># run server</span></span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8086</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>启动后发送请求，发现可以跑通，但是获取不到参数，原因是使用 <strong>application/json</strong> 的形式发送 request， 参数并没有放在 form 里面，而是放在 request.data 里面了。<br>request.data 里面为 bytes 类型的数据，通过 request.json 可以获取其 dict 类型。</p><p>通过以上方式，完美地解决了复杂请求的跨域问题。</p><p>才怪嘞！！！♋</p><h2>问题所在</h2><p>以上解决跨域的方式为 CORS，准确地说，这是一种服务器端的技术。而现实生产环境中，如果一个前端想要用这种方式实现跨域，不知道要跟后端做多少沟通，那有没有纯前端的解决方案呢？<br>且听下回分解。☛</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;最近在 ITA 写了一个聊天机器人的 Flask 服务，自己写了一些 node 单元测试脚本跑没有问题，但是测试的同学也想覆盖到所有的 case，于是就帮忙写一个 html 页面去测试，然后就遇到了下面的问题：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;XMLHttpRequest cannot load &lt;a href=&quot;http://localhost:8085/predict&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost:8085/predict&lt;/a&gt;. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘null’ is therefore not allowed access.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个是典型的跨域问题(跨域是指：协议、域名、端口有任何一个不同，都被当做是不同的域)，想想之前也了解过跨域的知识，现在借着这个机会总结一下了。关于 GET 请求的跨域，使用 JSONP 是目前最好的解决方案，各大浏览器也基本都支持 JSONP，而 jQuery，AngularJS 等前端框架也都默认添加了对 JSONP 的封装，并且这次遇到的跨域问题是 POST 请求的，于是暂时先不写关于 JSONP 的相关知识。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="HTTP" scheme="https://lz5z.com/tags/HTTP/"/>
    
      <category term="Flask" scheme="https://lz5z.com/tags/Flask/"/>
    
      <category term="CORS" scheme="https://lz5z.com/tags/CORS/"/>
    
      <category term="跨域" scheme="https://lz5z.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Pandas 数据处理学习</title>
    <link href="https://lz5z.com/Pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lz5z.com/Pandas数据处理学习/</id>
    <published>2016-12-07T21:07:46.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>10分钟 Pandas 入门</h1><p>Pandas 是 Python 做数据分析最重要的模块之一，本文源自Pandas 作者 Wes McKinney 写的 <a href="http://pandas.pydata.org/pandas-docs/stable/10min.html" target="_blank" rel="noopener">10-minute tour of pandas</a>。</p><p>首先安装 Pandas 和相关的两个包 numpy、matplotlib</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br><span class="line">pip install numpy</span><br><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><p>导入 pandas、numpy、matplotlib</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2>对象创建</h2><p>Series 是一个序列，使用 Pandas 创建一个整数索引的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,np.nan,<span class="number">6</span>,<span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">8.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>DataFrame 是有多个列的数据表，每个列拥有一个 label，当然，DataFrame 也有索引:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates = pd.date_range(<span class="string">'20170101'</span>, periods=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates</span><br><span class="line">DatetimeIndex([<span class="string">'2017-01-01'</span>, <span class="string">'2017-01-02'</span>, <span class="string">'2017-01-03'</span>, <span class="string">'2017-01-04'</span>,</span><br><span class="line">               <span class="string">'2017-01-05'</span>, <span class="string">'2017-01-06'</span>],</span><br><span class="line">              dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="string">'D'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>), index=dates, columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&gt;&gt;&gt; df.shape</span><br><span class="line">(<span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span>  <span class="number">1.265863</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span>  <span class="number">1.522392</span>  <span class="number">1.129707</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span>  <span class="number">0.078448</span>  <span class="number">0.217550</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span> <span class="number">-0.951364</span>  <span class="number">0.362032</span></span><br></pre></td></tr></table></figure><p>通过一个对象字典创建 DataFrame， dict 的每个 value 会被转化成一个 Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2 = pd.DataFrame(&#123; <span class="string">'A'</span> : <span class="number">1.</span>, </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20170102'</span>), </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>), </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>), </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]), </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="string">'F'</span> : <span class="string">'foo'</span> &#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">     A          B    C  D      E    F</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>   test  foo</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>  train  foo</span><br><span class="line"><span class="number">2</span>  <span class="number">1.0</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>   test  foo</span><br><span class="line"><span class="number">3</span>  <span class="number">1.0</span> <span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>  train  foo</span><br></pre></td></tr></table></figure><p>查看每列的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2.dtypes</span><br><span class="line">A           float64</span><br><span class="line">B    datetime64[ns]</span><br><span class="line">C           float32</span><br><span class="line">D             int32</span><br><span class="line">E          category</span><br><span class="line">F            object</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>查看某一列的具体值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2.C</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">1.0</span></span><br><span class="line">Name: C, dtype: float32</span><br></pre></td></tr></table></figure><h2>查看数据</h2><p>使用 head() 查看 DataFrame 前几行； tail() 查看后几行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.head(<span class="number">3</span>)</span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span>  <span class="number">1.265863</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.tail(<span class="number">3</span>)</span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span>  <span class="number">1.522392</span>  <span class="number">1.129707</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span>  <span class="number">0.078448</span>  <span class="number">0.217550</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span> <span class="number">-0.951364</span>  <span class="number">0.362032</span></span><br></pre></td></tr></table></figure><p>实际上，DataFrame 内部用 numpy 格式存储数据。你也可以单独查看 index、columns 和 values：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.index</span><br><span class="line">DatetimeIndex([<span class="string">'2017-01-01'</span>, <span class="string">'2017-01-02'</span>, <span class="string">'2017-01-03'</span>, <span class="string">'2017-01-04'</span>,</span><br><span class="line">               <span class="string">'2017-01-05'</span>, <span class="string">'2017-01-06'</span>],</span><br><span class="line">              dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="string">'D'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.columns</span><br><span class="line">Index([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>], dtype=<span class="string">'object'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.values</span><br><span class="line">array([[ <span class="number">0.14707226</span>,  <span class="number">1.23522557</span>,  <span class="number">0.14395236</span>,  <span class="number">0.83141137</span>],</span><br><span class="line">       [ <span class="number">0.86229302</span>, <span class="number">-0.72510256</span>, <span class="number">-0.10466379</span>,  <span class="number">1.26586314</span>],</span><br><span class="line">       [ <span class="number">0.28151127</span>,  <span class="number">0.95686785</span>, <span class="number">-0.74119266</span>,  <span class="number">0.12907115</span>],</span><br><span class="line">       [<span class="number">-0.66447533</span>,  <span class="number">0.96565318</span>,  <span class="number">1.52239163</span>,  <span class="number">1.12970702</span>],</span><br><span class="line">       [<span class="number">-1.36453175</span>, <span class="number">-0.16787707</span>,  <span class="number">0.07844812</span>,  <span class="number">0.21755034</span>],</span><br><span class="line">       [ <span class="number">0.71772123</span>,  <span class="number">0.34473429</span>, <span class="number">-0.95136372</span>,  <span class="number">0.36203183</span>]])</span><br></pre></td></tr></table></figure><p>使用 describe() 可以帮你做一些数据的概要</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.describe()</span><br><span class="line">              A         B         C         D</span><br><span class="line">count  <span class="number">6.000000</span>  <span class="number">6.000000</span>  <span class="number">6.000000</span>  <span class="number">6.000000</span></span><br><span class="line">mean  <span class="number">-0.003402</span>  <span class="number">0.434917</span> <span class="number">-0.008738</span>  <span class="number">0.655939</span></span><br><span class="line">std    <span class="number">0.855916</span>  <span class="number">0.763118</span>  <span class="number">0.872870</span>  <span class="number">0.486500</span></span><br><span class="line">min   <span class="number">-1.364532</span> <span class="number">-0.725103</span> <span class="number">-0.951364</span>  <span class="number">0.129071</span></span><br><span class="line"><span class="number">25</span>%   <span class="number">-0.461588</span> <span class="number">-0.039724</span> <span class="number">-0.582060</span>  <span class="number">0.253671</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">0.214292</span>  <span class="number">0.650801</span> <span class="number">-0.013108</span>  <span class="number">0.596722</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">0.608669</span>  <span class="number">0.963457</span>  <span class="number">0.127576</span>  <span class="number">1.055133</span></span><br><span class="line">max    <span class="number">0.862293</span>  <span class="number">1.235226</span>  <span class="number">1.522392</span>  <span class="number">1.265863</span></span><br></pre></td></tr></table></figure><p>DataFrame 的矩阵转置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.T</span><br></pre></td></tr></table></figure><p>DataFrame 排序</p><p>（1） 使用 sort_index 按照索引排序<br>ascending 参数默认值为 True<br>axis = 0 指的是安装行排序，axis = 1 是指安装列排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>（2） 使用 sort_values 按照值排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.sort_values(by=<span class="string">'B'</span>, ascending=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h2>选择</h2><h3>行/列</h3><p>选择单独的列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'A'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.A</span><br></pre></td></tr></table></figure><p>切片，使用[]选择特定的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span>  <span class="number">1.265863</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span></span><br></pre></td></tr></table></figure><h3>通过 label 选择</h3><p>通过 label 选择(dates[0]=Timestamp(‘2017-01-01 00:00:00’, offset=‘D’))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[dates[<span class="number">0</span>]]</span><br><span class="line">A    <span class="number">0.147072</span></span><br><span class="line">B    <span class="number">1.235226</span></span><br><span class="line">C    <span class="number">0.143952</span></span><br><span class="line">D    <span class="number">0.831411</span></span><br></pre></td></tr></table></figure><p>多选，「A：B」 表示从 A 到 B</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="string">'20170102'</span>:<span class="string">'20170104'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="string">'20170102'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line">A    <span class="number">0.862293</span></span><br><span class="line">B   <span class="number">-0.725103</span></span><br><span class="line">Name: <span class="number">2017</span><span class="number">-01</span><span class="number">-02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>, dtype: float64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.at[dates[<span class="number">0</span>],<span class="string">'A'</span>]</span><br><span class="line"><span class="number">0.14707225966646126</span></span><br></pre></td></tr></table></figure><h3>通过下标选择</h3><p>选择第四行所有元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">3</span>]</span><br><span class="line">A   <span class="number">-0.664475</span></span><br><span class="line">B    <span class="number">0.965653</span></span><br><span class="line">C    <span class="number">1.522392</span></span><br><span class="line">D    <span class="number">1.129707</span></span><br></pre></td></tr></table></figure><p>选出3<sub>4行，0</sub>1列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">3</span>:<span class="number">5</span>,<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span></span><br></pre></td></tr></table></figure><p>选择单个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iloc[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iat[<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3>比较运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[df.A &gt; <span class="number">0</span>]</span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span>  <span class="number">1.265863</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span> <span class="number">-0.951364</span>  <span class="number">0.362032</span></span><br></pre></td></tr></table></figure><p>选出大于0 的全部元素，没有填充的值等于 NaN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[df &gt; <span class="number">0</span>]</span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span>       NaN       NaN  <span class="number">1.265863</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span>       NaN  <span class="number">0.129071</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>       NaN  <span class="number">0.965653</span>  <span class="number">1.522392</span>  <span class="number">1.129707</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>       NaN       NaN  <span class="number">0.078448</span>  <span class="number">0.217550</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span>       NaN  <span class="number">0.362032</span></span><br></pre></td></tr></table></figure><p>isin() 函数：是否在集合中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2 = df.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2[<span class="string">'E'</span>] = [<span class="string">'one'</span>, <span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>,<span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">                   A         B         C         D      E</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span>    one</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span>  <span class="number">1.265863</span>    one</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span>    two</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span>  <span class="number">1.522392</span>  <span class="number">1.129707</span>  three</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span>  <span class="number">0.078448</span>  <span class="number">0.217550</span>   four</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span> <span class="number">-0.951364</span>  <span class="number">0.362032</span>  three</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2[df2[<span class="string">'E'</span>].isin([<span class="string">'two'</span>,<span class="string">'four'</span>])]</span><br><span class="line">                   A         B         C         D     E</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span>   two</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span>  <span class="number">0.078448</span>  <span class="number">0.217550</span>  four</span><br></pre></td></tr></table></figure><h3>设置</h3><p>按照 index 给 DataFrame 添加新的列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], index=pd.date_range(<span class="string">'20170102'</span>, periods=<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-07</span>    <span class="number">6</span></span><br><span class="line">Freq: D, dtype: int64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'F'</span>] = s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">                   A         B         C         D    F</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.147072</span>  <span class="number">1.235226</span>  <span class="number">0.143952</span>  <span class="number">0.831411</span>  NaN</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span>  <span class="number">1.265863</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">0.281511</span>  <span class="number">0.956868</span> <span class="number">-0.741193</span>  <span class="number">0.129071</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span>  <span class="number">0.965653</span>  <span class="number">1.522392</span>  <span class="number">1.129707</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span>  <span class="number">0.078448</span>  <span class="number">0.217550</span>  <span class="number">4.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.717721</span>  <span class="number">0.344734</span> <span class="number">-0.951364</span>  <span class="number">0.362032</span>  <span class="number">5.0</span></span><br></pre></td></tr></table></figure><p>通过 label 设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.at[dates[<span class="number">0</span>],<span class="string">'A'</span>] = <span class="number">0</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'A'</span>]</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>    <span class="number">0.000000</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>    <span class="number">0.862293</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>    <span class="number">0.281511</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>   <span class="number">-0.664475</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>   <span class="number">-1.364532</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>    <span class="number">0.717721</span></span><br></pre></td></tr></table></figure><p>通过下标设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.iat[<span class="number">0</span>,<span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>用 numpy 数组设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[:,<span class="string">'D'</span>] = np.array([<span class="number">5</span>] * len(df))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.D</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span>    <span class="number">5</span></span><br></pre></td></tr></table></figure><p>使用比较设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2 = df.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2[df2 &gt; <span class="number">0</span>] = -df2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">                   A         B         C  D    F</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.000000</span> <span class="number">-1.000000</span> <span class="number">-0.143952</span> <span class="number">-5</span>  NaN</span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-02</span> <span class="number">-0.862293</span> <span class="number">-0.725103</span> <span class="number">-0.104664</span> <span class="number">-5</span> <span class="number">-1.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.281511</span> <span class="number">-0.956868</span> <span class="number">-0.741193</span> <span class="number">-5</span> <span class="number">-2.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-04</span> <span class="number">-0.664475</span> <span class="number">-0.965653</span> <span class="number">-1.522392</span> <span class="number">-5</span> <span class="number">-3.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.364532</span> <span class="number">-0.167877</span> <span class="number">-0.078448</span> <span class="number">-5</span> <span class="number">-4.0</span></span><br><span class="line"><span class="number">2017</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.717721</span> <span class="number">-0.344734</span> <span class="number">-0.951364</span> <span class="number">-5</span> <span class="number">-5.0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;10分钟 Pandas 入门&lt;/h1&gt;&lt;p&gt;Pandas 是 Python 做数据分析最重要的模块之一，本文源自Pandas 作者 Wes McKinney 写的 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/10min.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;10-minute tour of pandas&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;首先安装 Pandas 和相关的两个包 numpy、matplotlib&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lz5z.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="Pandas" scheme="https://lz5z.com/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 JavaScript——继承</title>
    <link href="https://lz5z.com/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <id>https://lz5z.com/JavaScript继承/</id>
    <published>2016-12-05T23:50:08.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>继承</h1><p>继承是面向对象语言中最重要的概念之一，许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于 ECMAScript 中没有方法签名，所以不能实现接口继承，而是通过原型链的方式完成实现继承。</p><h2>原型链</h2><p>每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而所有实例中都包含一个指向原型对象的内部指针。下面是一个实现原型链的基本方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subProperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subProperty</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上述代码定义了 SuperType 和 SubType 两种类型，每个类型分别有一个属性和一个方法，SubType 通过改写原型对象的方式实现对 SuperType 的继承。原来存在于 SuperType 中的属性和方法，现在也存在于 SubType.prototype 中。在确立了继承关系后，我们给 SubType.prototype 又添加了一个新方法，这个例子中的关系图如下：</p><img src="/assets/img/js_inherit.png" alt="js_inherit"><p>在上述代码中，我们修改 SubType 默认的原型为 SuperType 的实例，新原型不仅具有作为一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了 SuperType 的原型。最终的结果是这样的：instance 指向了 SubType 的原型，SubType 的原型又指向了 SuperType 的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance.__proto__ === SubType.prototype <span class="comment">// true</span></span><br><span class="line">SubType.prototype.__proto__ === SuperType.prototype <span class="comment">//true</span></span><br><span class="line">instance.__proto__.__proto__ === SuperType.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;继承&lt;/h1&gt;&lt;p&gt;继承是面向对象语言中最重要的概念之一，许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于 ECMAScript 中没有方法签名，所以不能实现接口继承，而是通过原型链的方式完成实现继承。&lt;/p
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="https://lz5z.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Object-Oriented" scheme="https://lz5z.com/tags/Object-Oriented/"/>
    
      <category term="继承" scheme="https://lz5z.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 JavaScript——理解原型</title>
    <link href="https://lz5z.com/JavaScript-prototype/"/>
    <id>https://lz5z.com/JavaScript-prototype/</id>
    <published>2016-12-02T13:21:53.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2>理解原型对象</h2><p>在 JavaScript 中，只要创建了新函数，都会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获取一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.constructor === Person</span><br></pre></td></tr></table></figure><p>通过 constructor，我们可以继续为原型对象添加其他属性和方法。</p><p>创建自定义的构造函数之后，其原型对象默认只会取得 constructor 属性，其它属性和方法都是从 Object 继承而来的。</p><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（[[Prototype]]），指向构造函数的原型对象，该指针在常用的浏览器中被定义为 <code>__proto__</code>。需要说明的一点是，该连接存在于实例和构造函数的原型对象之间，而不是存在于原型和构造函数之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Person()</span><br><span class="line">leo.__proto__ === Person.prototype</span><br></pre></td></tr></table></figure><a id="more"></a><h3>关系</h3><p>构造函数，实例，prototype，<code>__proto__</code> 之间的关系可以理解为下图：</p><img src="/assets/img/js_prototype.png" alt="js_prototype"><p>注意：<code>__proto__</code> 并非 JS 标准属性，而是浏览器的实现。</p><p>从图中可以看出构造函数 Person 和实例 leo 之间并没有直接关系，而是通过 Person.prototype 原型对象进行关联。虽然实例中并不包含属性和方法，但是可以通过调用 <code>leo.sayName</code> 进行调用。在非浏览器环境或者浏览器不支持 <code>__proto__</code> 的环境中，我们可以通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(leo) <span class="comment">// true</span></span><br><span class="line">leo.__proto__ === Person.prototype <span class="comment">// 一些浏览器可能不支持</span></span><br></pre></td></tr></table></figure><p>ECMAScript5 中增加了 Object.getPrototypeOf() 方法，该方法返回 [[Prototype]] 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(leo) === Person.prototype</span><br></pre></td></tr></table></figure><p>每当代码读取某个对象的属性时，都会执行一次搜索：首先判断实例是否具有给定名字的属性，如果没有的话，继续搜索实例的原型对象。</p><p>原型对象中的属性对于实例来说是只读的，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'JavaScript'</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.name = <span class="string">'CSS'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// CSS</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name) <span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">delete</span> p1.name</span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// JavaScript</span></span><br></pre></td></tr></table></figure><h3>hasOwnProperty() 与 in 操作符</h3><p>hasOwnProperty 可以检测一个属性是存在于实例中，还是存在于原型对象中，这个方法继承自 Object 对象；无论属性存在于实例中还是原型中，使用 in 操作符都能得到 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'JavaScript'</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p1) <span class="comment">// true</span></span><br><span class="line">p1.name = <span class="string">'nobody'</span></span><br><span class="line">p1.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注：ES5 中 Object.getOwnpropertyDescriptor() 方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnpropertyDescriptor()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(p1, <span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  configurable: true</span></span><br><span class="line"><span class="comment">//  enumerable: true</span></span><br><span class="line"><span class="comment">//  value: "nobody"</span></span><br><span class="line"><span class="comment">//  writable:true</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p>要取得对象上所有的可枚举的实例属性，可以使用 Object.keys() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'JavaScript'</span></span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Person.prototype) <span class="comment">// ["name", "age", "sayName"]</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">Object</span>.keys(p1) <span class="comment">// []</span></span><br><span class="line">p1.name = <span class="string">'JavaScript'</span></span><br><span class="line"><span class="built_in">Object</span>.keys(p1) <span class="comment">// ["name"]</span></span><br></pre></td></tr></table></figure><p>可以看出，Object.keys() 方法只枚举实例属性，并不枚举原型对象中的属性，而且 constructor 属性也是不可枚举的。</p><h3>更简单的原型语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'JavaScript',</span><br><span class="line">  age: 18,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法存在一个问题，就是重设的 constructor 属性的 [[Enumerable]] 特性被设置为 true，默认情况下，原生的 constructor 属性是不可枚举的。所以可以写成如下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'JavaScript'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.definedProperty(Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3>原型的动态性</h3><p>在修改原型的过程中，我们可以随时为原型添加属性和方法，但是如果重写整个原型对象，那有可能切断构造函数与原型之间的联系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'JavaScript',</span><br><span class="line">  age: 18,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br><span class="line">p1.sayName() <span class="comment">// p1.sayName is not a function</span></span><br></pre></td></tr></table></figure><p>为什么在调用 p1.sayName() 的时候会发生错误呢，因为 p1 指向的原型对象中并不包含 sayName 方法。</p><p>其关系可看下图：</p><img src="/assets/img/js_prototype_new.png" alt="js_prototype_new"><p>重写原型对象后，切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的任然是最初的原型。</p><h3>原型对象的缺点</h3><p>原型对象省略了为构造函数传递参数这一环节，使得所有实例在默认情况下都取得相同的属性值，而且原型中所有的属性是被全部实例共享的，这种共享对于函数来说非常合适，但是对于属性值，尤其是引用类型的属性值来说，问题就比较严重了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'JavaScript',</span><br><span class="line">  age: 18,</span><br><span class="line">  friends: ['Lily', 'Tony'],</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.friends.push(<span class="string">'Jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p2.friends) <span class="comment">// ["Lily", "Tony", "Jack"]</span></span><br><span class="line">p1.friends === p2.friends <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>修改实例 p1 的值的过程中，p2 的值也被修改了。这就导致了仅仅使用原型模式创建对象存在很大的问题。具体解决请查看<a href="https://lz5z.com/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">深入学习JavaScript——面向对象</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;理解原型对象&lt;/h2&gt;&lt;p&gt;在 JavaScript 中，只要创建了新函数，都会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。默认情况下，所有原型对象都会自动获取一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。比如：&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.constructor === Person&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;通过 constructor，我们可以继续为原型对象添加其他属性和方法。&lt;/p&gt;&lt;p&gt;创建自定义的构造函数之后，其原型对象默认只会取得 constructor 属性，其它属性和方法都是从 Object 继承而来的。&lt;/p&gt;&lt;p&gt;当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（[[Prototype]]），指向构造函数的原型对象，该指针在常用的浏览器中被定义为 &lt;code&gt;__proto__&lt;/code&gt;。需要说明的一点是，该连接存在于实例和构造函数的原型对象之间，而不是存在于原型和构造函数之间。&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; leo = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;leo.__proto__ === Person.prototype&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="prototype" scheme="https://lz5z.com/tags/prototype/"/>
    
      <category term="原型" scheme="https://lz5z.com/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 JavaScript——面向对象</title>
    <link href="https://lz5z.com/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lz5z.com/JavaScript面向对象/</id>
    <published>2016-12-01T18:14:29.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>JavaScript 面向对象</h1><p>几乎所有面向对象的语言都有一个标志，那就是类，通过类创建具有相同属性和方法的对象。而 ECMAScript 中没有类的概念，它把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。即对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而这个名字都映射到一个值。因此对象的本质是一个<a href="https://lz5z.com/JavaScript-Object-Hash/">散列表</a>。</p><a id="more"></a><h1>创建对象</h1><p>虽然 Object 构造函数或对象字面量都可以创建单个对象，但是这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。为了解决这个问题，就可以使用工厂模式来创建对象。</p><h2>工厂模式</h2><p>工厂模式用函数来封装特定接口创建对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.job = job</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = createPerson(<span class="string">'Leo'</span>, <span class="number">18</span>, <span class="string">"Engineer"</span>)</span><br></pre></td></tr></table></figure><p>工厂模式虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型）。</p><h2>构造函数模式</h2><p>ECMAScript 中的构造函数可以用来创建特定类型的对象，像 Object 和 Array 的原生的构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Person(<span class="string">'Leo'</span>, <span class="number">18</span>, <span class="string">"Engineer"</span>)</span><br><span class="line"><span class="keyword">let</span> jack = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">18</span>, <span class="string">"Engineer"</span>)</span><br></pre></td></tr></table></figure><p>构造函数模式与工厂模式有以下不同：</p><ol><li>没有显式的创建对象；</li><li>直接将属性和方法赋给了this对象；</li><li>没有return语句；</li></ol><p>构造函数应该以大写字母开头，使用 new 操作符。new 操作符创建对象经历以下 4 个步骤：</p><ol><li>创建新的对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象；</li></ol><p>生成的对象 leo 中有一个 constructor 属性，该属性指向 Person，并且可以用 instanceof 做类型检测。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leo.constructor === Person <span class="comment">// true</span></span><br><span class="line">leo <span class="keyword">instanceof</span>  <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">leo <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>构造函数的缺点在于每个方法都要在每个实例上重新创建一遍。在前面例子中，leo 和 jack 都有一个名为 sayName 的方法，但是这两个方法不属于同一个对象。</p><p>那么我们能不能共享一个 sayName() 方法。如果想要完成这种需求，大可像下面代码一样，通过把函数定义转移到构造函数的外部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Person(<span class="string">'Leo'</span>, <span class="number">18</span>, <span class="string">"Engineer"</span>)</span><br><span class="line"><span class="keyword">let</span> jack = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">18</span>, <span class="string">"Engineer"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(leo.sayName === jack.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面例子中的做法，确实解决了两个函数做同一件事的问题，但是无意中定义了很多全局函数，而这些全局函数中由于包含 “this” 关键字，又只能被某个函数调用。不仅污染了全局作用域，还使得这个自定义的引用类型完全丧失封装性。好在这些问题都可以通过原型模式解决。</p><h2>原型模式</h2><p>JavaScript 中创建的每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的 <strong>所有实例共享的属性和方法</strong>。prototype是通过调用构造函数而创建的那个对象实例的对象原型，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Leo'</span></span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo1 = <span class="keyword">new</span> Person</span><br><span class="line"><span class="keyword">let</span> leo2 = <span class="keyword">new</span> Person</span><br><span class="line">leo1.sayName()</span><br><span class="line">leo2.sayName()</span><br></pre></td></tr></table></figure><p>在此，我们将 sayName() 方法和所有的属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数，而通过 new 创建出来的对象具有相同的属性和方法。但是与构造函数模式不同对的是，新对象的这些属性和方法是由所有的实例共享的，也就是说</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leo1.sayName === leo2.sayName <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2>组合使用构造函数模式和原型模式</h2><p>创建自定义对象最常见的形式就是组合使用构造函数模式和原型模式，构造函数用于定义类的实例属性，而原型模式用于定义对象的共享属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.friends = []</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Person(<span class="string">'Leo'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> jack = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line">leo.friends.push(<span class="string">'Elsa'</span>)</span><br><span class="line">jack.friends.push(<span class="string">'Lucy'</span>)</span><br><span class="line">leo.sayName === jack.sayName <span class="comment">// true</span></span><br><span class="line">jack.friends === leo.friends <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实例属性都是在构造函数中定义的，而实例共享属性 constructor 和方法 sayName() 则是在原型中定义的。这种构造函数与原型混成的模式，是目前 ECMAScript 中使用最广泛、认同度最高的一种创建自定义对象的方法。</p><h2>动态原型模式</h2><p>动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Person(<span class="string">'Leo'</span>, <span class="number">18</span>)</span><br><span class="line">leo.sayName()</span><br></pre></td></tr></table></figure><p>Person 是一个构造函数，通过 new Person() 来生成实例对象。每当一个 Person 的对象生成时，Person 内部的代码都会被调用一次。</p><p>如果去掉 if 的话，你每 new 一次(即每当一个实例对象生产时)，都会重新定义一个新的函数，然后挂到 Person.prototype.sayName 属性上。而实际上，你只需要定义一次就够了，因为所有实例都会共享此属性的。而加上 if 后，只在 new 第一个实例时才会定义 sayName 方法，之后就不会了。</p><p>假设除了sayName 方法外，你还定义了很多其他方法，比如 sayBye、cry、smile 等等。此时你只需要把它们都放到对 sayName 判断的 if 块里面就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line">    Person.prototype.sayBye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line">    Person.prototype.cry = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，要么它们全都还没有定义(new 第一个实例时)，要么已经全都定义了(new 其他实例后)，即它们的存在性是一致的，用同一个判断就可以了，而不需要分别对它们进行判断。</p><p>使用动图原型模式时，不能使用对象字面量重写原型，如果在已经创建实例的情况下重写原型，会切断现有实例和原型之间的联系。</p><h2>寄生构造函数模式</h2><p>寄生构造函数的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Person(<span class="string">'Leo'</span>, <span class="number">18</span>)</span><br><span class="line">leo.sayName()</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后返回这个对象。除了使用 new 操作符并把使用的包装函数叫做构造函数外，这个模式跟工厂模式一模一样。构造函数在不返回值的情况下，默认会返回新的对象实例。</p><p>这个模式在特殊的情况下可以用来为对象创建构造函数。假如我们想创建一个具有额外方法的特殊数组，由于不能直接修改 Array 的构造函数，因此可以使用这种模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>)</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()) <span class="comment">// 'red|blue|green'</span></span><br></pre></td></tr></table></figure><p>关于寄生构造函数模式，有一点需要说明：返回的对象与构造函数或者构造函数的原型属性直接没有关系，所以不能依赖 instanceof 操作符来确定对象类型。</p><h2>稳妥构造函数模式</h2><p>稳妥对象，是指没有公共属性，而且方法也不引用 this 的对象，适合在一些安全环境中（禁用 this 和 new），或者在防止数据被其它应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但是有两点不同：一是新创建对象的实例方法不引用 this，二是不使用 new 操作符调用构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> leo = Person(<span class="string">'Leo'</span>, <span class="number">18</span>)</span><br><span class="line">leo.sayName()</span><br></pre></td></tr></table></figure><p>注意在这种模式创建的对象中，除了使用 sayName 方法之外，没有其他办法访问 name 属性，即使有其他代码给这个对象添加属性或者方法，也不可能有别的办法访问传入到构造函数中的原始数据。</p><p>与寄生构造函数类似，稳妥构造函数模式创建的对象与构造函数直接也没有什么关系，所以不能依赖 instanceof 操作符来确定对象类型。</p><h1>总结</h1><p>组合使用构造函数模式和原型模式是目前使用最广的方法，如果不希望构造函数和原型相互分离的话，可以使用动态原型模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;JavaScript 面向对象&lt;/h1&gt;&lt;p&gt;几乎所有面向对象的语言都有一个标志，那就是类，通过类创建具有相同属性和方法的对象。而 ECMAScript 中没有类的概念，它把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。即对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而这个名字都映射到一个值。因此对象的本质是一个&lt;a href=&quot;https://lz5z.com/JavaScript-Object-Hash/&quot;&gt;散列表&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="https://lz5z.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Object-Oriented" scheme="https://lz5z.com/tags/Object-Oriented/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 对象与 Hash 表</title>
    <link href="https://lz5z.com/JavaScript-Object-Hash/"/>
    <id>https://lz5z.com/JavaScript-Object-Hash/</id>
    <published>2016-12-01T10:02:04.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>哈希表(Hash table，也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>JavaScript 中的对象也是以 Key-Value 的形式访问，那么 JavaScript 的对象是否以 Hash 的结构存储呢？</p><p>我们首先来看一下 Hash 表结构。</p><a id="more"></a><h2>Hash 表结构</h2><p>数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易，Hash 表综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构。</p><p>下图是最常见的 <strong>拉链法</strong> 做出的 Hash 表</p><img src="/assets/img/hash.jpg" alt="hash"><p>左边是一个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p><p>元素特征转变为数组下标的方法就是散列法。上图运用的方法为 <strong>整除法</strong>，公式为：</p><blockquote><p>index = value % 16</p></blockquote><p>hash表的工作原理：</p><ol><li>第一步 先根据给定的key和散列算法得到具体的散列值，也就是对应的数组下标。</li><li>第二步，根据数组下标得到此下标里存储的指针，若指针为空，则不存在这样的键值对，否则根据此指针得到此链式数组。</li><li>遍历此链式数组，分别取出Key与给定的Key比较，若找到与给定key相等的Key，即在此hash表中存在此要查找的&lt;Key,Value&gt;键值对，此后便可以对此键值对进行相关操作；若找不到，即为不存在此键值对。</li></ol><h1>JavaScript 对象存储形式</h1><h2>JavaScript 对象 Key 存储形式</h2><p>在我们创建或者访问对象属性的时候，如果使用 <strong>对象.属性名</strong> 的方式，属性名只能为字符串类型，而且不能以数字开头：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj<span class="number">.2</span> = <span class="number">2</span>;  <span class="comment">//Uncaught SyntaxError: Unexpected number</span></span><br><span class="line">obj<span class="number">.12</span>s = <span class="string">'12s'</span>;  <span class="comment">//Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure><p>而使用字面量的形式创建对象，或者用 <strong>对象[属性名]</strong> 的方法，却没有这样的限制:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">    o: <span class="string">'object'</span>,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Leo'</span>&#125;: <span class="string">'object'</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="string">'12s'</span>] = <span class="string">'12s'</span>;</span><br><span class="line">obj[&#123;<span class="attr">name</span>: <span class="string">'Leo'</span>&#125;] = <span class="string">'object'</span>; <span class="comment">//使用 对象[属性名] 的方式甚至可以把对象当做属性名传入</span></span><br></pre></td></tr></table></figure><p>此时 obj 里面的属性 <strong>2</strong> 是一个整数吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> i, i, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// string 2 2</span></span><br><span class="line"><span class="comment">// string x 1</span></span><br><span class="line"><span class="comment">// string o object</span></span><br><span class="line"><span class="comment">// string 12s 12s</span></span><br><span class="line"><span class="comment">// string [object Object] object</span></span><br></pre></td></tr></table></figure><p>由此可见 JavaScript 中对象的 Key 均是 string 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">2</span>] === obj[<span class="string">'2'</span>]);  <span class="comment">// true</span></span><br><span class="line">object[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(object[<span class="string">'2'</span>]);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>可见解释器在访问 object[2] 的时候，先将方括号里面的 2 转换成字符串，然后再访问。</p><p>而使用 obj[{name: ‘Leo’}] = ‘object’ 的时候，也是同样的，解释器先调用 Objcet.toString 方法把对象 {name: ‘Leo’} 转换成字符串，然后再访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object[&#123;<span class="attr">name</span>: <span class="string">'Leo'</span>&#125;]);　　<span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上述的 <strong>object[{name: ‘Leo’}]</strong> 相当于 <strong>object[{name: ‘Leo’}.toString()]</strong> 亦相当于 <strong>object[‘2’]</strong>，于是就得到结果 2。</p><p>这里也间接证明了 JavaScript 对象中，所有的 key 都是字符串，即使你访问的时候不是字符串的形式，解释器也会先将其转化为字符串。</p><p>可是我们知道整数值直接调用 toString 方法是会报错的，因为 JavaScript 解析器会试图将点操作符解析为浮点数字面值的一部分。不过有很多变通方法可以让数字的字面值看起来像对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString() <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="comment">//解决方案</span></span><br><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure><p>所以 JavaScript 解释器应该有帮我们做这一部分工作。</p><h2>JavaScript 对象 Value 存储形式</h2><p>在JavaScript高级程序设计（第三版）中，是这么描述属性的：属性在创建时都带有一些特征值，JavaScript引擎通过这些特征值来定义他们的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">'Leo'</span>;</span><br><span class="line"><span class="keyword">var</span> descriptor=<span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor); </span><br><span class="line"><span class="comment">//Object</span></span><br><span class="line"><span class="comment">// configurable: true</span></span><br><span class="line"><span class="comment">// enumerable: true</span></span><br><span class="line"><span class="comment">// value: "Leo"</span></span><br><span class="line"><span class="comment">// writable: true</span></span><br><span class="line"><span class="comment">// __proto__: Object</span></span><br></pre></td></tr></table></figure><p>可见 value 的数据类型是结构体。</p><h2>JavaScript 对象存储形式</h2><p>在 JavaScript 中，我们可以任意给对象添加或者删除属性，由此可以推断，对象不是由数组结构存储；链表虽然能够任意伸缩但是其查询效率低下，因此也排除链表。如果用树作为存储结构，效率较高的可能就是平衡树了。平衡树的查询效率还可以接受，但是当删除属性的时候，平衡树在调整的时候代价相比于 hash 表要大很多。于是 Hash 成为最好的选择。</p><p>假如有这么一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">id, name, age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> bol = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="number">100</span>, <span class="string">'Leo'</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>JavaScript 内存分析图如下：<br><img src="/assets/img/js_obj_mem.png" alt="memory"></p><p>变量 num、bol、str 为基本数据类型，它们的值直接存放在栈中。obj、person、arr 为复合数据类型，他们的引用变量存储在栈中，指向于存储在堆中的实际对象。</p><p>在 JavaScript 中变量分为基本类型和引用类型（对象类型），分别对应着两种不同的存储方式–栈存储和堆存储。</p><p>基本类型一旦初始化则内存大小固定，访问变量就是访问变量的内存上实际的数据，称之为按值访问。而对象类型内存大小不固定，无法在栈中维护，所以 JavaScript 就把对象类型的变量放到堆中，让解释器为其按需分配内存，而通过对象的引用指针对其进行访问，因为对象在堆中的内存地址大小是固定的，因此可以将内存地址保存在栈内存的引用中。这种方式称之为按引用访问。</p><h1>总结</h1><p>在 JavaScript 中对象是以 Hash 结构存储的，用 &lt;Key, Value&gt; 键值对表示对象的属性，Key 的数据类型为字符串，Value 的数据类型是结构体，即对象是以 &lt;String, Object&gt; 类型的 HashMap 结构存储的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;哈希表(Hash table，也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。&lt;/p&gt;&lt;p&gt;JavaScript 中的对象也是以 Key-Value 的形式访问，那么 JavaScript 的对象是否以 Hash 的结构存储呢？&lt;/p&gt;&lt;p&gt;我们首先来看一下 Hash 表结构。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Hash" scheme="https://lz5z.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Spark RDD 操作详解——Transformations</title>
    <link href="https://lz5z.com/rdd-operations/"/>
    <id>https://lz5z.com/rdd-operations/</id>
    <published>2016-11-29T15:08:50.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>RDD 操作有哪些</h1><p>Spark RDD 支持2种类型的操作: transformations 和 actions。transformations： 从已经存在的数据集中创建一个新的数据集，如 map。actions： 数据集上进行计算之后返回一个值，如 reduce。</p><p>在 Spark 中，所有的 transformations 都是 lazy 的，它们不会马上计算它们的结果，而是仅仅记录转换操作是应用到哪些基础数据集上的，只有当 actions 要返回结果的时候计算才会发生。</p><a id="more"></a><p>默认情况下，每一个转换过的 RDD 会在每次执行 actions 的时候重新计算一次。但是可以使用 persist (或 cache)方法持久化一个 RDD 到内存中，这样Spark 会在集群上保存相关的元素，下次查询的时候会变得更快，也可以持久化 RDD 到磁盘，或在多个节点间复制。</p><h2>基础</h2><p>在 Spark-shell 中运行如下脚本</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> lines = sc.textFile(<span class="string">"test.txt"</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> lineLengths = lines.map(s =&gt; s.length)</span><br><span class="line">scala&gt; <span class="keyword">val</span> totalLength = lineLengths.reduce((a, b) =&gt; a + b))</span><br><span class="line">totalLength: <span class="type">Int</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure><p>第一步： 定义外部文件 RDD，lines 指向 test.txt 文件， 这个文件即没有加载到内存也没有做其他的操作，所以即使文件不存在也不会报错。<br>第二步： 定义 lineLengths，它是 map 转换(transformation)的结果。同样，lineLengths 由于 lazy 模式也没有立即计算。<br>第三步： reduce 是一个 action， 所以真正执行读文件和 map 计算是在这一步发生的。Spark 将计算分成多个 task，并且让它们运行在多台机器上。每台机器都运行自己的 map 部分和本地 reduce 部分，最后将结果返回给驱动程序。</p><p>如果我们想要再次使用 lineLengths，我们可以使用 persist 或者 cache 将 lineLengths 保存到内存中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; lineLengths.persist()</span><br><span class="line">scala&gt; lineLengths.collect()</span><br><span class="line">res7: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h1>Transformations</h1><p>Transformations 是 RDD 的基本转换操作，主要方法有： map， filter， flatMap， mapPartitions， mapPartitionsWithIndex， sample， union， intersection， distinct， groupByKey， reduceByKey， aggregateByKey， sortByKey， join， cogroup， cartesian， pipe， coalesce， repartition。</p><h2>filter(func)</h2><p>filter 返回一个新的数据集，从源数据中选出 func 返回 true 的元素。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">9</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.filter(x =&gt; x &gt; <span class="number">5</span>)</span><br><span class="line">scala&gt; b.collect</span><br><span class="line">res11: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><h2>flatMap(func)</h2><p>与 map 类似，区别是原 RDD 中的元素经 map 处理后只能生成一个元素，而经 flatmap 处理后可生成多个元素来构建新 RDD， 所以 func 必须返回一个 Seq，而不是单个 item。</p><p>举例：对原RDD中的每个元素x产生y个元素（从1到y，y为元素x的值）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = sc.parallelize(<span class="number">1</span> to <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> b = a.flatMap(x =&gt; <span class="number">1</span> to x)</span><br><span class="line">scala&gt; b.collect</span><br><span class="line">res12: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2>mapPartitions(func)</h2><p>mapPartitions 是 map 的一个变种。map 的输入函数是应用于 RDD 中每个元素，而 mapPartitions 的输入函数是应用于每个分区，也就是把每个分区中的内容作为整体来处理的。<br>它的函数定义为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitions</span></span>[<span class="type">U</span>](f: (<span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">Iterator</span>[<span class="type">U</span>], preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>)(<span class="keyword">implicit</span> arg0: <span class="type">ClassTag</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure><p>f 即为输入函数，它处理每个分区里面的内容。每个分区中的内容将以 Iterator[T] 传递给输入函数 f，f 的输出结果是 Iterator[U]。最终的 RDD 由所有分区经过输入函数处理后的结果合并起来的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = rdd.mapPartitions(x =&gt; &#123;</span><br><span class="line">     | <span class="keyword">var</span> result = <span class="type">List</span>[<span class="type">Int</span>]()</span><br><span class="line">     | <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">     | <span class="keyword">while</span>(x.hasNext) &#123;</span><br><span class="line">     |   i += x.next</span><br><span class="line">     | &#125;</span><br><span class="line">     | result.::(i).iterator</span><br><span class="line">     |&#125;)</span><br><span class="line">scala&gt; rdd2.collect</span><br><span class="line">res13: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">3</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; rdd2.partitions.size</span><br><span class="line">res14: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>上述例子中 rdd2 将 rdd 每个分区中的数值累加。</p><h2>mapPartitionsWithIndex(func)</h2><p>函数定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitionsWithIndex</span></span>[<span class="type">U</span>](f: (<span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">Iterator</span>[<span class="type">U</span>], preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>)(<span class="keyword">implicit</span> arg0: <span class="type">ClassTag</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure><p>mapPartitionsWithIndex 的作用与 mapPartitions 相同，不过提供了两个参数，第一个参数为分区的索引。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = rdd.mapPartitionsWithIndex(</span><br><span class="line">     | (x, iter) =&gt; &#123;</span><br><span class="line">     |   <span class="keyword">var</span> result = <span class="type">List</span>[<span class="type">Int</span>]()</span><br><span class="line">     |   <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">     |    <span class="keyword">while</span>(iter.hasNext) &#123;</span><br><span class="line">     |     i += iter.next</span><br><span class="line">     |    &#125;</span><br><span class="line">     |   result.::(x + <span class="string">"|"</span> + i).iterator</span><br><span class="line">     |&#125;)</span><br><span class="line">scala&gt; rdd2.collect</span><br><span class="line">res14: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="number">0</span>|<span class="number">3</span>, <span class="number">1</span>|<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; rdd2.partitions.size</span><br><span class="line">res15: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><h2>sample(withReplacement, fraction, seed)</h2><h2>union(otherDataset)</h2><p>函数定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure><p>该函数比较简单，就是将两个 RDD 进行合并，不去重。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> rdd1 = sc.makeRDD(<span class="number">1</span> to <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">scala&gt; <span class="keyword">var</span> rdd2 = sc.makeRDD(<span class="number">2</span> to <span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">scala&gt; rdd1.union(rdd2).collect</span><br><span class="line">res18: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2>intersection(otherDataset)</h2><p>函数定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>], numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>], partitioner: <span class="type">Partitioner</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure><p>该函数返回两个 RDD 的交集，并且去重。<br>参数numPartitions指定返回的RDD的分区数。<br>参数partitioner用于指定分区函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> rdd1 = sc.makeRDD(<span class="number">1</span> to <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">scala&gt; rdd1.collect</span><br><span class="line">res19: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">var</span> rdd2 = sc.makeRDD(<span class="number">2</span> to <span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">scala&gt; rdd2.collect</span><br><span class="line">res20: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">scala&gt; rdd1.intersection(rdd2).collect</span><br><span class="line">res21: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2>distinct([numTasks])</h2><p>返回一个新的 RDD，里面包含源 RDD 中所有的（distinct）元素。</p><h2>groupByKey([numTasks])</h2><h2>reduceByKey(func, [numTasks])</h2><h2>aggregateByKey(zeroValue)(seqOp, combOp, [numTasks])</h2><h2>sortByKey([ascending], [numTasks])</h2><h2>join(otherDataset, [numTasks])</h2><h2>cogroup(otherDataset, [numTasks])</h2><h2>cartesian(otherDataset)</h2><h2>pipe(command, [envVars])</h2><h2>coalesce(numPartitions)</h2><h2>repartition(numPartitions)</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;RDD 操作有哪些&lt;/h1&gt;&lt;p&gt;Spark RDD 支持2种类型的操作: transformations 和 actions。transformations： 从已经存在的数据集中创建一个新的数据集，如 map。actions： 数据集上进行计算之后返回一个值，如 reduce。&lt;/p&gt;&lt;p&gt;在 Spark 中，所有的 transformations 都是 lazy 的，它们不会马上计算它们的结果，而是仅仅记录转换操作是应用到哪些基础数据集上的，只有当 actions 要返回结果的时候计算才会发生。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://lz5z.com/categories/Big-Data/"/>
    
    
      <category term="Spark" scheme="https://lz5z.com/tags/Spark/"/>
    
      <category term="Scala" scheme="https://lz5z.com/tags/Scala/"/>
    
      <category term="RDD" scheme="https://lz5z.com/tags/RDD/"/>
    
      <category term="Transformations" scheme="https://lz5z.com/tags/Transformations/"/>
    
  </entry>
  
  <entry>
    <title>Spark RDD 基础</title>
    <link href="https://lz5z.com/Spark-RDD/"/>
    <id>https://lz5z.com/Spark-RDD/</id>
    <published>2016-11-29T11:29:07.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>RDD 是什么？</h1><img src="/assets/img/spark-stack.png" alt="rdd"> [图片摘自[Spark 官网](http://spark.apache.org/)]<p><a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="noopener">RDD</a> 全称 <strong>Resilient Distributed Datasets</strong>，是 Spark 中的抽象数据结构类型，任何数据在Spark中都被表示为RDD。 Spark 建立在统一抽象的RDD之上，使得它可以以基本一致的方式应对不同的大数据处理场景，包括MapReduce，Streaming，SQL，Machine Learning 等。</p><a id="more"></a><p>简单的理解就是 RDD 就是一个数据结构，不过这个数据结构中的数据是分布式存储的，Spark 中封装了对 RDD 的各种操作，可以让用户显式地将数据存储到磁盘和内存中，并能控制数据的分区。</p><h2>RDD 特性</h2><p>RDD 是 Spark 的核心，也是整个 Spark 的架构基础。它的特性可以总结如下：</p><ul><li>它是不变的数据结构存储</li><li>它是支持跨集群的分布式数据结构</li><li>可以根据数据记录的key对结构进行分区</li><li>提供了粗粒度的操作，且这些操作都支持分区</li><li>它将数据存储在内存中，从而提供了低延迟性</li></ul><h1>创建 RDD</h1><p>本文中的例子全部基于 <a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">Spark-shell</a>，需要的请自行安装。</p><p>创建 RDD 主要有两种方式，一种是使用 SparkContext 的 <strong>parallelize</strong> 方法创建并行集合，还有一种是通过外部外部数据集的方法创建，比如本地文件系统，HDFS，HBase，Cassandra等。</p><h2>并行集合</h2><p>使用 parallelize 方法从普通数组中创建 RDD:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val a = sc.parallelize(1 to 9, 3)</span></span><br><span class="line">a: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &lt;console&gt;:21</span><br></pre></td></tr></table></figure><p>parallelize 方法接受两个参数，第一个是数据集合，第二个是切片的个数，表示将数据存放在几个分区中。</p><p>一旦创建完成，这个分布式数据集(a)就可以被并行操作。例如，我们可以调用 a.reduce((m, n) =&gt; m + n) 将这个数组中的元素相加。 更多的操作请见 <a href="https://lz5z.com/rdd-operations">Spark RDD 操作</a>。</p><h2>本地文件</h2><p>文本文件 RDDs 可以使用 SparkContext 的 textFile 方法创建。 在这个方法里传入文件的 URI (机器上的本地路径或 hdfs://，s3n:// 等)，然后它会将文件读取成一个行集合。</p><p>读取文件 test.txt 来创建RDD，文件中的每一行就是RDD中的一个元素。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val b = sc.textFile(<span class="string">"test.txt"</span>)</span></span><br><span class="line">b: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at textFile at &lt;console&gt;:21</span><br></pre></td></tr></table></figure><p>一旦创建完成，(b) 就能做数据集操作。例如，我们可以用下面的方式使用 map 和 reduce 操作将所有行的长度相加： b.map(s =&gt; s.length).reduce((m, n) =&gt; m + n)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> b.collect</span></span><br><span class="line">res1: Array[String] = Array(Spark, RDD, Transformations, Actions)</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> b.map(s =&gt; s.length).reduce((m, n) =&gt; m + n))</span></span><br><span class="line">res2: Int = 30</span><br></pre></td></tr></table></figure><h3>Spark 读文件注意事项</h3><ol><li><p>如果使用本地文件系统路径，文件必须能在 worker 节点上用相同的路径访问到。要么复制文件到所有的 worker 节点，要么使用网络的方式共享文件系统。</p></li><li><p>所有 Spark 的基于文件的方法，包括 textFile，能很好地支持文件目录，压缩过的文件和通配符。例如，你可以使用 textFile(&quot;/文件目录&quot;)，textFile(&quot;/文件*.txt&quot;) 和 textFile(&quot;/文件目录/*.gz&quot;)。</p></li><li><p>textFile 方法也可以选择第二个可选参数来控制切片(slices)的数目。默认情况下，Spark 为每一个文件块(HDFS 默认文件块大小是 64M)创建一个切片(slice)。但是你也可以通过一个更大的值来设置一个更高的切片数目。注意，你不能设置一个小于文件块数目的切片值。</p></li></ol><h3>ScalaAPI 对其它数据格式的支持</h3><ol><li><p>SparkContext.wholeTextFiles 让你读取一个包含多个小文本文件的文件目录并且返回每一个(filename, content)对。与 textFile 的差异是：它记录的是每个文件中的每一行。</p></li><li><p>对于 <a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/mapred/SequenceFileInputFormat.html" target="_blank" rel="noopener">SequenceFiles</a>，可以使用 SparkContext 的 sequenceFile[K, V] 方法创建，K 和 V 分别对应的是 key 和 values 的类型。像 <a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/IntWritable.html" target="_blank" rel="noopener">IntWritable</a> 与 <a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Text.html" target="_blank" rel="noopener">Text</a> 一样，它们必须是 Hadoop 的 <a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html" target="_blank" rel="noopener">Writable</a> 接口的子类。另外，对于几种通用的 Writables，Spark 允许你指定原生类型来替代。例如： sequenceFile[Int, String] 将会自动读取 IntWritables 和 Text。</p></li><li><p>对于其他的 Hadoop InputFormats，你可以使用 SparkContext.hadoopRDD 方法，它可以指定任意的 JobConf，输入格式(InputFormat)，key 类型，values 类型。你可以跟设置 Hadoop job 一样的方法设置输入源。你还可以在新的 MapReduce 接口(org.apache.hadoop.mapreduce)基础上使用 SparkContext.newAPIHadoopRDD(译者注：老的接口是 SparkContext.newHadoopRDD)。</p></li><li><p>RDD.saveAsObjectFile 和 SparkContext.objectFile 支持保存一个RDD，保存格式是一个简单的 Java<br>对象序列化格式。这是一种效率不高的专有格式，如 Avro，它提供了简单的方法来保存任何一个 RDD。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;RDD 是什么？&lt;/h1&gt;&lt;img src=&quot;/assets/img/spark-stack.png&quot; alt=&quot;rdd&quot;&gt; [图片摘自[Spark 官网](http://spark.apache.org/)]&lt;p&gt;&lt;a href=&quot;http://spark.apache.org/docs/latest/programming-guide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RDD&lt;/a&gt; 全称 &lt;strong&gt;Resilient Distributed Datasets&lt;/strong&gt;，是 Spark 中的抽象数据结构类型，任何数据在Spark中都被表示为RDD。 Spark 建立在统一抽象的RDD之上，使得它可以以基本一致的方式应对不同的大数据处理场景，包括MapReduce，Streaming，SQL，Machine Learning 等。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://lz5z.com/categories/Big-Data/"/>
    
    
      <category term="Spark" scheme="https://lz5z.com/tags/Spark/"/>
    
      <category term="Scala" scheme="https://lz5z.com/tags/Scala/"/>
    
      <category term="RDD" scheme="https://lz5z.com/tags/RDD/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 JavaScript——Object 对象</title>
    <link href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84Object%E5%AF%B9%E8%B1%A1/"/>
    <id>https://lz5z.com/JavaScript中的Object对象/</id>
    <published>2016-11-25T15:52:44.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>Object–JavaScript世界的起源</h1><p>JavaScript的世界中「一切皆是对象」，而所有对象的起源就是 Object 对象。</p><p>神說：「要有光」。就有了光。</p><a id="more"></a><h2>Object简介</h2><p>JavaScript中的对象其实是一组数据和功能的集合。我们通过执行 new 操作符 + <strong>对象类型的名称</strong>来创建对象。<br>创建 Object 类型的实例并为其添加属性和方法就可以创建自定义对象，Object既是一个对象，也是自身的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;  <span class="comment">//如果不给构造函数传递参数可以省略圆括号，但不推荐这么写</span></span><br></pre></td></tr></table></figure><p>仅仅创建 Object 实例并没有什么用处，但关键是理解一个重要的思想，即在JavaScript中，Object 类型是它所有实例的基础，换句话说，Object类型所具有的任何属性和方法同样存在于更具体的对象中。</p><h2>Object对象属性</h2><p>Object 对象一共有三个属性： _<em>proto</em>_, constructor, prototype。</p><h3>Object._<em>proto</em>_</h3><ol><li>为对象设置原型</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line">rec.__proto__ === Rectangle.prototype; <span class="comment">// true</span></span><br><span class="line">rec.__proto__ = <span class="built_in">Object</span>.prototype;</span><br><span class="line">rec.__proto__ === Rectangle.prototype; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>_<em>proto</em>_ 属性可用于设置对象的原型</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line">obj.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x === <span class="number">10</span>;  <span class="comment">// true</span></span><br><span class="line">obj.y === <span class="number">20</span>;  <span class="comment">// true</span></span><br><span class="line">obj.z === <span class="number">40</span>;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>这只适用于可扩展的对象，一个不可扩展的对象的 _<em>proto</em>_ 属性是不可变的</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line">obj.__proto__ = &#123;&#125;; <span class="comment">// 抛出异常TypeError</span></span><br></pre></td></tr></table></figure><h3>Object.constructor</h3><p>所有对象都会从它的原型上继承一个 constructor 属性， constructor 属性是保存当前对象的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 或者 o = &#123;&#125;</span></span><br><span class="line">o.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>  <span class="comment">// 或者 a = []</span></span><br><span class="line">a.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>); <span class="comment">// 或者 n = 3</span></span><br><span class="line">n.constructor === <span class="built_in">Number</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3>Object.prototype</h3><p>Object.prototype 属性表示对象 Object 的原型对象，由于所有的对象都是基于 Object，所以 <strong>所有的对象都继承了Object.prototype的属性和方法</strong>，除非这些属性和方法被其他原型链更里层的改动所覆盖。</p><ol><li><strong>Object.prototype.hasOwnProperty()</strong></li></ol><p>返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = <span class="string">'object'</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">'name'</span>);             <span class="comment">// true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">'toString'</span>);         <span class="comment">// false</span></span><br><span class="line">o.hasOwnProperty(<span class="string">'hasOwnProperty'</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Object.prototype.isPrototypeOf()</strong></li></ol><p>返回一个布尔值，表示指定的对象是否在本对象的原型链中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">Rectangle.prototype.isPrototypeOf(rec); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Object.prototype.propertyIsEnumerable()</strong></li></ol><p>判断指定属性是否可枚举。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.propertyIsEnumerable(proName)</span><br></pre></td></tr></table></figure><p>如果 proName 存在于 object 中，且可以使用 for 循环对其进行枚举，则 propertyIsEnumerable 方法返回 true。如果 object 不具有所指定名称的属性或者所指定的属性是不可枚举的，则 propertyIsEnumerable 方法将返回 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cactus"</span>);</span><br><span class="line">a.propertyIsEnumerable(<span class="number">1</span>); <span class="comment">// true，0-2 都是true</span></span><br><span class="line">a.propertyIsEnumerable(<span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Object.prototype.toString()</strong></li></ol><p>返回对象的字符串表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">o.toString() <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure><p>上面代码调用空对象的 toString 方法，结果返回一个字符串 <strong>“[object Object]”</strong>，其中第二个Object表示该值的构造函数，<br>实例对象可能会自定义 toString 方法，覆盖掉 Object.prototype.toString 方法。通过函数的 call 方法，可以在任意值上调用 Object.prototype.toString 方法，帮助我们判断这个值的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">0</span>) <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>) <span class="comment">// "[object Math]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">//"[object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/./</span>) <span class="comment">//"[object RegExp]"</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>Object.prototype.valueOf()</strong></li></ol><p>返回指定对象的原始值。valueOf() 方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p><p>valueOf方法的主要用途是，JavaScript自动类型转换时会默认调用这个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="number">1</span> + o <span class="comment">// "1[object Object]"  //默认调用valueOf()方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义valueOf() 方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2>Object对象方法</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Object.assign(target, …sources)</td><td style="text-align:left">将来自一个或多个源对象中的值复制到一个目标对象。</td></tr><tr><td style="text-align:left">Object.create(prototype, descriptors)</td><td style="text-align:left">创建具有指定原型并可选择包含指定属性的对象。</td></tr><tr><td style="text-align:left">Object.defineProperties(obj, props)</td><td style="text-align:left">将一个或多个属性添加到对象，和/或修改现有属性的特性。</td></tr><tr><td style="text-align:left">Object.defineProperty(obj, prop, descriptor)</td><td style="text-align:left">将属性添加到对象，或修改现有属性的特性。</td></tr><tr><td style="text-align:left">Object.freeze(obj)</td><td style="text-align:left">防止修改现有属性的特性和值，并防止添加新属性。</td></tr><tr><td style="text-align:left">Object.getOwnPropertyDescriptor(obj, prop)</td><td style="text-align:left">返回数据属性或访问器属性的定义。</td></tr><tr><td style="text-align:left">Object.getOwnPropertyNames(obj)</td><td style="text-align:left">返回对象属性及方法的名称。</td></tr><tr><td style="text-align:left">Object.getOwnPropertySymbols(obj)</td><td style="text-align:left">返回对象的符号属性。</td></tr><tr><td style="text-align:left">Object.getPrototypeOf(obj)</td><td style="text-align:left">返回对象的原型。</td></tr><tr><td style="text-align:left"><a href="http://Object.is" target="_blank" rel="noopener">Object.is</a>(value1, value2)</td><td style="text-align:left">返回一个值，该值指示两个值是否相同。</td></tr><tr><td style="text-align:left">Object.isExtensible(obj)</td><td style="text-align:left">返回指示是否可将新属性添加到对象的值。</td></tr><tr><td style="text-align:left">Object.isFrozen(obj)</td><td style="text-align:left">如果无法在对象中修改现有属性的特性和值，并且无法将新属性添加到对象，则返回 true。</td></tr><tr><td style="text-align:left">Object.seal(obj)</td><td style="text-align:left">防止修改现有属性的特性，并防止添加新属性。</td></tr><tr><td style="text-align:left">Object.isSealed(obj)</td><td style="text-align:left">如果无法在对象中修改现有属性特性，并且无法将新属性添加到对象，则返回 true。</td></tr><tr><td style="text-align:left">Object.keys(obj)</td><td style="text-align:left">返回对象的 <strong>可枚举</strong>属性和方法的名称。</td></tr><tr><td style="text-align:left">Object.preventExtensions(obj)</td><td style="text-align:left">防止向对象添加新属性。</td></tr><tr><td style="text-align:left">Object.setPrototypeOf(obj, prototype)</td><td style="text-align:left">设置对象的原型。</td></tr></tbody></table><hr><h3>Object.assign(target, …sources)</h3><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p><p>如果存在分配错误，此函数将引发 TypeError，这将终止复制操作。如果目标属性不可写，则将引发 TypeError。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> first = &#123; <span class="attr">name</span>: <span class="string">"Leo"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> last = &#123; <span class="attr">lastName</span>: <span class="string">"Li"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.assign(first, last);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">//&#123; name: "Leo", lastName: "Li" &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="built_in">Object</span>.assign(&#123;&#125;, person); <span class="comment">//使用 Object.assign 克隆对象。</span></span><br></pre></td></tr></table></figure><h3>Object.create(prototype, descriptors)</h3><p>创建一个具有指定原型且包含指定属性的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  size: &#123;</span><br><span class="line">    value: <span class="string">"large"</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  shape: &#123;</span><br><span class="line">    value: <span class="string">"round"</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newObj.size); <span class="comment">// large</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.shape); <span class="comment">// round</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newObj)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>使用Object.create实现类式继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x += x;</span><br><span class="line">    <span class="keyword">this</span>.y += y;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"Shape moved."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - subclass</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">//call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle <span class="comment">//true.</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape <span class="comment">//true.</span></span><br><span class="line"></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//Outputs, "Shape moved."</span></span><br></pre></td></tr></table></figure><h3>Object.keys(obj)</h3><p>返回对象可枚举的属性名组成的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">"Hello"</span>, <span class="string">"World"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(a)</span><br><span class="line"><span class="comment">// ["0", "1"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a)</span><br><span class="line"><span class="comment">// ["0", "1", "length"]</span></span><br></pre></td></tr></table></figure><h3>Object.getOwnPropertyNames(obj)</h3><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(arr).sort(); <span class="comment">//[ '0', '1', '2', 'length' ]</span></span><br></pre></td></tr></table></figure><h3>Object.getOwnPropertySymbols(obj)</h3><p>该特性属于 ECMAScript 2015（ES6）规范。</p><p>Object.getOwnPropertySymbols() 方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">"a"</span>;</span><br><span class="line">obj[b] = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols.length; <span class="comment">// 2</span></span><br><span class="line">objectSymbols;        <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line">objectSymbols[<span class="number">0</span>];     <span class="comment">// Symbol(a)</span></span><br></pre></td></tr></table></figure><h3>对象限制型方法</h3><p>ES5中提供了一系列限制对象被修改的方法，用来防止被某些对象被无意间修改导致的错误。每种限制类型包含一个判断方法和一个设置方法。</p><h4>阻止对象扩展</h4><p>Object.preventExtensions() 用来限制对象的扩展，设置之后，对象将无法添加新属性。</p><ol><li>对象的属性不可用扩展，但是已存在的属性可以被删除。</li><li>无法添加新属性指的是无法在自身上添加属性，如果是在对象的原型上，还是可以添加属性的。</li><li>Object.isExtensible() 方法用来判断一个对象是否可扩展。</li></ol><h4>将对象密封</h4><p>Object.seal() 可以密封一个对象并返回被密封的对象。<br>密封对象无法添加或删除已有属性，也无法修改属性的enumerable，writable，configurable，但是可以修改属性值。</p><p>通过 Object.isSealed() 判断一个对象是否密封。</p><h4>冻结对象</h4><p>Object.freeze() 方法用来冻结一个对象，被冻结的对象将无法添加，修改，删除属性值，也无法修改属性的特性值，即这个对象无法被修改。被冻结的对象无法删除自身的属性，但是通过其原型对象还是可以新增属性的。</p><p>通过 Object.isFrozen() 可以用来判断一个对象是否被冻结了。</p><h3>其它</h3><p>Object.defineProperties、Object.defineProperty、Object.freeze、Object.getOwnPropertyDescriptor 的用法请参考<a href="https://lz5z.com/Object.defineProperty%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/">使用Object.defineProperty为对象定义属性</a>。</p><h2>总结</h2><p>Object 对象虽然平时我们很少直接用到，但是很多对象的属性和方法都是由 Object 继承而来的，因此非常具有学习意义。<br>这篇 Blog 虽然都是 API 级别的学习，可是很多东西都是欠下的技术债，就当补课了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Object–JavaScript世界的起源&lt;/h1&gt;&lt;p&gt;JavaScript的世界中「一切皆是对象」，而所有对象的起源就是 Object 对象。&lt;/p&gt;&lt;p&gt;神說：「要有光」。就有了光。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://lz5z.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>深入学习 JavaScript——闭包</title>
    <link href="https://lz5z.com/JavaScript%E9%97%AD%E5%8C%85/"/>
    <id>https://lz5z.com/JavaScript闭包/</id>
    <published>2016-11-24T22:39:45.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是闭包（Closure）</h1><p>“函数挂载父环境的时机，如果是定义时就是闭包，如果是执行时就不是闭包。”——听一位大神同事讲的。</p><p>“闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。”——<a href="https://developer.mozilla.org/cn/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN</a></p><p>刚学JavaScript的时候看了这些定义后我就哭了，要想理解闭包还是要看例子。</p><a id="more"></a><h2>举个栗子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a++);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fun = foo();</span><br><span class="line">fun(); <span class="comment">//1</span></span><br><span class="line">fun(); <span class="comment">//2</span></span><br><span class="line">fun = <span class="literal">null</span>; <span class="comment">//a被垃圾回收</span></span><br></pre></td></tr></table></figure><p>函数 foo 返回一个内部函数 inner，所以“let fun = foo()”的结果应该是“fun = inner” 也就是 “fun = function (){console.log(a++)};”</p><p>那么当执行 fun() 的时候 <strong>a=?</strong>，显然在 fun 的外部环境中是没有 a 的定义的，于是就向 inner 函数定义时候的父环境中找 <strong>a</strong>，果然在 foo 函数中找到了。这样就可以理解上面给出的第一个闭包的定义了：一个函数在执行的时候，如果能拿到定义时候父环境的值，这样就是闭包，反之则不是闭包。</p><p>那闭包究竟是一个什么东西呢？我们可以把闭包理解成 “函数 + 函数创建时的环境”的组合，比如上面的 inner 函数 + 变量a 就是一个闭包。</p><h1>闭包的用途</h1><p>通过使用闭包，我们可以做很多事情。</p><ol><li>JavaScript面向对象</li><li>提升代码效率</li><li>编写更优雅的代码</li></ol><h2>匿名自执行函数（立即执行函数表达式）</h2><p>匿名自执行函数有两个作用：</p><ol><li>不污染全局变量</li><li>函数执行完立刻释放垃圾回收</li></ol><p>比如我上面栗子中创建的函数 foo 会自动绑定到全局变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.foo()(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这样我们每次创建一个函数都必须要使用 const/let/var 去声明一个变量等于函数，不然全局对象的属性会越来越多，从而影响访问速度(因为变量的取值是需要从原型链上遍历的)，而且可能会导致变量冲突。</p><h2>结果缓存</h2><p>结果缓存是闭包能显著提高程序效率的一个用途。假如有一个处理过程很耗时的函数对象，我们可以将每次处理的结果缓存起来，当再次调用这个函数的时候，就先从缓存中查找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheSearch = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[key];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cache[key] = <span class="string">`Hello <span class="subst">$&#123;key&#125;</span>`</span>; <span class="comment">//假如这是一步比较复杂的计算</span></span><br><span class="line">            <span class="keyword">return</span> cache[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2>封装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">'name'</span>; <span class="comment">// “闭包”内的函数可以访问 name 变量，而 name 变量对于外部却是隐藏的</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 通过定义的接口来访问 name</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;,</span><br><span class="line">        setName: <span class="function"><span class="keyword">function</span>(<span class="params">new_name</span>) </span>&#123; <span class="comment">// 通过定义的接口来修改 name</span></span><br><span class="line">            name = new_name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">foo.getName(); <span class="comment">// 得到 'name'</span></span><br><span class="line">foo.setName(<span class="string">'newName'</span>); <span class="comment">// 通过函数接口，我们访问并修改了 name 变量</span></span><br><span class="line">foo.getName(); <span class="comment">// 得到 'newName'</span></span><br><span class="line">foo.name; <span class="comment">// Type error，访问不能</span></span><br></pre></td></tr></table></figure><h2>实现类和继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'God'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//继承自Person</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//添加私有方法</span></span><br><span class="line">Student.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> leo = <span class="keyword">new</span> Student();</span><br><span class="line">leo.setName(<span class="string">'Leo'</span>);</span><br><span class="line">leo.Say(<span class="string">'World'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(leo.getName());</span><br></pre></td></tr></table></figure><p>这里的 Person 是一个函数，由于 JavaScript “没有” class 的概念（有 class 关键字）<br>，所以在 JavaScript 中，new 后面跟的是构造函数。<br>上面的代码里面定义了 Student 继承自 Person，所以拥有 getName 方法，然后通过prototype添加自己的方法。</p><h2>经典题目</h2><p>实现每隔一秒输出一个递增的数字（0 到 5）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法想必大家都知道结果是什么，那就是每隔一秒输出一个5</p><p>使用闭包实现输出数字为 0 到 5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a)</span><br><span class="line">        &#125;, a * <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种使用闭包的方式是使用 Array 的 forEach 循环，forEach 里的执行函数也行成了一个闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然使用 ES6 的 let 才是最好的选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>闭包总结</h2><p>闭包三个特性：</p><ol><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ol><p>闭包的优点：</p><ol><li>希望一个变量长期驻扎在内存中</li><li>避免全局变量的污染</li><li>私有成员的存在</li></ol><p>闭包的缺点：</p><ol><li>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;什么是闭包（Closure）&lt;/h1&gt;&lt;p&gt;“函数挂载父环境的时机，如果是定义时就是闭包，如果是执行时就不是闭包。”——听一位大神同事讲的。&lt;/p&gt;&lt;p&gt;“闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。”——&lt;a href=&quot;https://developer.mozilla.org/cn/docs/Web/JavaScript/Closures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;&lt;/p&gt;&lt;p&gt;刚学JavaScript的时候看了这些定义后我就哭了，要想理解闭包还是要看例子。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://lz5z.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>在 Hexo 中插入音乐与视频</title>
    <link href="https://lz5z.com/Music-Video/"/>
    <id>https://lz5z.com/Music-Video/</id>
    <published>2016-11-22T21:28:11.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h2>网易云音乐iframe</h2><p>首先打开网易云音乐首页找到你想要的音药，点击 「生成外链播放器」</p><img src="/assets/img/hexo_music.png" alt="我是一只的图片"><p>选择合适的尺寸后将生成的 iframe 插件或者 flash 插件代码复制到 markdown 中即可。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=26085700&auto=0&height=66"></iframe><a id="more"></a><h2>腾讯视频</h2><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=f0022xw9le3&tiny=0&auto=0" allowfullscreen></iframe><h2>优酷视频</h2><p>优酷暂时没有 https，这个比较讨厌。</p><h2>B站</h2><p>B 站的视频，找到想要分享的视频，点击下方的分享即可。</p><p><embed height="415" width="544" quality="high" allowfullscreen type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=18827465&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;网易云音乐iframe&lt;/h2&gt;&lt;p&gt;首先打开网易云音乐首页找到你想要的音药，点击 「生成外链播放器」&lt;/p&gt;&lt;img src=&quot;/assets/img/hexo_music.png&quot; alt=&quot;我是一只的图片&quot;&gt;&lt;p&gt;选择合适的尺寸后将生成的 iframe 插件或者 flash 插件代码复制到 markdown 中即可。&lt;/p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=26085700&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="Hexo" scheme="https://lz5z.com/tags/Hexo/"/>
    
      <category term="Music" scheme="https://lz5z.com/tags/Music/"/>
    
      <category term="Video" scheme="https://lz5z.com/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>使用 Object.defineProperty 为对象定义属性</title>
    <link href="https://lz5z.com/Object.defineProperty%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7/"/>
    <id>https://lz5z.com/Object.defineProperty为对象定义属性/</id>
    <published>2016-11-21T22:38:27.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>先说句题外话</h1><p>目前前端开发中比较流行的两个框架： <a href="https://angularjs.org/" target="_blank" rel="noopener">Angular</a> 和 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a> 都采用了数据双向绑定的技术。<br>Angular1 中数据双向绑定是通过「脏检测」的方式实现，每当数据发生变更，对所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了变化以及这个变化是否会影响其它数据的变化，然后将变更的数据发送到视图，更新页面展示。</p><p>Vue 数据双向绑定的原理与Angular有所不同，网上人称「数据劫持」<img src="/assets/img/scary.gif" alt="scary" width="5%">。Vue使用的是 ES5 提供的 Object.defineProperty() 结合发布者-订阅者模式，通过Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><a id="more"></a><h1>Object.defineProperty()</h1><h2>定义以及使用</h2><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</p><p>我们来看下一般使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'Leo'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Leo.name); <span class="comment">//Leo</span></span><br></pre></td></tr></table></figure><p>其基本语法规则如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><ol><li>obj: 需要定义属性的对象。</li><li>prop: 需定义或修改的属性的名字。</li><li>descriptor: 将被定义或修改的属性的描述符。</li><li>返回值: 返回传入函数的对象，即第一个参数obj</li></ol><p>所以 <strong>Object.defineProperty(obj, ‘name’, { value: ‘Leo’})</strong> 相当于 <strong><a href="http://obj.name" target="_blank" rel="noopener">obj.name</a> = ‘Leo’</strong> 或者 **obj[‘name’] = ‘Leo’**喽。</p><p>那我们直接使用「对象.属性」就好了，为什么要用 Object.defineProperty 这么复杂的方法呢？</p><h2>Object.defineProperty 解决什么问题</h2><p>如果你想定义一个对象的属性为只读怎么办？<br>「对象.属性」能做到吗？显然不能！Object.defineProperty 却可以做到。因此 <strong>Object.defineProperty 方法是对属性更加精确的定义</strong>。</p><h3>属性的状态设置</h3><p>我们可以在descriptor参数中设置如下值，来实现对属性的控制：</p><ul><li>value：默认为 undefined。该属性的值。</li><li>writable：默认为 false。该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（<a href="https://lz5z.com/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/">严格模式</a>会报错，正常模式则什么都不做）</li><li>configurable：默认为 false。当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。</li><li>enumerable：默认为 false。当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中（for…in 或者 Object.keys）</li><li>get: 默认为 undefined。一个给属性提供 getter 的方法。该方法返回值被用作属性值。</li><li>set: 默认为 undefined。一个给属性提供 setter 的方法。该方法将接受唯一参数，并将该参数的新值分配给该属性。</li></ul><h3>value、writable</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">//writable 为true的时候name属性才可以被更改</span></span><br><span class="line">    value: <span class="string">'Leo'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Leo.name = <span class="string">'Jack'</span>; <span class="comment">//strict mode下修改writable为false的属性会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(Leo.name);</span><br></pre></td></tr></table></figure><h3>configurable</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'Leo'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Leo.name; <span class="comment">//configurable为false的时候删除属性会报错</span></span><br></pre></td></tr></table></figure><p>configurable 参数不仅负责属性的删除，也与属性修改有关。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'Leo'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Leo, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// Cannot redefine property: name</span></span><br><span class="line">    value: <span class="string">'Jack'</span>, <span class="comment">//Cannot redefine property: name</span></span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">//Cannot redefine property: name</span></span><br><span class="line">    enumerable: <span class="literal">true</span> <span class="comment">//Cannot redefine property: name</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假如一个属性被定义成 configurable 为 false，则这个属性既不能修改值（value），又不能修改属性的属性（configurable，writable，enumerable）；如果 configurable 为 true 就可以放心修改了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'Leo'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Leo, <span class="string">'name'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">'Jack'</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3>enumerable</h3><p>属性特性 enumerable 定义了对象的属性是否可以在 for…in 循环和 Object.keys() 中被枚举。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">"a"</span>, &#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"b"</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"c"</span>, &#123;<span class="attr">value</span>: <span class="number">3</span>&#125;); <span class="comment">// enumerable defaults to false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> o) &#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "a" "d" </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// ["a", "d"]</span></span><br><span class="line"></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'a'</span>); <span class="comment">// true</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'b'</span>); <span class="comment">// false</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">'c'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3>get、set</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Leo'</span>;</span><br><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Leo.name = <span class="string">'Jack'</span>; <span class="comment">// 'set'</span></span><br><span class="line"><span class="built_in">console</span>.log(Leo.name); <span class="comment">// 'get' 'Jack'</span></span><br></pre></td></tr></table></figure><p>在对Leo.name进行赋值的时候，其实是调用了name的set方法；而使用Leo.name的时候则调用了get方法。这就是Vue数据双向绑定的原理：每当数据发生改变，其实是调用了set方法，set方法里面发布数据变动的消息给订阅者，触发相应的监听回调。</p><p>注意： 如果 get 方法与 value 同时出现，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Leo'</span>;</span><br><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: name, <span class="comment">// A property cannot both have accessors and be writable or have a value</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1>相关的方法</h1><h2>Object.getOwnPropertyDescriptor(obj, prop)</h2><p>Object.getOwnPropertyDescriptor() 返回指定对象上一个自有属性对应的属性描述符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Leo = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'name'</span>, &#123;</span><br><span class="line">    value: <span class="string">'Leo'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(Leo, <span class="string">'name'</span>)); </span><br><span class="line"><span class="comment">//&#123; value: 'Leo',</span></span><br><span class="line"><span class="comment">//  writable: false,</span></span><br><span class="line"><span class="comment">//  enumerable: false,</span></span><br><span class="line"><span class="comment">//  configurable: false &#125;</span></span><br></pre></td></tr></table></figure><h2>Object.defineProperties(object, descriptors)</h2><p>Object.defineProperties 与 Object.defineProperty 作用相同，不过可以同时将多个属性添加/修改到对象。</p><h2>Object.freeze(obj)</h2><p>Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</p><h1>最后</h1><p>了解了 Object.defineProperty 的用法，接下来就是写一个自己的 Vue.js 了。敬请期待。<img src="/assets/img/smiling.png" alt="smiling"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;先说句题外话&lt;/h1&gt;&lt;p&gt;目前前端开发中比较流行的两个框架： &lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angular&lt;/a&gt; 和 &lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt; 都采用了数据双向绑定的技术。&lt;br&gt;Angular1 中数据双向绑定是通过「脏检测」的方式实现，每当数据发生变更，对所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了变化以及这个变化是否会影响其它数据的变化，然后将变更的数据发送到视图，更新页面展示。&lt;/p&gt;&lt;p&gt;Vue 数据双向绑定的原理与Angular有所不同，网上人称「数据劫持」&lt;img src=&quot;/assets/img/scary.gif&quot; alt=&quot;scary&quot; width=&quot;5%&quot;&gt;。Vue使用的是 ES5 提供的 Object.defineProperty() 结合发布者-订阅者模式，通过Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="defineProperty" scheme="https://lz5z.com/tags/defineProperty/"/>
    
      <category term="Object" scheme="https://lz5z.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动部署 Hexo</title>
    <link href="https://lz5z.com/%E4%BD%BF%E7%94%A8TravisCI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/"/>
    <id>https://lz5z.com/使用TravisCI自动部署Hexo/</id>
    <published>2016-11-18T10:00:36.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>Travis CI</h1><p><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 是一个持续集成的平台，我们可以使用其自动构建部署的功能帮我们简化 Hexo 博客的部署流程。</p><h2>为什么要用 Travis CI</h2><p>因为懒。 <img src="/assets/img/what_can_i_say.jpg" alt="what_can_i_say"></p><p>Hexo 部署 Blog 到 GitPage 通常需要三部曲：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>很简单吧，但是如果是一个新的环境，你需要安装一大堆工具和依赖，比如要装 Node，要装 Hexo，还有 package.json 里面的各种依赖，虽然 Npm 提供了强大的包管理功能，但是有时候就是不方便。</p><p>使用 Travis，你只需要本地有一个 git 就可以了。</p><p>每当你 Push 一个 commit 到 Github 时，Travis CI 会检测到你的提交，并根据配置文件自动运行一些命令，通常这些命令用于测试，构建等等。</p><p>那么在我们的需求下，就可以用它运行一些 hexo deploy -g 之类的命令用来自动生成、部署我们的网站。</p><h1>使用方法</h1><p>使用 Travis 构建 Hexo 只需要三步：</p><ol><li>登录 Travis，配置仓库</li><li>在 Travis CI 配置 GitHub 的 Access Token</li><li>Blog 根目录下配置 .travis.yml</li></ol><h2>配置 Travis 仓库</h2><p>首先使用 GitHub 账号登录<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>，登录后会进入如下页面</p><img src="/assets/img/Travis_main_page.png" alt="我是一只的图片"><p>点击「My Repositories」后面的 <strong>+</strong>，添加要自动构建的仓库</p><img src="/assets/img/Travis.png" alt="我是一只的图片"><p>这里会显示你 GitHub 下所有的项目，选中博客仓库，我的博客在GitHub上的仓库名字就叫做 <strong>Blog</strong>。然后点击仓库名进入仓库配置页面。</p><img src="/assets/img/Travis_settings.png" alt="我是一只的图片"><p>选择 Settings，配置选择如下：</p><img src="/assets/img/Travis_general_settings.png" alt="我是一只的图片"><ul><li>Build only if .travis.yml is present：是只有在 .travis.yml 文件中配置的分支改变了才构建</li><li>Build pushes：当推送完这个分支后开始构建</li></ul><p>这个时候，我们已经开启要构建的仓库，但是如何将构建完成后的文件推送到 Github 上呢？</p><h2>GitHub Access Token</h2><p>Github 支持一种特殊的 URL 来执行 push/pull 等等操作，而不需要输入用户名密码。但这需要事先在 Github 上创建一个 token。</p><p>首先去 GitHub Settings 页面选择 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener"><strong>Personal access tokens</strong></a>，如果你已经登录了，点击链接进去即可。</p><img src="/assets/img/Travis_generate_token.png" alt="我是一只的图片"><p>选择 <strong>Generate new token</strong>，配置如下：</p><img src="/assets/img/Travis_token.png" alt="我是一只的图片"><p>点击绿色确认按钮，copy 刚刚生成的 token。回到 Travis Settings 页面，将复制的 token 加入到环境变量，并命名为 <strong>GitHub_token</strong>。</p><img src="/assets/img/Travis_add_token.png" alt="我是一只的图片"><h2>.travis.yml</h2><p>上述步骤完成后，只需要在你 Blog 源代码的根目录下增加一个 <strong>.travis.yml</strong> 文件，<br>我的文件内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"YOUR GITHUB USER NAME"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"YOUR GITHUB EMAIL"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GitHub_token&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr"> global:</span></span><br><span class="line"><span class="attr">   - GH_REF:</span> <span class="string">github.com/Leo555/Leo555.github.io.git</span></span><br></pre></td></tr></table></figure><p>将上面的 name 和 email 还有 GH_REF 修改成你自己的。</p><p>这里用 Linux 环境变量的引用方式将 GH_REF 和 GitHub_token 其引入 git push 的 url，因此 push 方法就能通过 GitHub OAuth 授权，完成自动 push 的功能。</p><p>此时就万事俱备了。</p><h1>测试</h1><p>使用 Hexo 创建新的 Blog 文件，然后 push 到 GitHub 上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new test.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"add new post test"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure><p>然后回到 Travis 主页面，发现部署已经开始了</p><img src="/assets/img/Travis_deploy.png" alt="我是一只图片"><p>在下面的 log 中可以看到部署的详细情况。</p><p>包括 <strong>nvm install</strong>，<strong>npm install</strong>，<strong>hexo g</strong> 等命令都在这里执行。</p><h1>总结</h1><p>有了自动部署的功能，从此以后就可以将关注点集中在博客内容上，换了平台和环境也没有任何影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Travis CI&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt; 是一个持续集成的平台，我们可以使用其自动构建部署的功能帮我们简化 Hexo 博客的部署流程。&lt;/p&gt;&lt;h2&gt;为什么要用 Travis CI&lt;/h2&gt;&lt;p&gt;因为懒。 &lt;img src=&quot;/assets/img/what_can_i_say.jpg&quot; alt=&quot;what_can_i_say&quot;&gt;&lt;/p&gt;&lt;p&gt;Hexo 部署 Blog 到 GitPage 通常需要三部曲：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; hexo clean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; hexo g&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; hexo deploy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="Hexo" scheme="https://lz5z.com/tags/Hexo/"/>
    
      <category term="Travis" scheme="https://lz5z.com/tags/Travis/"/>
    
      <category term="持续集成" scheme="https://lz5z.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中 child_procss 模块</title>
    <link href="https://lz5z.com/Node.js%E4%B8%ADchild_procss%E6%A8%A1%E5%9D%97/"/>
    <id>https://lz5z.com/Node.js中child_procss模块/</id>
    <published>2016-11-16T20:53:46.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>Node.js 的单线程模型给了它无数的赞美，也带给它无数的诟病。单线程模型，让开发者远离了线程调度的复杂性，使用事件驱动也能开发出一个高并发的服务器；同样也是因为单线程，让CPU密集型计算应用完全不适用。</p><p>Node.js 中内建了一个 <a href="https://nodejs.org/api/child_process.html" target="_blank" rel="noopener">child_process</a>模块，可以在程序中创建子进程，从而实现多核并行计算。</p><a id="more"></a><h1><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="noopener">child_process</a></h1><p>child_process 是 Node.js 中一个非常重要的模块，主要功能有：</p><ol><li>创建子进程</li><li>主进程与子进程通信</li><li>主进程读取子进程返回结果</li></ol><p>使用 child_process 模块创建进程一共有六种方法（Node.js v7.1.0）</p><h3>异步创建进程</h3><ol><li>child_process.<strong>exec</strong>(command[, options][, callback])</li><li>child_process.<strong>execFile</strong>(file[, args][, options][, callback])</li><li>child_process.<strong>fork</strong>(modulePath[, args][, options])</li><li>child_process.<strong>spawn</strong>(command[, args][, options])</li></ol><h3>同步创建进程</h3><ol><li>child_process.<strong>execFileSync</strong>(file[, args][, options])</li><li>child_process.<strong>execSync</strong>(command[, options])</li><li>child_process.<strong>spawnSync</strong>(command[, args][, options])</li></ol><p>以异步函数中 spawn 是最基本的创建子进程的函数，其他三个异步函数都是对 spawn 不同程度的封装。spawn 只能运行指定的程序，参数需要在列表中给出，而 exec 可以直接运行复杂的命令。</p><h2>spawn()</h2><p>spawn从定义来看，有3个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.spawn(command[, args][, options])</span><br></pre></td></tr></table></figure><ol><li>command: 执行的命令</li><li>args: 参数列表，可输入多的参数</li><li>options: 环境变量对象</li><li>return: 返回一个ChildProcess 类的实例</li></ol><h3>options</h3><blockquote><ol><li>cwd [String] Current working directory of the child process</li></ol></blockquote><ol start="2"><li>env [Object] Environment key-value pairs</li><li>argv0 [String] Explicitly set the value of argv[0] sent to the child process. This will be set to command if not specified.</li><li>stdio [Array] | [String] Child’s stdio configuration. (See options.stdio)</li><li>detached [Boolean] Prepare child to run independently of its parent process. Specific behavior depends on the platform, see options.detached)</li><li>uid [Number] Sets the user identity of the process. (See setuid(2).)</li><li>gid [Number] Sets the group identity of the process. (See setgid(2).)</li><li>shell [Boolean] | [String] If true, runs command inside of a shell. Uses ‘/bin/sh’ on UNIX, and ‘cmd.exe’ on Windows. A different shell can be specified as a string. The shell should understand the -c switch on UNIX, or /d /s /c on Windows. Defaults to false (no shell).</li></ol><p>spawn 方法创建一个子进程来执行特定命令，它没有回调函数，只能通过监听事件，来获取运行结果。属于异步执行，适用于子进程长时间运行的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> path = <span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">let</span> child = child_process.spawn(<span class="string">'ls'</span>, [<span class="string">'-l'</span>, path]);</span><br><span class="line">child.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">'close'</span>, (code) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child process exited with code '</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>spawn 方法通过 stream 的方式发数据传给主进程，从而实现了多进程之间的数据交换。</p><h2>exec()</h2><p>exec 方法的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.exec(command[, options][, callback])</span><br></pre></td></tr></table></figure><p>exec 方法是对 spawn 方法的封装，增加了 shell/bash 命令解析和回调函数，更加符合 JavaScript 的函数调用习惯。</p><p>command参数是一个命令字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ls = exec(<span class="string">'ls -l'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error.stack);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error code: '</span> + error.code);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Child Process STDOUT: '</span> + stdout);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>exec 方法第二个参数是回调函数，该函数接受三个参数，分别是发生的错误、标准输出的显示结果、标准错误的显示结果。</p><p>由于标准输出和标准错误都是流对象（stream），可以监听 data 事件，因此上面的代码也可以写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="keyword">let</span> child = exec(<span class="string">'ls -l'</span>);</span><br><span class="line"></span><br><span class="line">child.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + data);</span><br><span class="line">&#125;);</span><br><span class="line">child.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + data);</span><br><span class="line">&#125;);</span><br><span class="line">child.on(<span class="string">'close'</span>, (code) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'closing code: '</span> + code);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>exec 方法会直接调用 bash（/bin/sh程序） 来解释命令，如果用户输入恶意代码，将会带来安全风险。因此，在有用户输入的情况下，最好不使用 exec 方法，而是使用 execFile 方法。</p><h2>execFile()</h2><p>execFile的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_process.execFile(file[, args][, options][, callback])</span><br></pre></td></tr></table></figure><p>execFile 命令有四个参数，file 和callbakc 为必传参数，options、args 为可选参数：</p><ul><li>file 要执行程序的文件或命令名。字符串类型</li><li>args 要执行程序或命令的参数列表。数组类型</li><li>options 可选参数对象，与exec的options对象相同</li><li>callback 子进程执行完毕的回调函数。与exec的callback函数相同</li><li>返回值: ChildProcess 对象</li></ul><p>execFile 从可执行程序启动子进程。与 exec 相比，execFile 不启动独立的 bash/shell，因此更加轻量级，也更加安全。 execFile 也可以用于执行命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">let</span> path = <span class="string">"."</span>;</span><br><span class="line">childProcess.execFile(<span class="string">'ls'</span>, [<span class="string">'-l'</span>, path], (err, result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么，什么时候使用 exec，什么时候使用 execFile 呢？</p><p>如果命令参数是由用户来输入的，对于 exec 函数来说是有安全性风险的，因为 Shell 会运行多行命令，比如 ’ls -l .;pwd，如逗号分隔，之后的命令也会被系统运行。但使用 exeFile 命令时，命令和参数分来，防止了参数注入的安全风险。</p><h2>fork()</h2><p>fork 函数，用于在子进程中运行的模块，如 fork(’./son.js’) 相当于 spawn(‘node’, [’./son.js’]) 。与 spawn 方法不同的是，fork 会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p><p>假设有一个主进程文件 mian.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">let</span> son = childProcess.fork(<span class="string">'./son.js'</span>);</span><br><span class="line"></span><br><span class="line">son.on(<span class="string">'message'</span>, (m) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Main Listen: '</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line">son.send(&#123;</span><br><span class="line">    hello: <span class="string">'son'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有一个子进程文件 son.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'message'</span>, (m) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Son Listen:'</span>, m);</span><br><span class="line">&#125;);</span><br><span class="line">process.send(&#123;</span><br><span class="line">    Hello: <span class="string">'main'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js</span><br><span class="line">Son <span class="string">Listen:</span> &#123; <span class="string">hello:</span> <span class="string">'son'</span> &#125;</span><br><span class="line">Main <span class="string">Listen:</span>  &#123; <span class="string">Hello:</span> <span class="string">'main'</span> &#125;</span><br></pre></td></tr></table></figure><p>通过 main.js 启动子进程 son.js，通过 process 在两个进程之间传递数据。</p><p>使用 child_process.fork() 生成新进程之后，就可以用 son.send(message, [sendHandle]) 向新进程发送消息，新进程中通过监听message事件，来获取消息，这就是主线程与子线程之间的通信方式。</p><h2>Windows</h2><p>在Windows上执行一个 <strong>.bat</strong> 或者 <strong>.cmd</strong> 文件的方式略有不同。</p><p>假如有一个bat文件 my.bat</p><h3>spawn</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> bat = spawn(<span class="string">'cmd.exe'</span>, [<span class="string">'/c'</span>, <span class="string">'my.bat'</span>]);</span><br><span class="line"></span><br><span class="line">bat.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bat.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bat.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Child exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3>exec</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line">exec(<span class="string">'my.bat'</span>, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(stdout);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果文件名中有空格：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bat = spawn(<span class="string">'"my script.cmd"'</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>], &#123; <span class="attr">shell</span>:<span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">exec(<span class="string">'"my script.cmd" a b'</span>, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;Node.js 的单线程模型给了它无数的赞美，也带给它无数的诟病。单线程模型，让开发者远离了线程调度的复杂性，使用事件驱动也能开发出一个高并发的服务器；同样也是因为单线程，让CPU密集型计算应用完全不适用。&lt;/p&gt;&lt;p&gt;Node.js 中内建了一个 &lt;a href=&quot;https://nodejs.org/api/child_process.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;child_process&lt;/a&gt;模块，可以在程序中创建子进程，从而实现多核并行计算。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="进程" scheme="https://lz5z.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>快速排序思想解决水桶问题</title>
    <link href="https://lz5z.com/QuickSortToKettle/"/>
    <id>https://lz5z.com/QuickSortToKettle/</id>
    <published>2016-11-16T09:41:44.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>水桶问题</h1><img src="/assets/img/Bucket.png" alt="我是一只的图片"><p>假设给你n个红色的水壶和n个蓝色的水壶。它们的形状和尺寸都各不相同。所有的红色水壶盛水量都各不相同，蓝色水壶也是如此。但对于每一个红色水壶来说，都有一个蓝色水壶盛水量和其相同；反之亦然。<br>你的任务是配对出全部盛水量相同的红色水壶和蓝色水壶。为此，可以执行的操作为，挑出一对水壶，一只红色一只蓝色，将红色水壶灌满水，将红色水壶的水倒入蓝色水壶中，看其是否恰好灌满来判断，这个红色水壶的盛水量大于、小于或等于蓝色水壶。假设这样的比较需要花费一个单位时间。<br>请找出一种算法，它能够用最少的比较次数来确定所有水壶的配对。<br>注意:不可直接比较两个红色或者两个蓝色水壶，一次比较必须取一只红色一只蓝色。</p><a id="more"></a><h1>解决方案</h1><h2>快速排序思想解</h2><p>1.首先在集合中选取一个元素作为 「基准」 pivot<br>2.将集合中所有元素与「基准」元素进行对比，所有小于「基准」的元素，都移到「基准」的左边；所有大于「基准」的元素，都移到「基准」的右边。<br>3.对「基准」元素左右两边的集合，分别进行上述两步，直到所有的子集只剩下一个元素。</p><p>代码描述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">arr</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left = [], right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ai <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ai &lt; pivot) &#123;</span><br><span class="line">            left.push(ai);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(ai);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>水壶问题</h2><p>1.依次从红色水壶中选取一个水壶与蓝色水壶集合对比，对比过程如下：<br>2.红色水壶与每一个蓝色水壶对比，盛水量大于红色水壶的蓝水壶放在右边，小于的放在左边，水量相等的为当前集合的 「基准」 元素。<br>3.如果当前集合中已有 「基准」 元素，则拿红色水壶与「基准」元素对比： 红色水壶大于基准元素，则选取基准元素右边的集合重复第二步; 如果红色水壶小于基准元素，则选取基准元素左边边的集合重复第二步。</p><h3>举个栗子</h3><p>现在有红色水壶容量为： [3, 5, 1, 4, 8, 2, 6]<br>蓝色水壶： [6, 2, 3, 1, 8, 5, 4]</p><p>第一步，选取红色水壶中第一个水壶 3 跟蓝色水壶依次对比，大于 3 的放右边，小于 3 的放左边，等于 3 的水壶为当前集合的 「基准」 元素。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">1</span>, ③, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>然后选取红色水壶中的第二个水壶 5 与 「基准」 元素对比，5 &gt; 3, 因此使用第一步的方法，拿 5 与 「基准」 元素右边的元素依次对比。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">1</span>, ③, <span class="number">4</span>, ⑤, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>红色第三个水壶为 1， 拿 1 与第一个 「基准」 元素比较， 1 &lt; 3, 因此使用第一步的方法， 拿 1 与 「基准」 元素左边的元素依次对比。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[①, <span class="number">2</span>, ③, <span class="number">4</span>, ⑤, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>红色第四个水壶为 4， 拿 4 与第一个 「基准」 元素比较， 4 &gt; 3, 因此使用第一步的方法， 拿 4 与 「基准」 元素右边的元素依次对比。<br>右边元素集合中又有 「基准」 元素 5 ，因此先与 「基准」 元素对比， 4 &lt; 5， 所以拿 4 与 「基准」 元素左边的元素依次对比。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[①, <span class="number">2</span>, ③, ④, ⑤, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>后面的顺序为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[①, <span class="number">2</span>, ③, ④, ⑤, <span class="number">6</span>, ⑧]</span><br><span class="line"></span><br><span class="line">[①, ②, ③, ④, ⑤, <span class="number">6</span>, ⑧]</span><br><span class="line"></span><br><span class="line">[①, ②, ③, ④, ⑤, ⑥, ⑧]</span><br></pre></td></tr></table></figure><p>代码描述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.pivot = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">const</span> quickMatch = <span class="function">(<span class="params">key, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> matched!`</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.pivot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr.left = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        arr.right = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        arr.map(<span class="function"><span class="params">ai</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ai &lt; key) &#123;</span><br><span class="line">                arr.left.push(ai);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ai &gt; key) &#123;</span><br><span class="line">                arr.right.push(ai);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ai === key) &#123;</span><br><span class="line">                arr.pivot = key;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> matched!`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &gt; arr.pivot) &#123;</span><br><span class="line">            quickMatch(key, arr.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr.pivot) &#123;</span><br><span class="line">            quickMatch(key, arr.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrRed = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arrBlue = [<span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arrRed) &#123;</span><br><span class="line">    quickMatch(key, arrBlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>总结</h1><p>这个算法有点类似于二叉树的思想，将红色水壶与蓝色水壶依次对比的时候，构建蓝色水壶二叉树，每个二叉树的根结点为红色水壶。平均时间复杂度为O(nlgn)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;水桶问题&lt;/h1&gt;&lt;img src=&quot;/assets/img/Bucket.png&quot; alt=&quot;我是一只的图片&quot;&gt;&lt;p&gt;假设给你n个红色的水壶和n个蓝色的水壶。它们的形状和尺寸都各不相同。所有的红色水壶盛水量都各不相同，蓝色水壶也是如此。但对于每一个红色水壶来说，都有一个蓝色水壶盛水量和其相同；反之亦然。&lt;br&gt;你的任务是配对出全部盛水量相同的红色水壶和蓝色水壶。为此，可以执行的操作为，挑出一对水壶，一只红色一只蓝色，将红色水壶灌满水，将红色水壶的水倒入蓝色水壶中，看其是否恰好灌满来判断，这个红色水壶的盛水量大于、小于或等于蓝色水壶。假设这样的比较需要花费一个单位时间。&lt;br&gt;请找出一种算法，它能够用最少的比较次数来确定所有水壶的配对。&lt;br&gt;注意:不可直接比较两个红色或者两个蓝色水壶，一次比较必须取一只红色一只蓝色。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://lz5z.com/categories/Algorithm/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="Algorithm" scheme="https://lz5z.com/tags/Algorithm/"/>
    
      <category term="快速排序" scheme="https://lz5z.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="水桶问题" scheme="https://lz5z.com/tags/%E6%B0%B4%E6%A1%B6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HTML5 前端存储</title>
    <link href="https://lz5z.com/HTML%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <id>https://lz5z.com/HTML前端存储/</id>
    <published>2016-11-16T00:33:38.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>Cookie, LocalStorage 与 SessionStorage</h1><h2>基本概念</h2><p>Cookie，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</p><p>html5 中的 Web Storage 包括了两种存储方式：sessionStorage和localStorage。</p><p>sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</p><p>而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。浏览器中同一个域下的窗口可以共享 localStorage 数据。</p><a id="more"></a><h2>兼容性</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:center">Chrome</th><th style="text-align:center">Firefox (Gecko)</th><th style="text-align:center">Internet Explorer</th><th style="text-align:center">Opera</th><th style="text-align:center">Safari (WebKit)</th></tr></thead><tbody><tr><td style="text-align:left">localStorage</td><td style="text-align:center">4</td><td style="text-align:center">3.5</td><td style="text-align:center">8</td><td style="text-align:center">10.50</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">sessionStorage</td><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">8</td><td style="text-align:center">10.50</td><td style="text-align:center">4</td></tr></tbody></table><h2>差别</h2><p>Cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成 Cookie，默认是关闭浏览器后失效。Http 通信的时候 Cookie 的信息会保存的 Http 头中。<br>localStorage 和 sessionStorage 仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><h2>应用场景</h2><p>因为每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 应当尽可能精简，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。</p><p>localStorage 主要存储一些比较多的本地数据，如 HTML5 小游戏里面生成的数据。</p><p>如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。</p><h2>安全性的考虑</h2><p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，所以千万不要用它们存储你系统中的敏感数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Cookie, LocalStorage 与 SessionStorage&lt;/h1&gt;&lt;h2&gt;基本概念&lt;/h2&gt;&lt;p&gt;Cookie，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。&lt;/p&gt;&lt;p&gt;html5 中的 Web Storage 包括了两种存储方式：sessionStorage和localStorage。&lt;/p&gt;&lt;p&gt;sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。&lt;/p&gt;&lt;p&gt;而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。浏览器中同一个域下的窗口可以共享 localStorage 数据。&lt;/p&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://lz5z.com/categories/HTML/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="HTML5" scheme="https://lz5z.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>Python一些书写技巧</title>
    <link href="https://lz5z.com/Python%E4%B8%80%E4%BA%9B%E4%B9%A6%E5%86%99%E6%8A%80%E5%B7%A7/"/>
    <id>https://lz5z.com/Python一些书写技巧/</id>
    <published>2016-11-13T21:36:55.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>本文介绍了一些平时用到的Python书写技巧。之后会不断更新。<br><img src="/assets/img/python.png" alt="我是一只的图片" width="20%"></p><a id="more"></a><h2>交换变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">6</span></span><br><span class="line">y = <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">x, y = y, x</span><br><span class="line"> </span><br><span class="line">print(x, y) <span class="comment">#5 6</span></span><br></pre></td></tr></table></figure><h2>if 语句在行内</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Hello"</span>) <span class="keyword">if</span> <span class="keyword">True</span> <span class="keyword">else</span> <span class="string">"World"</span> <span class="comment">#Hello</span></span><br></pre></td></tr></table></figure><h2>连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">print(a + b) <span class="comment">#[1, 2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line">print(str(<span class="number">1</span>) + <span class="string">" world"</span>) <span class="comment">#1 world</span></span><br><span class="line"> </span><br><span class="line">print(`<span class="number">1</span>` + <span class="string">" world"</span>) <span class="comment">#1 world</span></span><br><span class="line"> </span><br><span class="line">print(<span class="number">1</span>, <span class="string">"world"</span>) <span class="comment">#1 world</span></span><br><span class="line"></span><br><span class="line">print(a, <span class="number">3</span>) <span class="comment">#[1, 2] 3</span></span><br></pre></td></tr></table></figure><h2>除法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">5.0</span>//<span class="number">2</span>) <span class="comment">#2 地板除</span></span><br><span class="line">print(<span class="number">2</span>**<span class="number">5</span>) <span class="comment">#32 2的5次方</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">.3</span>/<span class="number">.1</span>) <span class="comment">#2.9999999999999996</span></span><br><span class="line">print(<span class="number">.3</span>//<span class="number">.1</span>) <span class="comment">#2.0</span></span><br></pre></td></tr></table></figure><h2>数值比较</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">3</span> &gt; x &gt; <span class="number">1</span>:</span><br><span class="line">   print(x) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &lt; x &gt; <span class="number">0</span>:</span><br><span class="line">   print(x) <span class="comment">#2</span></span><br></pre></td></tr></table></figure><h2>迭代列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">names = (<span class="string">'Jack'</span>,<span class="string">'Leo'</span>,<span class="string">'Sony'</span>)</span><br><span class="line">ages = (<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>)</span><br><span class="line"><span class="keyword">for</span> a, n <span class="keyword">in</span> zip(names, ages):</span><br><span class="line">    print(a, n)</span><br><span class="line"><span class="comment">#Jack 2001</span></span><br><span class="line"><span class="comment">#Leo 2002</span></span><br><span class="line"><span class="comment">#Sony 2003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引</span></span><br><span class="line"><span class="keyword">for</span> index, a <span class="keyword">in</span> enumerate(names):</span><br><span class="line">    print(index, a)</span><br><span class="line"><span class="comment">#0 Jack</span></span><br><span class="line"><span class="comment">#1 Leo</span></span><br><span class="line"><span class="comment">#2 Sony</span></span><br></pre></td></tr></table></figure><h2>列表推导式</h2><p>已知一个列表，我们可以筛选出偶数列表方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">even = []</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span> number%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        even.append(number)</span><br><span class="line"></span><br><span class="line"><span class="comment">#转变成如下：</span></span><br><span class="line">even = [number <span class="keyword">for</span> number <span class="keyword">in</span> numbers <span class="keyword">if</span> number%<span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2>字典推导</h2><p>和列表推导类似，字典可以做同样的工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Jack'</span>,<span class="string">'Leo'</span>,<span class="string">'Sony'</span>]</span><br><span class="line">people = [&#123;key: value <span class="keyword">for</span> value, key <span class="keyword">in</span> enumerate(names)&#125;]</span><br><span class="line">print(people)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[&#123;<span class="string">'Sony'</span>: <span class="number">2</span>, <span class="string">'Leo'</span>: <span class="number">1</span>, <span class="string">'Jack'</span>: <span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure><h2>初始化列表的值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">0</span>]*<span class="number">3</span></span><br><span class="line">print(items)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2>列表转换为字符串</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">"Leo"</span>, <span class="string">"Jack"</span>, <span class="string">"Lucy"</span>]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">", "</span>.join(names)</span></span>)</span><br><span class="line">&gt;&gt;&gt; Leo, Jack, Lucy</span><br></pre></td></tr></table></figure><h2>从字典中获取元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'user'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Max'</span>, <span class="string">'age'</span>: <span class="number">4</span>&#125;</span><br><span class="line">is_admin = data.get(<span class="string">'admin'</span>, <span class="keyword">False</span>)</span><br><span class="line">print(is_admin)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2>切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">#前3个</span></span><br><span class="line">print(x[:<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">#中间4个</span></span><br><span class="line">print(x[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">#最后3个</span></span><br><span class="line">print(x[<span class="number">-3</span>:])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">#奇数项</span></span><br><span class="line">print(x[::<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">#偶数项</span></span><br><span class="line">print(x[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2>一行代码解决FizzBuzz</h2><p>有一个简单的编程练习叫FizzBuzz，问题引用如下：</p><p>写一个程序，打印数字1到100，3的倍数打印“Fizz”来替换这个数，5的倍数打印“Buzz”，对于既是3的倍数又是5的倍数的数字打印“FizzBuzz”。</p><p>这里就是一个简短的，有意思的方法解决这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):print(<span class="string">"fizz"</span>[x%<span class="number">3</span>*<span class="number">4</span>::]+<span class="string">"buzz"</span>[x%<span class="number">5</span>*<span class="number">4</span>::]<span class="keyword">or</span> x)</span><br></pre></td></tr></table></figure><h2>集合</h2><p>除了python内置的数据类型外，在collection模块同样还包括一些特别的用例，在有些场合Counter非常实用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">print(Counter(<span class="string">"hello"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(&#123;<span class="string">'l'</span>: <span class="number">2</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h2>迭代工具</h2><p>和collections库一样，还有一个库叫itertools，对某些问题真能高效地解决。其中一个用例是查找所有组合，他能告诉你在一个组中元素的所有不同的组合方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line">names = [<span class="string">"Leo"</span>, <span class="string">"Jack"</span>, <span class="string">"Lucy"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> combinations(names, <span class="number">2</span>):</span><br><span class="line">    print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'Leo'</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'Leo'</span>, <span class="string">'Lucy'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'Jack'</span>, <span class="string">'Lucy'</span>)</span><br></pre></td></tr></table></figure><h2>False == True</h2><p>在Python中，True和False是全局变量，因此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">False</span> = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">False</span>:</span><br><span class="line">   print(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">"World"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;本文介绍了一些平时用到的Python书写技巧。之后会不断更新。&lt;br&gt;&lt;img src=&quot;/assets/img/python.png&quot; alt=&quot;我是一只的图片&quot; width=&quot;20%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lz5z.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>换了一个 Blog 主题</title>
    <link href="https://lz5z.com/%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AABlog%E4%B8%BB%E9%A2%98/"/>
    <id>https://lz5z.com/换了一个Blog主题/</id>
    <published>2016-11-11T09:17:09.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>yilia</h1><p>前几天deploy博客的时候，发现打开blog页面是空的，只有head部分显示出来了。打开控制台排查问题，发现hexo主题里面有几个外部ajax call失败，导致整个页面都没有渲染出来，这是一件恼火的事情。<img src="/assets/img/angry.png" alt="我是一只生气的图片"></p><p>于是果断换主题，其实对之前的主题还是很满意的： 简洁，渲染速度也很快，功能虽然不多，但是基本满足我的需求。</p><p>这次选择的主题是腾讯的工程师Litten制作的 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">「yilia」</a></p><p>「yilia」 同样是我喜欢的简洁样式，作者甚至移除了搜索框。而且对于移动端的优化也做得很不错。</p><a id="more"></a><h1>yotuku</h1><p>之前Blog里面的图片一直都选择 <a href="http://yotuku.cn/" target="_blank" rel="noopener">「yotuku」</a> 生成在线图片，然后在markdown里面引用，如果图片大小或者位置不合适的话，会在md里面手写一段html，这样做很省事。</p><p>今天早上看自己的Blog发现有几张图片没有加载出来，以为是新主题渲染的问题，重新deploy以后发现还是没有。看来不是主题的锅。</p><p>使用控制台发现</p><img src="/assets/img/ajax_call_failure.png" alt="我是一只失败的图片"><p>原来这几张图片都没有拿到，已经在官网留言，希望能够解决。</p><p>不过使用免费云服务存储自己Blog的图片确实不太安全，像这样丢失图片的行为可能会导致几张图片加载不出来，但是如果以后云服务提供商挂掉了（这里不是诅咒yutuku不好，希望这样良心企业越来越好），那这些图片岂不就再也找不到了。</p><p>还是老老实实把图片放到Blog路径下，用相对地址引用吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;yilia&lt;/h1&gt;&lt;p&gt;前几天deploy博客的时候，发现打开blog页面是空的，只有head部分显示出来了。打开控制台排查问题，发现hexo主题里面有几个外部ajax call失败，导致整个页面都没有渲染出来，这是一件恼火的事情。&lt;img src=&quot;/assets/img/angry.png&quot; alt=&quot;我是一只生气的图片&quot;&gt;&lt;/p&gt;&lt;p&gt;于是果断换主题，其实对之前的主题还是很满意的： 简洁，渲染速度也很快，功能虽然不多，但是基本满足我的需求。&lt;/p&gt;&lt;p&gt;这次选择的主题是腾讯的工程师Litten制作的 &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「yilia」&lt;/a&gt;&lt;/p&gt;&lt;p&gt;「yilia」 同样是我喜欢的简洁样式，作者甚至移除了搜索框。而且对于移动端的优化也做得很不错。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="Hexo" scheme="https://lz5z.com/tags/Hexo/"/>
    
      <category term="Yilia" scheme="https://lz5z.com/tags/Yilia/"/>
    
      <category term="Theme" scheme="https://lz5z.com/tags/Theme/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 严格模式</title>
    <link href="https://lz5z.com/JavaScript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lz5z.com/JavaScript严格模式/</id>
    <published>2016-11-09T12:58:12.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对于某些不安全的操作也会抛出错误。（<a href="https://github.com/Leo555/JavaScript/blob/master/books/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%91%E4%B8%AD%E6%96%87%20%E9%AB%98%E6%B8%85%20%E5%AE%8C%E6%95%B4%20%E8%AF%A6%E7%BB%86%E4%B9%A6%E7%AD%BE%E7%89%88.pdf" target="_blank" rel="noopener">JavaScript高级程序设计</a>）</p><a id="more"></a><p>设立严格模式的目的：</p><ol><li>严格模式会将JavaScript陷阱直接变成明显的错误。</li><li>严格模式修正了一些引擎难以优化的错误。</li><li>同样的代码有些时候严格模式会比非严格模式下更快。</li><li>严格模式禁用了一些有可能在未来版本中定义的语法。</li></ol><h1>开启严格模式</h1><p>使用 ‘use strict’; 进入严格模式。 严格模式可以应用到整个script标签或个别函数中。</p><h2>为整个script标签开启严格模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个语句都开启严格模式的语法</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'严格模式script'</span>)</span><br></pre></td></tr></table></figure><p>注意： 如果要为整个script开启严格模式，‘use strict’; 一定要放在第一行。 如果担心文件合并带来严格模式与正常模式的混合，可以将script写成自执行函数的形式。</p><h2>为某个函数开启严格模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;　　</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"严格模式函数"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"正常模式函数"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>严格模式有哪些不同</h1><h2>全局变量显式声明</h2><p>在正常模式下，如果一个变量未声明就直接赋值，相当于创建一个全局变量。这给新人开发者带来便利的同时，给整个项目留下巨大隐患。严格模式将这种失误当成错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">a = <span class="string">'严格模式'</span>;  <span class="comment">//ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><h2>不再Silently Fail</h2><p>严格模式会使引起静默失败(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常。</p><h3>不可变量赋值</h3><p>例如： NaN 是一个不可写的全局变量. 在正常模式下, 给 NaN 赋值不会产生任何作用; 开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="literal">NaN</span> = <span class="number">3</span>; <span class="comment">//TypeError: Cannot assign to read only property 'NaN' of #&lt;Object&gt;</span></span><br></pre></td></tr></table></figure><p>给不可写属性赋值, 给只读属性(getter-only)赋值赋值, 给不可扩展对象(non-extensible object)的新属性赋值) 都会抛出异常:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可写属性赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"x"</span>, &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">obj1.x = <span class="number">9</span>; <span class="comment">// TypeError: Cannot assign to read only property 'x' of #&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给只读属性赋值</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    get x() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2.x = <span class="number">5</span>; <span class="comment">// TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可扩展对象的新属性赋值</span></span><br><span class="line"><span class="keyword">var</span> fixed = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = <span class="string">"haha"</span>; <span class="comment">// TypeError: Can't add property newProp, object is not extensible</span></span><br></pre></td></tr></table></figure><h3>删除不可删除属性</h3><p>在严格模式下, 试图删除不可删除的属性时会抛出异常(之前这种操作不会产生任何效果)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">//TypeError: Cannot delete property 'prototype' of function Object()</span></span><br></pre></td></tr></table></figure><h3>参数名唯一</h3><p>严格模式要求函数的参数名唯一。在正常模式下, 最后一个重名参数名会掩盖之前的重名参数。 之前的参数仍然可以通过 arguments[i] 来访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, a, c</span>) </span>&#123; <span class="comment">//SyntaxError: Strict mode function may not have duplicate parameter names</span></span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>禁止八进制数字语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">015</span> + <span class="comment">// SyntaxError: Octal literals are not allowed in strict mode.</span></span><br><span class="line">          <span class="number">197</span> +</span><br><span class="line">          <span class="number">142</span>;</span><br></pre></td></tr></table></figure><h2>简化变量的使用</h2><h3>禁用 with</h3><p>先看一个with的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="comment">//x: 4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>结果是2， with块内x为全局变量x。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>结果是17， with块内x为变量obj.x。</p><p>所以with中块内的x究竟是指全局变量x还是obj.x在运行之前是无法得知的，这对编译器优化十分不利，因此严格模式禁用 with。</p><h3>eval作用域</h3><p>严格模式下的 eval 不在为上层范围(surrounding scope,注:包围eval代码块的范围)引入新变量。</p><p>在正常模式下, 代码 eval(“var x;”) 会给上层函数(surrounding function)或者全局引入一个新的变量 x 。<br>严格模式下，eval语句本身就是一个作用域，它所生成的变量只能用于eval内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> evalX = <span class="built_in">eval</span>(<span class="string">"'use strict'; var x = 32; x"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">//17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> evalY = <span class="built_in">eval</span>(<span class="string">"var y = 32; y"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">//32</span></span><br></pre></td></tr></table></figure><h3>禁止删除声明变量</h3><p>严格模式禁止删除声明变量。delete name 在严格模式下会引起语法错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// SyntaxError: Delete of an unqualified identifier in strict mode.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var x; delete x;"</span>); <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h2>让eval和arguments变的简单</h2><h3>绑定或赋值</h3><p>eval 和 arguments 不能通过程序语法被绑定或赋值。 以下的所有尝试将引起语法错误:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="number">17</span>;</span><br><span class="line"><span class="built_in">arguments</span>++;</span><br><span class="line">++<span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    set p(<span class="built_in">arguments</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> (<span class="built_in">arguments</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">eval</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="function"><span class="keyword">function</span> <span class="title">eval</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arguments"</span>, <span class="string">"'use strict'; return 17;"</span>);</span><br></pre></td></tr></table></figure><h3>arguments对象</h3><p>arguments对象不再追踪参数的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    a = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pair = f(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(pair[<span class="number">0</span>] === <span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(pair[<span class="number">1</span>] === <span class="number">17</span>);</span><br></pre></td></tr></table></figure><h3>不再支持 arguments.callee</h3><p>正常模式下，arguments.callee 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span>.callee; &#125;;</span><br><span class="line">f(); <span class="comment">// TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them</span></span><br></pre></td></tr></table></figure><h2>“安全的” JavaScript</h2><p>严格模式下更容易写出“安全”的JavaScript。</p><h3>this关键字</h3><p>在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;　　　　</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);　　</span><br><span class="line">&#125;　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;　　　　</span><br><span class="line"><span class="meta">    "use strict"</span>;　　　　</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.bind(<span class="number">3</span>)();  <span class="comment">//[Number: 3]</span></span><br><span class="line">f1.bind(<span class="number">3</span>)();  <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>对一个普通的函数来说，this总会是一个对象：不管调用时this它本来就是一个对象；还是用布尔值，字符串或者数字调用函数时函数里面被封装成对象的this；还是使用undefined或者null调用函数时this代表的全局对象（使用call, apply或者bind方法来指定一个确定的this）。</p><p>这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患。</p><p>所以对于一个开启严格模式的函数，指定的this不再被封装为对象，而且如果没有指定this的话它值是undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">assert(fun() === <span class="literal">undefined</span>);</span><br><span class="line">assert(fun.call(<span class="number">2</span>) === <span class="number">2</span>);</span><br><span class="line">assert(fun.apply(<span class="literal">null</span>) === <span class="literal">null</span>);</span><br><span class="line">assert(fun.call(<span class="literal">undefined</span>) === <span class="literal">undefined</span>);</span><br><span class="line">assert(fun.bind(<span class="literal">true</span>)() === <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2>为未来的ECMAScript版本铺平道路</h2><h3>保留的关键字</h3><p>在严格模式中一部分字符变成了保留的关键字。这些字符包括implements, interface, let, package, private, protected, public,<br>static和yield。在严格模式下，你不能再用这些名字作为变量名或者形参名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">package</span>(<span class="params">protected</span>) // !!!</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> implements; <span class="comment">// !!!</span></span><br><span class="line"></span><br><span class="line">    interface: <span class="comment">// !!!</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> interface; <span class="comment">// !!!</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// !!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">static</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">&#125; <span class="comment">// !!!</span></span><br></pre></td></tr></table></figure><h3>函数声明</h3><p>严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// !!! 语法错误</span></span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) // 合法</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eit</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 同样合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>总结</h1><p>严格模式虽然限制了一部分JavaScript书写和运行的自由，但是随着JavaScript在更大的工程中扮演更重要的角色，规范化是必经之路。</p><h1>参考链接</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">MDN严格模式</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener">Javascript 严格模式详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对于某些不安全的操作也会抛出错误。（&lt;a href=&quot;https://github.com/Leo555/JavaScript/blob/master/books/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E3%80%91%E4%B8%AD%E6%96%87%20%E9%AB%98%E6%B8%85%20%E5%AE%8C%E6%95%B4%20%E8%AF%A6%E7%BB%86%E4%B9%A6%E7%AD%BE%E7%89%88.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JavaScript高级程序设计&lt;/a&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 递归优化</title>
    <link href="https://lz5z.com/JavaScript%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/"/>
    <id>https://lz5z.com/JavaScript递归优化/</id>
    <published>2016-11-03T00:35:34.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>在之前的项目 <strong>Regional Guideline</strong> 中，有一个操作点击 Ext 树的一个结点，展开这个结点的全部子树（树的深度未知），刚开始看到 TreeNode 中有一个名为 expand 的 Public Method， 其API如下：</p><p><img src="http://i1.piimg.com/567571/c1346477e1e277a6.png" alt=""><br>[公司使用的版本为ExtJS 3.3]</p><a id="more"></a><p>简单明了，expand 第一个参数 deep 是一个 Boolean 型参数，如果为true的话，就展开当前结点以及子结点的所有子结点。</p><p>于是没有多加思考就用了。在开发测试环节一直没有出现什么问题，可是到了 Production 测试，帮忙测试的同学发现： 在操作树的时候，有时候浏览器会崩溃。刚开始以为是特殊情况，浏览器问题之类的，没有在意。可是不断地测试发现浏览器崩溃的情况是可复现的，就是在某几个固定的树展开的时候会出现这个问题。可见这不是浏览器的问题，是我代码的问题。</p><p>排查代码，发现这个 expand 方法似乎是罪魁祸首。查看ExtJS源码，果然是这个家伙的问题，原来这个函数使用递归的方式去展开所有的子结点，而当子结点比较多的时候，内存和CPU的消耗变得非常大，于是浏览器就崩溃了。</p><h1>分析问题</h1><p>首先查看 ExtJS 源码， TreeNode 中的 expand 方法的源码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expand this node.</span></span><br><span class="line"><span class="comment"> * @param &#123;Boolean&#125; deep (optional) True to expand all children as well</span></span><br><span class="line"><span class="comment"> * @param &#123;Boolean&#125; anim (optional) false to cancel the default animation</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; callback (optional) A callback to be called when</span></span><br><span class="line"><span class="comment"> * expanding this node completes (does not wait for deep expand to complete).</span></span><br><span class="line"><span class="comment"> * Called with 1 parameter, this node.</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; scope (optional) The scope (this reference) in which the callback is executed. Defaults to this TreeNode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">expand : <span class="function"><span class="keyword">function</span>(<span class="params">deep, anim, callback, scope</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.expanded)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.fireEvent(<span class="string">'beforeexpand'</span>, <span class="keyword">this</span>, deep, anim) === <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.childrenRendered)&#123;</span><br><span class="line">            <span class="keyword">this</span>.renderChildren();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.expanded = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isHiddenRoot() &amp;&amp; (<span class="keyword">this</span>.getOwnerTree().animate &amp;&amp; anim !== <span class="literal">false</span>) || anim)&#123;</span><br><span class="line">            <span class="keyword">this</span>.ui.animExpand(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.fireEvent(<span class="string">'expand'</span>, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">this</span>.runCallback(callback, scope || <span class="keyword">this</span>, [<span class="keyword">this</span>]);</span><br><span class="line">                <span class="keyword">if</span>(deep === <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">this</span>.expandChildNodes(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.createDelegate(<span class="keyword">this</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ui.expand();</span><br><span class="line">            <span class="keyword">this</span>.fireEvent(<span class="string">'expand'</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.runCallback(callback, scope || <span class="keyword">this</span>, [<span class="keyword">this</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.runCallback(callback, scope || <span class="keyword">this</span>, [<span class="keyword">this</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deep === <span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.expandChildNodes(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expandChildNodes 的源码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expand all child nodes</span></span><br><span class="line"><span class="comment"> * @param &#123;Boolean&#125; deep (optional) true if the child nodes should also expand their child nodes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">expandChildNodes : <span class="function"><span class="keyword">function</span>(<span class="params">deep, anim</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cs = <span class="keyword">this</span>.childNodes,</span><br><span class="line">        i,</span><br><span class="line">        len = cs.length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            cs[i].expand(deep, anim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看调用关系，发现 expand 方法如果传参 deep = true 的话会调用 expandChildNodes 方法去展开当前结点的子结点，而 expandChildNodes 方法又调用 expand 方法逐个展开子结点的所有子结点。 这样就变成了递归。</p><h2>说说递归</h2><p>假设有一个求和函数sum： sum(n) = ∑ k</p><h3>循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = n;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result += --n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环自然是速度和性能最好的，但是在编写复杂的代码时，循环代码的数学描述性不够强。</p><h3>普通递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n + sum(--n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述递归的方式可以说是将代码与数学描述完美结合，以上代码给一个完全不懂编程的人也看得懂。</p><p>但是我们分析其计算过程，比如计算sum(5)的时候，其计算过程是这样的:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span> + sum(<span class="number">4</span>))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + sum(<span class="number">3</span>)))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + sum(<span class="number">2</span>))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + (<span class="number">2</span> + sum(<span class="number">1</span>)))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + (<span class="number">2</span> + <span class="number">1</span>))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">3</span> + (<span class="number">3</span>))))</span><br><span class="line">(<span class="number">5</span> + (<span class="number">4</span> + (<span class="number">6</span>))</span><br><span class="line">(<span class="number">5</span> + <span class="number">10</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>这样的计算有什么问题呢？</p><p>我们知道线程在执行代码的时候，计算机会分配一定大小的栈空间，每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回地址、调用位置等等），这些信息会占用一定空间，成千上万个此类空间累积起来，可能会导致栈溢出。</p><h3>尾递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, total = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum(--x, x + total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 sum(5)的时候，其过程是这样的:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sum</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(<span class="number">3</span>, <span class="number">9</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(<span class="number">2</span>, <span class="number">12</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(<span class="number">1</span>, <span class="number">14</span>)</span></span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>sum() 函数多了一个 total 参数，这个参数记录在递归调用时上一次计算的结果，并将其传入下一次递归调用中。每一次函数调用都发生在函数最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p><p>函数在尾部调用自身，就称为尾递归。</p><p>尾递归的本质，其实是将递归方法中的需要的“所有状态”通过方法的参数传入下一次调用中。</p><p>与普通递归相比，由于尾递归的调用处于方法的最后，因此方法之前所积累下的各种状态对于递归调用结果已经没有任何意义，因此完全可以把本次方法中留在堆栈中的数据完全清除，把空间让给最后的递归调用。这样的优化使得递归不会在调用堆栈上产生堆积，意味着即使是“无限”递归也不会让堆栈溢出。这便是尾递归的优势。</p><h2>ES6 对尾递归的支持</h2><p>ES6 中将会资磁zīcí尾递归优化，通过尾递归优化，JavaScript 代码在解释成机器码的时候，会将尾递归函数解释成 while 函数，达到写的时候表达性强，运行的时候速度高的效果。</p><p>下面来看 Babel 编译的效果，将上述为递归的 sum 函数编译后如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">_x2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">var</span> _again = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    _function: <span class="keyword">while</span> (_again) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = _x2;</span><br><span class="line">        _again = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> total = _arguments.length &lt;= <span class="number">1</span> || _arguments[<span class="number">1</span>] === <span class="literal">undefined</span> ? <span class="number">0</span> : _arguments[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x + total;</span><br><span class="line">        &#125;</span><br><span class="line">        _arguments = [_x2 = --x, x + total];</span><br><span class="line">        _again = <span class="literal">true</span>;</span><br><span class="line">        total = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">continue</span> _function;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>严格模式</h2><p>ES6的尾递归优化只在严格模式下开启，正常模式是无效的。<br>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><pre><code>* arguments：返回调用时函数的参数。* func.caller：返回调用当前函数的那个函数。</code></pre><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><h1>解决问题</h1><p>回到最早的问题，如何高效地展开一棵不知深浅的树？</p><p>当时并没有尾递归方面的知识，而且改 Ext 源码也不是那么方便，于是通过 Google 知道了一个比较好的解决方案：使用栈代替递归。</p><p>怎么做呢？</p><p>要展开一棵树，首先将树的根结点入栈，然后一个节点一个节点出栈，每次出栈后，将出栈节点的所有子节点入栈，以此达到遍历一颗树的效果。出栈的过程中逐一展开当前节点的字结点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expandAllChildNodes: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodeStack = [];</span><br><span class="line">    nodeStack.push(node);</span><br><span class="line">    <span class="keyword">while</span> (nodeStack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> nodeTop = nodeStack.pop();</span><br><span class="line">        <span class="keyword">if</span> (nodeTop.hasChildNodes()) &#123;</span><br><span class="line">            nodeTop.expand();</span><br><span class="line">            nodeStack = nodeStack.concat(nodeTop.childNodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法将递归转化为栈，可读性也不是很差，算是一个不错的解决方案。测试发现之前几个导致浏览器崩溃的树都可以完美展开，O(∩_∩)O~~。</p><h1>总结</h1><p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p><p>循环代表着高效，递归代表着易读，如果能将递归方便地转化为循环是想必那是极好的，可是如果转化不是那么方便的话，尽量使用尾递归。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;在之前的项目 &lt;strong&gt;Regional Guideline&lt;/strong&gt; 中，有一个操作点击 Ext 树的一个结点，展开这个结点的全部子树（树的深度未知），刚开始看到 TreeNode 中有一个名为 expand 的 Public Method， 其API如下：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://i1.piimg.com/567571/c1346477e1e277a6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;[公司使用的版本为ExtJS 3.3]&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://lz5z.com/categories/Algorithm/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 异步解决方案 async/await</title>
    <link href="https://lz5z.com/JavaScript%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://lz5z.com/JavaScript异步解决方案/</id>
    <published>2016-11-01T22:54:01.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>异步操作一直都是 JavaScript 中一个比较麻烦的事情，从最早的 callback hell，到TJ大神的 co，再到 Promise 对象，然后ES6中的 Generator 函数，每次都有所改进，但都不是那么彻底，而且理解起来总是很复杂。</p><p>直到 async/await 出现，让写异步的人根本不用关心它是不是异步，可以说是目前最好的 JavaScript 异步解决方案。</p><a id="more"></a><p>ECMAScript 2016(ES7) 中已经确定支持 async/await，那我们怎么能够落后呢？</p><p>本文是 async/await 的学习笔记，涵盖基本用法以及一些小 demo。</p><h2>async 函数是什么</h2><p>阮一峰的 Blog <a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a>, 对async的定义一语中的：<strong>async 函数就是 Generator 函数的语法糖。</strong></p><p>假如有一个Generator函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> f(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> f(<span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = generator.next();</span><br><span class="line">ret.value.then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">let</span> ret1 = generator.next(data);</span><br><span class="line">    ret1.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        generator.next(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将 gen 函数写成 async 函数，就是下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncF = <span class="keyword">async</span>(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">await</span>(f(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">await</span>(f(<span class="number">2000</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><h3>说明</h3><p>由于目前的大部分浏览器和 NodeJS 环境还不支持 async/await，所以本文程序借助 “asyncawait” 实现，需要额外安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install asyncawait</span></span><br></pre></td></tr></table></figure><p>当然如果你对 babel 比较熟悉的话，也可以通过 babel 将 async/await 编译为 ES5，就可直接运行了。</p><h2>async/await 使用规则</h2><ul><li>async 表示这是一个async函数，await只能用在这个函数里面。</li><li>await 如果后面是异步函数，跟在后面的应该是一个Promise对象。</li><li>await 表示在这里等待Promise返回结果了，再继续执行。</li></ul><h2>获得返回值</h2><p>可以看到使用 Generator 的时候获取返回值必须使用 .then() 方法，而使用 async/await 就简单很多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'asyncawait/async'</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">await</span> = <span class="built_in">require</span>(<span class="string">'asyncawait/await'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">await</span>(f(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(f1);</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">await</span>(f(<span class="number">2000</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(f2);</span><br><span class="line">&#125;))();</span><br></pre></td></tr></table></figure><p>await 等待的虽然是 promise 对象，但不必写使用 .then()，也可以得到返回值。</p><h2>捕捉异常</h2><p>既然 .then() 不用写了，那 .catch()也不用写，可以直接用标准的try<br>catch语法捕捉错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>));</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span>(f(<span class="number">3000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err.message); <span class="comment">// 这里捕捉到错误 `error`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))();</span><br></pre></td></tr></table></figure><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中</p><h2>循环使用 await</h2><p>await 最好用的地方是可以写在 for 循环里面，这是Promise无法做到的，使得 async/await 看起来更像是同步代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(time);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="keyword">async</span>(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`当前是第<span class="subst">$&#123;i&#125;</span>次等待..`</span>);</span><br><span class="line">        <span class="keyword">await</span>(f(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;异步操作一直都是 JavaScript 中一个比较麻烦的事情，从最早的 callback hell，到TJ大神的 co，再到 Promise 对象，然后ES6中的 Generator 函数，每次都有所改进，但都不是那么彻底，而且理解起来总是很复杂。&lt;/p&gt;&lt;p&gt;直到 async/await 出现，让写异步的人根本不用关心它是不是异步，可以说是目前最好的 JavaScript 异步解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="ES7" scheme="https://lz5z.com/tags/ES7/"/>
    
      <category term="async" scheme="https://lz5z.com/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程</title>
    <link href="https://lz5z.com/Python%E5%8D%8F%E7%A8%8B/"/>
    <id>https://lz5z.com/Python协程/</id>
    <published>2016-10-25T22:02:48.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>第一次听同学提到协程 Coroutine，说是一个类似于多线程而又不是多线程的东西，听得云里雾里，不觉明厉。后来找了个机会好好看了一下相关的知识，发现协程是一个很有趣的东西。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="noopener">Wiki百科</a>给协程的定义是：“与子例程一样，协程也是一种程序组件。。。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务，迭代器，无限列表和管道。”</p><p>那什么是子程序呢？<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">Wiki百科</a>给出的定义是：“在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method, subprogram, callable unit），是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。”</p><a id="more"></a><p>后来翻阅多方资料，相信我可以把协程讲清楚。</p><h1>概念理解</h1><p>假如程序中有两种函数，我们把它们命名为 <strong>自私函数</strong>和 <strong>无私函数</strong>。由于CPU资源非常宝贵，每个函数都希望自己能够被执行。</p><p><strong>自私函数</strong>选择对自己最有利的方案，每次都有自己执行完毕(return)才把CPU资源交给别的函数，于是所有的函数按照调用顺序依次执行。</p><p><strong>无私函数</strong>由于学过纳什均衡愿意牺牲自己一部分利益换取群里利益最大化，当然对方必须也是无私函数。因此无私函数可以在自己还没有执行完(not return)的时候把CPU资源交给别人。</p><p>比如有这个两个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'1'</span>)</span><br><span class="line">    print(<span class="string">'2'</span>)</span><br><span class="line">    print(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'x'</span>)</span><br><span class="line">    print(<span class="string">'y'</span>)</span><br><span class="line">    print(<span class="string">'z'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">A()</span><br><span class="line">B()</span><br></pre></td></tr></table></figure><p>如果这两个函数都是自私函数，那么调用顺序决定输出结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>而如果两个函数都是无私函数，那么在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。可能出现的结果是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line"><span class="number">3</span></span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>看起来好像两个函数同时执行了。但是一定要注意，这里只有一个线程。</p><p>无私函数之间相互协作完成任务，所以称为“协程”。</p><p>无私函数（协程）通过yield来调用其它无私函数（协程）。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。所以协程在执行过程中可以中断该子程序，去执行其他子程序。</p><h2>协程与子程序</h2><p>协程与子程序的根本区别是 <strong>执行时期控制权能否转接</strong>。</p><h2>协程与多线程</h2><p>协程只有一个线程在执行，由于 CPU 速度非常快，所以能达到（看起来）多个任务同时执行的效果。</p><p>用小时候非常喜欢看的《龙珠》做比喻就是，协程就是残像拳，悟空不断地在A和B两地移动，速度非常快，看起来就像两个悟空一样；而多线程就是沙鲁分泌出来的小沙鲁，每个小沙鲁都能独立作战。</p><h1>协程的使用</h1><h2>yield</h2><p>创建一个斐波那契序列的生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用for in消费这些数据</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib(<span class="number">20</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>当一个函数中包含 yield 语句时，python 会自动将其识别为一个生成器。这时 fib() 并不会真正调用函数体，而是以函数体生成了一个生成器对象实例。</p><p>yield 在这里可以保留fib函数的计算现场（a, b的值），暂停fib的计算并将 b 返回。而将 fib 放入 for…in 循环中时，每次循环都会调用 next(fib())，唤醒生成器，执行到下一个 yield 语句处，直到抛出 StopIteration 异常。此异常会被 for 循环捕获，导致跳出循环。</p><p>执行的时候发现速度非常快，而且不会给内存带来很大的压力，因为每一次i的值都是动态生成的，而不需要把它们存储在列表中。更概括的说上面的例子中使用 yield 便可获得了一个协程，协程会消费掉发送给它的值。</p><h2>send</h2><p>从上面的程序中可以看到，目前只有数据从 fib() 中通过 yield 流向外面的 for 循环；如果可以向 fib() 发送数据，那不是就可以在 Python 中实现协程了嘛。</p><p>平时写程序的时候总是会遇到一些比较耗时的操作，比如读写文件，读取网络等，所以我们给刚才的 fib() 函数加上一段休眠变成慢速 fib()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; n:</span><br><span class="line">        sleep_cnt = <span class="keyword">yield</span> b</span><br><span class="line">        print(<span class="string">'let me think %.2f secs'</span> % sleep_cnt)</span><br><span class="line">        time.sleep(sleep_cnt)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sfib = slow_fib(<span class="number">20</span>)</span><br><span class="line">fib_res = next(sfib) <span class="comment">#sfib.send(None)</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    print(fib_res)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fib_res = sfib.send(random.uniform(<span class="number">0</span>, <span class="number">0.5</span>))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>其中 next(sfib) 相当于 sfib.send(None)，可以使得sfib运行至第一个 yield 处返回。后续的 sfib.send(random.uniform(0, 0.5))则将一个随机的秒数发送给 sfib，作为当前中断的 yield 表达式的返回值。</p><p>于是，Python 中的生成器有了 send 函数，yield 表达式也拥有了返回值。</p><h2>grep</h2><p>Python 实现的 grep 也是一个很好的协程的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">    print(<span class="string">"Searching for"</span>, pattern)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            print(line)</span><br></pre></td></tr></table></figure><p>调用方式：使用 next() 启动一个协程，协程中包含的生成器并不是立刻执行，而是通过 next() 方法来响应 send() 方法。因此，你必须通过 next() 方法来执行 yield 表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>) </span><br><span class="line">next(search)  <span class="comment">#Searching for coroutine</span></span><br></pre></td></tr></table></figure><p>使用 send() 向 search 传值,当传入的值中包含 ‘coroutine’ 时，输出传入的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search.send(<span class="string">"I love you"</span>)</span><br><span class="line">search.send(<span class="string">"Don't you love me?"</span>)</span><br><span class="line">search.send(<span class="string">"I love coroutine instead!"</span>)  <span class="comment">#I love coroutine instead!</span></span><br></pre></td></tr></table></figure><p>通过 close() 方法来关闭一个协程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search.close()</span><br></pre></td></tr></table></figure><h2>生产者消费者</h2><p>下面来看一个完整的生产者消费者的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    c.send(<span class="keyword">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure><p>注意到 consumer 函数是一个 generator，把一个 consumer 传入 produce 后：</p><ol><li>首先调用 c.send(None) 启动生成器；</li><li>然后，一旦生产了东西，通过 c.send(n) 切换到 consumer 执行；</li><li>consumer 通过 yield 拿到消息，处理，又通过 yield 把结果传回；</li><li>produce 拿到 consumer 处理的结果，继续生产下一条消息；</li><li>produce 决定不生产了，通过 c.close() 关闭 consumer，整个过程结束。</li></ol><p>整个流程无锁，由一个线程执行，produce 和 consumer 协作完成任务，所以称为“协程”。</p><h1>总结</h1><p>每次使用协程都要依赖生成器是不是很麻烦呢？</p><p>Python3.5 引入 async/await 让协程表面上独立于生成器而存在，让 Python 写协程更加方便。</p><p>学习完成后会更新博客，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;第一次听同学提到协程 Coroutine，说是一个类似于多线程而又不是多线程的东西，听得云里雾里，不觉明厉。后来找了个机会好好看了一下相关的知识，发现协程是一个很有趣的东西。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wiki百科&lt;/a&gt;给协程的定义是：“与子例程一样，协程也是一种程序组件。。。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务，迭代器，无限列表和管道。”&lt;/p&gt;&lt;p&gt;那什么是子程序呢？&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wiki百科&lt;/a&gt;给出的定义是：“在计算机科学中，子程序（英语：Subroutine, procedure, function, routine, method, subprogram, callable unit），是一个大型程序中的某部分代码，由一个或多个语句块组成。它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。”&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lz5z.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="协程" scheme="https://lz5z.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Coroutine" scheme="https://lz5z.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Oracle LISTAGG 长度大于 4000 解决方案</title>
    <link href="https://lz5z.com/Oracle%20LISTAGG%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E4000%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://lz5z.com/Oracle LISTAGG长度大于4000解决方案/</id>
    <published>2016-10-24T10:11:35.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>公司业务网站上有一个可以 Free input 的 textarea，长度没有限制，可是存到 DB 的时候 Oracle varchar2 最大长度限制是4000，于是聪明的同事使用分而治之的方式解决了这个问题。如果长度大于某个值就新建一个 record 存储，然后使用 seq_num 记录表示其顺序。</p><a id="more"></a><h1>listagg</h1><p>上周做 report 的时候需要把这个 column 的数据生成给别的部门的同事，于是首先想到的是用 Oracle 的 listagg 函数。</p><p>listagg 可以将多行合并成为一行。<br>具体使用如下：</p><p>比如有这样一张表 Employee</p><table><thead><tr><th style="text-align:center">employee_id</th><th style="text-align:center">department_id</th><th style="text-align:center">first_name</th><th style="text-align:center">last_name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">Leo</td><td style="text-align:center">Li</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">Jack</td><td style="text-align:center">Li</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">Lucy</td><td style="text-align:center">Li</td></tr></tbody></table><p>需要得到所有 “last_name” 为Li的 “first_name”， 并且用&quot;; &quot;分隔，显示效果如下:</p><table><thead><tr><th style="text-align:center">department_id</th><th style="text-align:center">first_names</th><th style="text-align:center">last_name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Leo; Jack; Lucy</td><td style="text-align:center">Li</td></tr></tbody></table><p>于是可以使用 sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(department_id) department_id,</span><br><span class="line">  <span class="keyword">listagg</span>(first_name, <span class="string">'; '</span>) <span class="keyword">within</span> <span class="keyword">GROUP</span> (</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id) first_names,</span><br><span class="line">  <span class="keyword">MAX</span>(last_name) last_name</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> department_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> last_name       = <span class="string">'Li'</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id department_id,</span><br><span class="line">       <span class="keyword">LISTAGG</span>(first_name, <span class="string">'; '</span>)</span><br><span class="line">      <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_id) first_names,</span><br><span class="line">      last_name</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id,last_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><h1>遇到的问题</h1><p>由于该 textare 是 Free Input 的，你不能确定用户到底输入了多少个字符，于是我第一次尝试使用 listagg 的时候发现超过 varchar2 的最大长度4000了。怎么办呢？首先想到的是截取字符串，如果超过4k就截取前面4k的部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="keyword">LISTAGG</span>(**, <span class="string">'; '</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> **), <span class="number">0</span>, <span class="number">3999</span>)...</span><br></pre></td></tr></table></figure><p>然并暖（😄），因为在超过4k长度的那部分，使用 listagg 就已经报错了，并不是 select 的时候报错的</p><p>于是 Google 之，输入关键词 <strong>listagg 4000 characters</strong>，在 Oracle 社区发现已经有大神给出了<a href="https://community.oracle.com/thread/2548234" target="_blank" rel="noopener">解决方案</a>。</p><h1>解决方案</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set long 10000</span><br><span class="line">SQL&gt; select listagg(id, ',') within group (order by id)</span><br><span class="line">  2    from (<span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">as</span> <span class="keyword">id</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt; <span class="number">1050</span>)</span><br><span class="line">  <span class="number">3</span>  /</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">as</span> <span class="keyword">id</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt; <span class="number">1050</span>)</span><br><span class="line">                                *</span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">2</span>:</span><br><span class="line">ORA<span class="number">-01489</span>: <span class="keyword">result</span> <span class="keyword">of</span> <span class="keyword">string</span> concatenation <span class="keyword">is</span> too <span class="keyword">long</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select rtrim(xmlagg(xmlelement(e,id,',').extract('//text()') order by id).GetClobVal(),',')</span><br><span class="line">  2    from (<span class="keyword">select</span> <span class="keyword">level</span> <span class="keyword">as</span> <span class="keyword">id</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span> &lt; <span class="number">1050</span>)</span><br><span class="line">  <span class="number">3</span>  /</span><br><span class="line"></span><br><span class="line"><span class="keyword">RTRIM</span>(<span class="keyword">XMLAGG</span>(<span class="keyword">XMLELEMENT</span>(E,<span class="keyword">ID</span>,<span class="string">','</span>).EXTRACT(<span class="string">'//TEXT()'</span>)ORDERBYID).GETCLOBVAL(),<span class="string">','</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18.</span>..</span><br></pre></td></tr></table></figure><p>将 level 参数不断扩大发现均能查到结果，不确定最大支持多长的字符，不过20000也能查到结果，相信能满足大部分需求。</p><h1>总结</h1><p>如果使用 listagg 出现 <strong><em>result of string concatenation is too long</em></strong> 的错误时候，可以尝试使用 XMLAGG 代替。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;公司业务网站上有一个可以 Free input 的 textarea，长度没有限制，可是存到 DB 的时候 Oracle varchar2 最大长度限制是4000，于是聪明的同事使用分而治之的方式解决了这个问题。如果长度大于某个值就新建一个 record 存储，然后使用 seq_num 记录表示其顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="Oracle" scheme="https://lz5z.com/tags/Oracle/"/>
    
      <category term="listagg" scheme="https://lz5z.com/tags/listagg/"/>
    
  </entry>
  
  <entry>
    <title>如何判断页面编码</title>
    <link href="https://lz5z.com/%E5%88%A4%E6%96%AD%E9%A1%B5%E9%9D%A2%E7%BC%96%E7%A0%81/"/>
    <id>https://lz5z.com/判断页面编码/</id>
    <published>2016-10-17T14:52:44.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h2>W3C</h2><p>在编写微博爬虫的时候，稍微学习了一下网页编码的知识，主要来自于 <a href="https://www.w3.org/TR/html4/charset.html" target="_blank" rel="noopener"><strong>W3C</strong></a> 官方文档的 5.2.2 小节。</p><blockquote><p>To sum up, conforming user agents must observe the following priorities when determining a document’s character encoding (from highest priority to lowest):</p></blockquote><blockquote><ol><li>An HTTP “charset” parameter in a “Content-Type” field.</li><li>A META declaration with “http-equiv” set to “Content-Type” and a value set for “charset”.</li><li>The charset attribute set on an element that designates an external resource.</li></ol></blockquote><p>首先看 http 头信息中的 <strong>Content-Type</strong> 字段，如果没有的话，会查看 <strong>Meta</strong> 信息，如果还没有的话，会查看一些外部资源的信息，比如css或者JavaScript的charset字段。<br>如果以上信息依然不能确定编码的话，就采用默认的 <strong>ISO-8859-1</strong> 字符集去解析网页。</p><h2>gb2312 页面解析</h2><p>在爬取 “珠海市人力资源和社会保障局” 的网站的时候，遇到中文编码 gb2312，使用 <a href="https://github.com/ashtuchkin/iconv-lite" target="_blank" rel="noopener">iconv-lite</a> 对其进行处理，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">const</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> req = request(<span class="string">'http://www.zhrsj.gov.cn/xinxi/gzzk/'</span>);</span><br><span class="line">req.on(<span class="string">'error'</span>, (err)=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> chunks = [];</span><br><span class="line">req.on(<span class="string">'data'</span>, (res)=&gt; &#123;</span><br><span class="line">    chunks.push(res);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'end'</span>, ()=&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> decodedBody = iconv.decode(Buffer.concat(chunks), <span class="string">'gb2312'</span>);</span><br><span class="line">    <span class="keyword">let</span> $ = cheerio.load(decodedBody);</span><br><span class="line">    $(<span class="string">"table[width='96%']"</span>).find(<span class="string">'tr'</span>).each(<span class="function">(<span class="params">index, e</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = $(e).children();</span><br><span class="line">        <span class="built_in">console</span>.log(a.eq(<span class="number">1</span>).text());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;W3C&lt;/h2&gt;&lt;p&gt;在编写微博爬虫的时候，稍微学习了一下网页编码的知识，主要来自于 &lt;a href=&quot;https://www.w3.org/TR/html4/charset.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;W3C
      
    
    </summary>
    
      <category term="HTML" scheme="https://lz5z.com/categories/HTML/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="HTML" scheme="https://lz5z.com/tags/HTML/"/>
    
      <category term="编码" scheme="https://lz5z.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>微博情绪分析</title>
    <link href="https://lz5z.com/%E5%BE%AE%E5%8D%9A%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90/"/>
    <id>https://lz5z.com/微博情绪分析/</id>
    <published>2016-10-16T22:55:00.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>本项目ITA的一个大数据学习的项目，以下是我的大体思路。</p><ol><li>使用node.js爬虫每天从「新浪微博」上爬取一定数量的微博。主要实现登录，抓取发布微博，抓取关注人和粉丝的功能，暂时把数据存放在MongoDB中。</li><li>对微博进行分词，分词是非常复杂的功能，需要机器学习训练模型，因此采用哈工大开源项目<a href="http://www.ltp-cloud.com/" target="_blank" rel="noopener">「LTP-Cloud」</a>直接调用现成API。感谢哈工大社会计算与信息检索研究中心 (HIT-SCIR)。</li><li>然后对分词后的词语进行情绪分析，这里使用大连理工大学林鸿飞教授带领全体教研室成员整理而成的<a href="http://ir.dlut.edu.cn/EmotionOntologyDownload" target="_blank" rel="noopener">「情感词汇本体库」</a>。</li><li>最后使用spark将情绪分析结果进行数据整合。</li></ol><a id="more"></a><h2>weibo_crawler</h2><p>第一部分是准备数据，随机爬取50w左右的微博用户，然后每天爬取他们前一天发布的微博作为本项目的数据源。</p><p>爬取用户信息采用递归的方式，随机以某个用户为起点，然后爬取该用户的关注和粉丝，然后递归地爬取关注和粉丝的信息。只需要得到用户名、用户ID即可。</p><p>由于新浪微博对爬虫有限制，因此爬取用户微博的时候采用定时器的方式。</p><p>由于只有登录了才能获取某个用户的个人信息和关注粉丝信息，而微博爬虫的难点就在于用户登录。</p><p>使用<strong>HttpFox</strong>抓取登录时候的http请求，发现微博登录分为两部分，第一部分是预登陆，第二部分是登录，需要传递用户名、密码等信息。使用 <a href="https://github.com/request/request" target="_blank" rel="noopener">request</a> 模拟这个登录过程。</p><p>抓取一定的用户后，每天定时爬取这些用户前一天发布的微博。使用<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">cheerio</a> 对返回的页面信息进行解析。</p><p>解析页面是一个难度不大，但是非常繁琐的过程，因为微博页面中有很多「无用」的Dom元素，比如广告啊，热门话题啊，还有好友动态之类的跟本项目完全无关。于是使用正则表达式先把关键信息提取，再使用cheerio解析，速度可以接受。</p><p>中途遇到一个问题，就是有时候拿不到数据，分析原因可能有三种：<br>1. 网络原因<br>2. 可能是新浪限制<br>3. 关注和粉丝不一定是“人”</p><p>采用的解决方案：<br>1. 对抓取微博失败的，Retry 5次<br>2. 放弃非人类</p><p>什么是非人类呢？我在抓取一个人的关注列表的时候发现<br><img src="/assets/img/weibo.png" alt="我是一只的图片"><br>原来「北京」并不是一个用户，而是一个话题，打开「北京」页面发现它的Dom结构与普通用户的Dom结构并不相同，于是果断放弃非人类。</p><h2>微博分词 Big Bang</h2><p>分词就是把一句话变成一个一个单词的过程。举个栗子吧：<br>我是中国人。<br>我 - 是 - 中国 - 人</p><p>前几天锤子M1/M1L发布会上最大的亮点就是这个Big Bang功能，让手机端对文字地操作更进一步。</p><h3>分词难在哪里</h3><p>国务院总理李克强调研上海外高桥时提出，支持上海积极探索新机制。</p><ol><li>正确的分词结果：<br>国务院/ 总理/ 李克强/ 调研/ 上海/ 外高桥/ 时/ 提出/ ，/ 支持/ 上海/ 积极/ 探索/ 新/ 机制/ 。</li><li>错误的分词结果<br>国务院/ 总理/ 李克/ 强调/ 研/ 上海 …</li></ol><h3>解决方案</h3><p>本项目采用<a href="http://www.ltp-cloud.com/" target="_blank" rel="noopener">语言技术平台</a>(Language Technology Platform，LTP)<br>语言技术平台是哈工大社会计算与信息检索研究中心历时十年研制的一整套开放中文自然语言处理系统。</p><p>使用方式有两种，Get和Post。本项目采用Post的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.ltp-cloud.com/analysis/'</span>;</span><br><span class="line"><span class="keyword">var</span> param = &#123;</span><br><span class="line">    <span class="string">'api_key'</span>: <span class="string">'***'</span>,</span><br><span class="line">    <span class="string">'pattern'</span>: <span class="string">'ws'</span>,</span><br><span class="line">    <span class="string">'text'</span>: <span class="string">'我是中国人'</span></span><br><span class="line">    <span class="string">'format'</span>: <span class="string">'plain'</span></span><br><span class="line">&#125;;</span><br><span class="line">Request.post(url,  &#123;<span class="attr">form</span>: param&#125;, callback);</span><br></pre></td></tr></table></figure><p>callback 里面会传回来分词后的结果。</p><h2>情绪分析</h2><p>情绪分析是将一个词语分出词性种类、情感类别、情感强度及极性，国外比较有影响的Ekman的6大类情感分类。</p><p>比如：<br><img src="/assets/img/sentiment.png" alt="我是一只的图片"></p><h3>中文情感词汇本体</h3><p>大连理工大学林鸿飞教授带领全体教研室成员整理而成的<a href="http://ir.dlut.edu.cn/EmotionOntologyDownload" target="_blank" rel="noopener">「情感词汇本体库」</a>，是目前最权威的中文情绪词典，共含有情感词共计27466个。</p><h4>情感分类</h4><ol><li>情感分为7大类（乐，好，怒，哀，惧，恶，惊）21小类。</li><li>情感强度分为1,3,5,7,9五档，9表示强度最大，1为强度最小。</li><li>词性种类一共分为7类，分别是名词（noun），动词（verb），形容词（adj），副词（adv），网络词语（nw），成语（idiom），介词短语（prep）。</li><li>极性标注，0代表中性，1代表褒义，2代表贬义，3代表兼有褒贬两性。</li></ol><p>下图是一些示例：<br><img src="/assets/img/sentiment_sample.png" alt="我是一只的图片" width="80%"></p><h3>情绪分析存在的问题</h3><ul><li><p>只能分析词汇，不能分析语法结构<br>快乐都是别人的，高兴一天天离我而去<br>分析结果: PA<em>5+PA</em>5</p></li><li><p>自定义情绪算法并不能很好的反应情绪值<br>词性： 褒义1； 贬义-1； 中性和两性0；<br>算法 ： ∑ (词性*强度)</p></li><li><p>Cost比较大<br>140字的微博分词后如果有80个词，需要比较80次。如果一次分析200条微博，需要比较200*80=16000次</p></li></ul><h3>解决方案</h3><p>真正想要解决情绪分析还是要靠机器学习和人工智能。<br>Google于2016年5月13号开源自然语言理解技术<a href="https://github.com/tensorflow/models/tree/master/syntaxnet" target="_blank" rel="noopener">SyntaxNet</a>，并且支持中文。<img src="/assets/img/XDPB.jpg" alt="我是一只的图片" width="5%"></p><p>准备学习之。</p><h2>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;本项目ITA的一个大数据学习的项目，以下是我的大体思路。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用node.js爬虫每天从「新浪微博」上爬取一定数量的微博。主要实现登录，抓取发布微博，抓取关注人和粉丝的功能，暂时把数据存放在MongoDB中。&lt;/li&gt;&lt;li&gt;对微博进行分词，分词是非常复杂的功能，需要机器学习训练模型，因此采用哈工大开源项目&lt;a href=&quot;http://www.ltp-cloud.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「LTP-Cloud」&lt;/a&gt;直接调用现成API。感谢哈工大社会计算与信息检索研究中心 (HIT-SCIR)。&lt;/li&gt;&lt;li&gt;然后对分词后的词语进行情绪分析，这里使用大连理工大学林鸿飞教授带领全体教研室成员整理而成的&lt;a href=&quot;http://ir.dlut.edu.cn/EmotionOntologyDownload&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「情感词汇本体库」&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;最后使用spark将情绪分析结果进行数据整合。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://lz5z.com/categories/Big-Data/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="Big Data" scheme="https://lz5z.com/tags/Big-Data/"/>
    
      <category term="情绪分析" scheme="https://lz5z.com/tags/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 let 和 const</title>
    <link href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84let%E5%92%8Cconst/"/>
    <id>https://lz5z.com/JavaScript中的let和const/</id>
    <published>2016-10-16T10:12:21.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，是没有块级作用域的概念的，在代码块内声明的变量，其作用域是整个函数作用域而不是块级作用域。let 和 const 作为加强版的 var，让程序员写出更安全，更高效的代码。</p><a id="more"></a><h2>let</h2><p>用 let 定义的变量与 var 有三个区别：块级作用域、不会变量提升，不能定义同名变量。</p><h3>块级作用域</h3><p>var 是函数作用域；let 是块作用域。在 ES6 之前，是没有块级作用域的说法的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Leo'</span></span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Leo</span></span><br></pre></td></tr></table></figure><p>while 体里面定义的变量在代码块外也可以访问到，而使用 let 就不会出现这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Leo'</span></span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure><h3>变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="string">'something'</span></span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>使用 var 定义的变量，JavaScript 解析器会自动把定义搬到最前面，然后在原来定义的地方赋值。所以上述代码就变成了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// undefined</span></span><br><span class="line">value = <span class="string">'something'</span></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// something</span></span><br></pre></td></tr></table></figure><p>而 let 则不会出现这样的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// ReferenceError: value is not defined</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">'something'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><h3>同名变量</h3><p>用 var 定义变量时，我们可以多次对它进行定义，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这样的代码是不会报错的，在 let 定义的相同块中定义同名变量时就会报错了，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><h2>const</h2><p>const 除了具有 let 的块级作用域和不会变量提升外，还有就是它定义的是常量，在用 const 定义变量后，我们就不能修改它了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AA = <span class="number">2</span></span><br><span class="line">AA = <span class="number">3</span> <span class="comment">//TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>每一个通过 const 声明的变量必须进行初始化，否则抛出语法错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name <span class="comment">//Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p>const 声明的对象不能修改绑定，但是允许修改值，这也就意味着 const 声明的对象可以修改属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">name: <span class="string">'Leo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以修改属性值</span></span><br><span class="line">person.name = <span class="string">'Leo555'</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line"><span class="comment">// &#123;name: "Leo555", age: 18&#125;</span></span><br><span class="line">person = &#123;</span><br><span class="line">name: <span class="string">'Leo'</span></span><br><span class="line">&#125; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><h2>临时死区</h2><p>var 声明的变量会自动提升， let 和 const 声明的变量则不会，如果在声明之前访问这些变量，则会引发错误。从作用域顶部到声明变量语句之前的这个区域，成为临时死区(temporal dead zone) 简称 TDZ。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">'555'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value) <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="string">'555'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很神奇，如果 js 解释器逐句解释，在函数作用域内，不解释到最后一句，都无法知道会发生什么。</p><p>如果在 let 和 const 作用域之外使用该变量则不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">'555'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>循环绑定</h2><p>var 声明使得在循环中创建和使用函数总是有一些问题。比如想要每一秒输出一个递增的数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来预期输出 0 - 4，结果输出了 5 个 5。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 let 和 const 出现之前是使用闭包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;, a * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 let 就简单很多了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let 在循环中每一次都创建一个新的变量，并且将其初始化为当前 i 的值，所以循环内部创建的每个函数都能得到 i 值得副本。for-in 循环和 for-of 循环也是一样的。</p><p>而 const 不能用于下面的循环，由 const 声明的 i 为常量，当对齐运行 ++ 运算的时候报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//TypeError: Assignment to constant variable.</span></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-in 循环和 for-of 循环由于都是创建新的变量将其绑定为当前迭代值，所以不会出现上述问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aa = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> a <span class="keyword">of</span> aa) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> a <span class="keyword">in</span> aa) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 中，是没有块级作用域的概念的，在代码块内声明的变量，其作用域是整个函数作用域而不是块级作用域。let 和 const 作为加强版的 var，让程序员写出更安全，更高效的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="let" scheme="https://lz5z.com/tags/let/"/>
    
      <category term="const" scheme="https://lz5z.com/tags/const/"/>
    
      <category term="ES6" scheme="https://lz5z.com/tags/ES6/"/>
    
      <category term="TDZ" scheme="https://lz5z.com/tags/TDZ/"/>
    
  </entry>
  
  <entry>
    <title>nssm 将应用写入 Windows 服务</title>
    <link href="https://lz5z.com/nssm%E5%B0%86%E5%BA%94%E7%94%A8%E5%86%99%E5%85%A5Windows%E6%9C%8D%E5%8A%A1/"/>
    <id>https://lz5z.com/nssm将应用写入Windows服务/</id>
    <published>2016-10-13T09:42:52.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>安装</h1><hr><p><a href="http://nssm.cc/" target="_blank" rel="noopener">nssm</a>是一个 Windows 服务管理器，可以把应用写入服务，以达到自动重启的功能。</p><p>目前最新的版本是2.24，<a href="http://nssm.cc/download" target="_blank" rel="noopener">下载地址</a>。 下载完成以后解压到某个路径下，然后将 win64/win32 文件路径（D:\nssm-2.24\win64）添加的环境变量 Path。</p><a id="more"></a><h1>使用</h1><h2>Node</h2><p>假设有一个最简单的 node 服务器程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app is listening at port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要将其写入 Windows 服务。</p><p>打开控制台工具。输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nssm install node_test</span></span><br></pre></td></tr></table></figure><p>之后会显示出GUI界面：</p><p>输入<strong>Path</strong>为 node.exe安装路径，<strong>Startup directory</strong> 为应用文件路径，<strong>Arguments</strong> 为启动文件</p><p>点击 Install service</p><p>然后打开 Windows 的 Services，看到刚才安装的应用已经在 Services 里面了，并且为 “Automatic”，说明它会随着 Windows 启动而自动启动。</p><p>右击-“start”启动该服务，或者在命令行中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nssm start node_test</span></span><br></pre></td></tr></table></figure><p>在浏览器中查看效果</p><p>在控制台输入 nssm 查看所有命令，可以看出 nssm 使用极其简单，参考<a href="http://nssm.cc/usage" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nssm install <span class="meta">[&lt;servicename&gt;]</span></span><br><span class="line">$ nssm remove <span class="meta">[&lt;servicename&gt;]</span></span><br><span class="line">$ nssm start &lt;servicename&gt;</span><br><span class="line">$ nssm stop &lt;servicename&gt;</span><br><span class="line">$ nssm restart &lt;servicename&gt;</span><br><span class="line">$ nssm edit &lt;servicename&gt;</span><br></pre></td></tr></table></figure><h2>bat</h2><p>Windows 中可以使用批处理文件做一些自动化和重复性的工作，bat 文件单击即可运行。</p><p>假如还是在刚才 index.js 文件夹下面有一个 bat 文件,文件内容：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">index</span>.js <span class="number">1</span>&gt; app.log <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们将 bat 文件写入 Windows Services （记得提前移除刚才写入的node_test服务）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nssm install node_test_bat</span></span><br></pre></td></tr></table></figure><p>这次路径直接选择 bat 文件即可，因为它是可执行文件。</p><p>启动 bat 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nssm start node_test_bat</span></span><br></pre></td></tr></table></figure><p>在浏览器中输入**<a href="http://localhost:3000/**%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C,%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%B7%B2%E7%BB%8F%E6%88%90%E5%8A%9F%E5%BC%80%E5%90%AF%EF%BC%8C%E8%80%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%9C%A8" target="_blank" rel="noopener">http://localhost:3000/**查看效果,发现服务已经成功开启，而且这个时候在</a> index.js 文件夹里面发现了一个<br><strong>app.log</strong> 文件，里面记录着node服务器的输入日志：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app is listening at<span class="built_in"> port </span>3000</span><br></pre></td></tr></table></figure><p>于是就在 nssm 监控管理 node 服务的同时，还拥有了一个简单的日志系统，是不是很方便。</p><h2>Python</h2><p>将 Python 应用写入 Windows 服务也可以使用上述两种方法。</p><h3>nssm 启动 bat 服务报错</h3><p>遇到 bat 文件双击可以运行，但是写入服务却不能运行的情况。</p><p>通过 Google 发现是可能是因为同时安装 Python2 和 Python3 导致的，因此改变 bat 文件为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">py</span> -<span class="number">3</span> main.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>写入服务即可。</p><h1>注意</h1><p>注意非常不推荐把一个运行一次就结束的程序写入 Windows Services 的，比如 Node 或者 Python 脚本里面只有一句输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello'</span>)</span><br></pre></td></tr></table></figure><p>使用 Windows 自带的 Services 手动启动：</p><p>使用 nssm 启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node_test: Unexpected status SERVICE_PAUSED <span class="keyword">in</span> response to START control.</span></span><br></pre></td></tr></table></figure><p>因为应用启动后立即结束，所以应用进入<strong>Paused</strong> 的状态。</p><p>但是可以把定时任务写入 Services。</p><p>如果对 Python 定时任务感兴趣，可以移步<a href="https://lz5z.com/Python%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">Python定时任务的实现方式</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;安装&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;http://nssm.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nssm&lt;/a&gt;是一个 Windows 服务管理器，可以把应用写入服务，以达到自动重启的功能。&lt;/p&gt;&lt;p&gt;目前最新的版本是2.24，&lt;a href=&quot;http://nssm.cc/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;。 下载完成以后解压到某个路径下，然后将 win64/win32 文件路径（D:\nssm-2.24\win64）添加的环境变量 Path。&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://lz5z.com/categories/Windows/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
      <category term="nssm" scheme="https://lz5z.com/tags/nssm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中 的this</title>
    <link href="https://lz5z.com/JavaScript%E4%B8%AD%E7%9A%84this/"/>
    <id>https://lz5z.com/JavaScript中的this/</id>
    <published>2016-10-08T21:48:25.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>变幻莫测的 this</h1><p>在JavaScript中，this的指向变幻莫测。首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，大概可以分为以下这几种情况。</p><a id="more"></a><h2>this 与 window 对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Leo'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//window</span></span><br><span class="line">&#125;</span><br><span class="line">hi();</span><br></pre></td></tr></table></figure><p>在这里this指向调用它的对象，也就是window对象，所以上面的调用 <strong>hi()</strong> 相当于 <strong>window.hi()</strong></p><h2>this 与普通对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Leo'</span>,</span><br><span class="line">    hi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Leo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hi();</span><br></pre></td></tr></table></figure><p>这里的this指向的是对象 person，因为你调用这个 hi 是通过 person.hi() 执行的。这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁(是这样的吗？)。</p><p>我们再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>; <span class="comment">//相当于 window.name = 'window'</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Leo'</span>,</span><br><span class="line">    hi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Leo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.person.hi();</span><br></pre></td></tr></table></figure><p>此时 hi 函数是由 window 对象调用，如果上述说法成立的话应该输出 <strong>window</strong> 才对，那究竟为什么this没有指向window呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:<span class="number">12</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//12</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></table></figure><p>很明显 fn 函数是由对象 o 调用的，而这里的 this 指向了对象 b 呢。</p><p>所以this的指向应该为：</p><ol><li>如果函数被上一级的对象所调用，那么this指向的就是上一级的对象(上级对象可能为window)。</li><li>如果函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a:<span class="number">10</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:<span class="number">12</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure><p>这里this指向的是window，因为函数最后是由window对象调用。</p><p>总结：<strong>this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的</strong></p><h2>严格模式</h2><p>在严格模式中，this的指向稍有不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Leo'</span>,</span><br><span class="line">    hi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Leo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hi() <span class="comment">// Leo</span></span><br><span class="line"><span class="keyword">var</span> hi = person.hi</span><br><span class="line">hi() <span class="comment">//  Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure><p>第二次调用 hi() 的时候，正常模式会输出 window，而严格模式则会报错，因为在严格模式中，禁止this指向全局对象，所以此时的 this 为 undefined。</p><h2>this 与 new</h2><p>假如函数为构造函数，那this会指向什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Leo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">//Leo</span></span><br></pre></td></tr></table></figure><p>使用new关键字创建了一个Fn的实例，并且将变量 a 指向这个实例（相当于复制了一份Fn到对象a里面）。此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a。</p><h2>this 与 return</h2><p>如果 new 出来的对象中return一个新对象的时候，情况会有所不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Leo'</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>JavaScript中所有的函数都是有返回值的，如果没有显式地指明返回值，则默认返回 undefined。</p><p>在上面的例子中，Fn返回了一个对象，此时this指向这个对象，所以结果为 undefined。</p><p>虽然null也是对象，但是在这里this还是指向那个函数的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Leo'</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">//Leo</span></span><br></pre></td></tr></table></figure><p>如果返回值是一个对象(非null对象)，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p><h1>总结</h1><ol><li>如果一个函数中有this，但是它没有被上级对象调用，那么this指向window或者undefied(严格模式)。</li><li>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</li><li>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</li><li>如果一个函数中有this，当使用「new + 函数」实例化一个对象时，如果函数的返回值是一个对象(非null对象)，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是函数的实例。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;变幻莫测的 this&lt;/h1&gt;&lt;p&gt;在JavaScript中，this的指向变幻莫测。首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，大概可以分为以下这几种情况。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="this" scheme="https://lz5z.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>scala 学习笔记</title>
    <link href="https://lz5z.com/scala%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://lz5z.com/scala学习笔记/</id>
    <published>2016-10-02T19:28:00.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<img src="/assets/img/scala.png" alt="我是一只的图片" width="20%"><h1>安装Scala</h1><p>到Scala官方下载地址下载：<a href="http://scala-lang.org/download/" target="_blank" rel="noopener">http://scala-lang.org/download/</a></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http:<span class="comment">//downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz</span></span><br><span class="line">$ tar zxf <span class="keyword">scala</span>-2.11.8.tgz</span><br><span class="line">$ <span class="keyword">cd</span> <span class="keyword">scala</span>-2.11.8</span><br><span class="line">$ ./bin/<span class="keyword">scala</span></span><br><span class="line">Welcome to <span class="keyword">Scala</span> <span class="keyword">version</span> 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_60).</span><br><span class="line"><span class="keyword">Type</span> <span class="keyword">in</span> expressions to have them evaluated.</span><br><span class="line"><span class="keyword">Type</span> :<span class="keyword">help</span> <span class="keyword">for</span> <span class="keyword">more</span> information.</span><br><span class="line"><span class="keyword">scala</span>&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2>RELP</h2><p>刚才我们已经启动了Scala RELP，它是一个基于命令行的交互式编程环境。我们可以在RELP中做一些代码尝试而不用启动IDE，这在我们思考问题时非常的方便。对于Java有一个好消息，JDK 9干始将内建支持RELP功能。</p><p>Scala是一个面向对象的函数式特性编程语言，它继承了Java的面向对特性，同时又从Haskell等其它语言那里吸收了很多函数式特性并做了增强。</p><h2>环境变量</h2><p>将scala文件夹移入平时装软件的地方，我常用的地方是 <strong>/usr/local</strong>, 重命名为scala，并打开bashrc文件配置环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mv scala-2.11.8 /usr/<span class="built_in">local</span>/scala</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gedit ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>将scala配入环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">SCALA_HOME</span>=/usr/local/scala</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$&#123;SCALA_HOME&#125;</span>/bin:$PATH</span><br></pre></td></tr></table></figure><h1>变量、基础数据类型</h1><p>Scala中变量不需要显示指定类型，但需要提前声明。这可以避免很多命名空间污染问题。Scala有一个很强大的类型自动推导功能，它可以根据右值及上下文自动推导出变量的类型。你可以通过如下方式来直接声明并赋值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val <span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line"><span class="selector-tag">a</span>: Int = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; val <span class="selector-tag">b</span> = true</span><br><span class="line"><span class="selector-tag">b</span>: Boolean = true</span><br><span class="line"></span><br><span class="line">scala&gt; val c = <span class="number">1.0</span></span><br><span class="line">c: Double = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">scala&gt; val <span class="selector-tag">a</span> = <span class="number">30</span> + <span class="string">"岁"</span></span><br><span class="line"><span class="selector-tag">a</span>: String = <span class="number">30</span>岁</span><br></pre></td></tr></table></figure><h3>Immutable</h3><p>函数式编程有一个很重要的特性：不可变性。Scala中除了变量的不可变性，它还定义了一套不可变集合scala.collection.immutable</p><p>val代表这是一个final variable，它是一个常量。定义后就不可以改变，相应的，使用var定义的就是平常所见的变量了，是可以改变的。从终端的打印可以看出，Scala从右值自动推导出了变量的类型。Scala可以如动态语言似的编写代码，但又有静态语言的编译时检查。这对于Java中冗长、重复的类型声明来说是一种很好的进步。</p><p>注：在RELP中，val变量是可以重新赋值的，这是｀RELP`的特性。在平常的代码中是不可以的。</p><h3>基础数据类型</h3><p>Scala中基础数据类型有：Byte、Short、Int、Long、Float、Double，Boolean，Char、String。和Java不同的是，Scala中没在区分原生类型和装箱类型，如：int和Integer。它统一抽象成Int类型，这样在Scala中所有类型都是对象了。编译器在编译时将自动决定使用原生类型还是装箱类型。</p><h4>字符串</h4><p>Scala中的字符串有3种。</p><ol><li>分别是普通字符串，它的特性和Java字符串一致。</li><li>连线3个双引号在Scala中也有特殊含义，它代表被包裹的内容是原始字符串，可以不需要字符转码。这一特性在定义正则表达式时很有优势。</li><li>还有一种被称为“字符串插值”的字符串，他可以直接引用上下文中的变量，并把结果插入字符串中。</li></ol><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val c2 = <span class="string">'李'</span></span><br><span class="line">c2: <span class="built_in">Char</span> = 李</span><br><span class="line"></span><br><span class="line">scala&gt; val s1 = <span class="string">"Hello 李"</span></span><br><span class="line">s1: <span class="built_in">String</span> = Hello 李</span><br><span class="line"></span><br><span class="line">scala&gt; val s2 = <span class="string">s"Hello $&#123;c2&#125;"</span></span><br><span class="line">s2: <span class="built_in">String</span> = Hello 李</span><br><span class="line"></span><br><span class="line">scala&gt; val s3 = <span class="string">s"""Hello"李"\n$&#123;c2&#125;Leo"""</span></span><br><span class="line">s3: <span class="built_in">String</span> =</span><br><span class="line"><span class="string">Hello"李"</span></span><br><span class="line">李Leo</span><br></pre></td></tr></table></figure><h2>运算符和命名</h2><p>Scala中的运算符其实是定义在对象上的方法（函数），你看到的诸如：3 + 2其实是这样子的：3.+(2)。+符号是定义在Int对象上的一个方法。支持和Java一至的运算符（方法）：</p><p>注：在Scala中，方法前的.号和方法两边的小括号在不引起歧义的情况下是可以省略</p><ul><li>比较运算: ==、!=</li><li>逻辑运算: !、|、&amp;、^</li><li>位运算: &gt;&gt;、&lt;&lt;</li></ul><p>在Scala中，修正了（算更符合一般人的常规理解吧）==和!=运算符的含义。在Scala中，==和!=是执行对象的值比较，相当于Java中的equals方法。而对象的引用比较需要使用eq和ne两个方法来实现。</p><h2>控制语句（表达式）</h2><p>Scala中支持if、while、for comprehension（for表达式)、match case（模式匹配）四大主要控制语句。Scala不支持switch和?:两种控制语句，但它的if和match case会有更好的实现。</p><h3>if</h3><p>Scala支持if语句，其基本使用和Java、Python中的一样。但不同的时，它是有返回值的。</p><p>注：Scala是函数式语言，函数式语言还有一大特性就是：表达式。函数式语言中所有语句都是基于“表达式”的，而“表达式”的一个特性就是它会有一个值。所有像Java中的? :3目运算符可以使用if语句来代替。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> <span class="keyword">if</span> (<span class="literal">true</span>) <span class="string">"真"</span> <span class="keyword">else</span> <span class="string">"假"</span></span></span><br><span class="line">res0: String = 真</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val f = <span class="keyword">if</span> (<span class="literal">false</span>) <span class="string">"真"</span> <span class="keyword">else</span> <span class="string">"假"</span></span></span><br><span class="line">f: String = 假</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val unit = <span class="keyword">if</span> (<span class="literal">false</span>) <span class="string">"真"</span></span></span><br><span class="line">unit: Any = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val unit2 = <span class="keyword">if</span> (<span class="literal">true</span>) <span class="string">"真"</span> </span></span><br><span class="line">unit2: Any = 真</span><br></pre></td></tr></table></figure><p>可以看到，if语句也是有返回值的，将表达式的结果赋给变量，编译器也能正常推导出变量的类型。unit和unit2变量的类型是Any，这是因为else语句的缺失，Scala编译器就按最大化类型来推导，而Any类型是Scala中的根类型。()在Scala中是Unit类型的实例，可以看做是Java中的Void。</p><h3>while</h3><p>Scala中的while循环语句：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(条件)</span> &#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>for comprehension</h3><p>Scala中也有for表达式，但它和Java中的for不太一样，它具有更强大的特性。通常的for语句如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 &lt;- 集合) &#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala中for表达式除了上面那样的常规用法，它还可以使用yield关键字将集合映射为另一个集合：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val <span class="keyword">list</span> = <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">list</span>: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; val list2 = <span class="keyword">for</span> (item &lt;- <span class="keyword">list</span>) <span class="keyword">yield</span> item + <span class="number">1</span></span><br><span class="line">list2: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>还可以在表达式中使用if判断：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val list3 = <span class="keyword">for</span> (item &lt;- <span class="keyword">list</span> <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">yield</span> item</span><br><span class="line">list3: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>还可以做flatMap操作，解析2维列表并将结果摊平（将2维列表拉平为一维列表）：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val llist = <span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="keyword">List</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line">llist: <span class="keyword">List</span>[<span class="keyword">List</span>[<span class="keyword">Int</span>]] = <span class="keyword">List</span>(<span class="keyword">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="keyword">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="keyword">List</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span> &#123;</span><br><span class="line">     |   l &lt;- llist</span><br><span class="line">     |   item &lt;- l <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">     | &#125; <span class="keyword">yield</span> item</span><br><span class="line">res3: <span class="keyword">List</span>[<span class="keyword">Int</span>] = <span class="keyword">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>看到了，Scala中for comprehension的特性是很强大的。Scala的整个集合库都支持这一特性，包括：Seq、Map、Set、Array……</p><p>Scala没有C-Like语言里的for (int i = 0; i &lt; 10; i++)语法，但Range（范围这个概念），可以基于它来实现循环迭代功能。在Scala中的使用方式如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for (i &lt;- (<span class="number">0</span> until <span class="number">10</span>)) &#123;</span><br><span class="line">     |   println(i)</span><br><span class="line">     | &#125;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>Scala中还有一个to方法：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; (for (i &lt;- (<span class="number">0</span> to <span class="number">10</span>)) print(<span class="string">" "</span> + i))</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>你还可以控制每次步进的步长，只需要简单的使用<code>by</code>方法即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">10</span> by <span class="number">2</span>) print(<span class="string">" "</span> + i)</span><br><span class="line"> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>match case</strong><br>模式匹配，是函数式语言很强大的一个特性。它比命令式语言里的<code>switch</code>更好用，表达性更强。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">level</span></span>(s: <span class="type">Int</span>) = s <span class="keyword">match</span> &#123;</span><br><span class="line">     |   <span class="keyword">case</span> n <span class="keyword">if</span> n &gt;= <span class="number">90</span> =&gt; <span class="string">"优秀"</span></span><br><span class="line">     |   <span class="keyword">case</span> n <span class="keyword">if</span> n &gt;= <span class="number">80</span> =&gt; <span class="string">"良好"</span></span><br><span class="line">     |   <span class="keyword">case</span> n <span class="keyword">if</span> n &gt;= <span class="number">70</span> =&gt; <span class="string">"良"</span></span><br><span class="line">     |   <span class="keyword">case</span> n <span class="keyword">if</span> n &gt;= <span class="number">60</span> =&gt; <span class="string">"及格"</span></span><br><span class="line">     |   <span class="keyword">case</span> _ =&gt; <span class="string">"差"</span></span><br><span class="line">     | &#125;</span><br><span class="line">level: (s: <span class="type">Int</span>)<span class="type">String</span></span><br><span class="line"></span><br><span class="line">scala&gt; level(<span class="number">51</span>)</span><br><span class="line">res28: <span class="type">String</span> = 差</span><br><span class="line"></span><br><span class="line">scala&gt; level(<span class="number">93</span>)</span><br><span class="line">res29: <span class="type">String</span> = 优秀</span><br><span class="line"></span><br><span class="line">scala&gt; level(<span class="number">80</span>)</span><br><span class="line">res30: <span class="type">String</span> = 良好</span><br></pre></td></tr></table></figure><p>可以看到，模式匹配可以实现<code>switch</code>相似的功能。但与<code>switch</code>需要使用<code>break</code>明确告知终止之后的判断不同，Scala中的<code>match case</code>是默认<strong>break</strong>的。只要其中一个<code>case</code>语句匹配，就终止之后的所以比较。且对应<code>case</code>语句的表达式值将作为整个<code>match case</code>表达式的值返回。</p><h2>集合</h2><p>在Scala中，常用的集合类型有：<code>List</code>、<code>Set</code>、<code>Map</code>、<code>Tuple</code>、<code>Vector</code>等。</p><p><strong>List</strong></p><p>Scala中<code>List</code>是一个不可变列表集合，它很精妙的使用递归结构定义了一个列表集合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>除了之前使用<code>List</code>object来定义一个列表，还可以使用如下方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="number">1</span> :: <span class="number">2</span> :: <span class="number">3</span> :: <span class="number">4</span> :: <span class="number">5</span> :: <span class="type">Nil</span></span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><code>List</code>采用前缀操作的方式（所有操作都在列表顶端（开头））进行，<code>::</code>操作符的作用是将一个元素和列表连接起来，并把元素放在列表的开头。这样<code>List</code>的操作就可以定义成一个递归操作。添加一个元素就是把元素加到列表的开头，List只需要更改下头指针，而删除一个元素就是把List的头指针指向列表中的第2个元素。这样，<code>List</code>的实现就非常的高效，它也不需要对内存做任何的转移操作。<code>List</code>有很多常用的方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; list.indexOf(<span class="number">3</span>)</span><br><span class="line">res6: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="number">0</span> :: list</span><br><span class="line">res8: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list.reverse</span><br><span class="line">res9: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list.filter(item =&gt; item == <span class="number">3</span>)</span><br><span class="line">res11: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list</span><br><span class="line">res12: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> list2 = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">list2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list.intersect(list2)</span><br><span class="line">res13: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list.union(list2)</span><br><span class="line">res14: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list.diff(list2)</span><br><span class="line">res15: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Scala中默认都是<strong>Immutable collection</strong>，在集合上定义的操作都不会更改集合本身，而是生成一个新的集合。这与Java集合是一个根本的区别，Java集合默认都是可变的。</p><p><strong>Tuple</strong></p><p>Scala中也支持<strong>Tuple</strong>（元组）这种集合，但最多只支持22个元素（事实上Scala中定义了<code>Tuple0</code>、<code>Tuple1</code>……<code>Tuple22</code>这样22个<code>TupleX</code>类。和大多数语言的Tuple类似（比如：Python），Scala也采用小括号来定义元组。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tuple1: (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; tuple1._2</span><br><span class="line">res17: <span class="type">Int</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> tuple2 = <span class="type">Tuple2</span>(<span class="string">"Leo"</span>, <span class="string">"Li"</span> )</span><br><span class="line">tuple2: (<span class="type">String</span>, <span class="type">String</span>) = (<span class="type">Leo</span>,<span class="type">Li</span>)</span><br></pre></td></tr></table></figure><p>可以使用<code>xxx._[X]</code>的形式来引用<code>Tuple</code>中某一个具体元素，其<code>_[X]</code>下标是从1开始的，一直到22（若有定义这么多）。</p><p><strong>Set</strong></p><p><code>Set</code>是一个不重复且无序的集合，初始化一个<code>Set</code>需要使用<code>Set</code>对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> set = <span class="type">Set</span>(<span class="string">"Scala"</span>, <span class="string">"Java"</span>, <span class="string">"C++"</span>, <span class="string">"Javascript"</span>, <span class="string">"C#"</span>, <span class="string">"Python"</span>, <span class="string">"PHP"</span>) </span><br><span class="line">set: scala.collection.immutable.<span class="type">Set</span>[<span class="type">String</span>] = <span class="type">Set</span>(<span class="type">Scala</span>, <span class="type">C</span>#, <span class="type">Python</span>, <span class="type">Javascript</span>, <span class="type">PHP</span>, <span class="type">C</span>++, <span class="type">Java</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; set + <span class="string">"Go"</span></span><br><span class="line">res21: scala.collection.immutable.<span class="type">Set</span>[<span class="type">String</span>] = <span class="type">Set</span>(<span class="type">Scala</span>, <span class="type">C</span>#, <span class="type">Python</span>,<span class="type">Javascript</span>, <span class="type">PHP</span>, <span class="type">C</span>++, <span class="type">Java</span>, <span class="type">Go</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; set filterNot (item =&gt; item == <span class="string">"PHP"</span>)</span><br><span class="line">res22: scala.collection.immutable.<span class="type">Set</span>[<span class="type">String</span>] = <span class="type">Set</span>(<span class="type">Scala</span>, <span class="type">C</span>#, <span class="type">Python</span>, <span class="type">Javascript</span>, <span class="type">C</span>++, <span class="type">Java</span>)</span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>Scala中的<code>Map</code>默认是一个<strong>HashMap</strong>，其特性与Java版的<code>HashMap</code>基本一至，除了它是<code>Immutable</code>的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">"a"</span> -&gt; <span class="string">"A"</span>, <span class="string">"b"</span> -&gt; <span class="string">"B"</span>)</span><br><span class="line">map: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(a -&gt; <span class="type">A</span>, b -&gt; <span class="type">B</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> map2 = <span class="type">Map</span>((<span class="string">"b"</span>, <span class="string">"B"</span>), (<span class="string">"c"</span>, <span class="string">"C"</span>))</span><br><span class="line">map2: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(b -&gt; <span class="type">B</span>, c -&gt; <span class="type">C</span>)</span><br></pre></td></tr></table></figure><p>Scala中定义<code>Map</code>时，传入的每个<code>Entry</code>（<strong>K</strong>、<strong>V</strong>对）其实就是一个<code>Tuple2</code>（有两个元素的元组），而<code>-&gt;</code>是定义<code>Tuple2</code>的一种便捷方式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; map + (<span class="string">"z"</span> -&gt; <span class="string">"Z"</span>)</span><br><span class="line">res23: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(a -&gt; <span class="type">A</span>, b -&gt; <span class="type">B</span>, z -&gt; <span class="type">Z</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; map.filterNot(entry =&gt; entry._1 == <span class="string">"a"</span>)</span><br><span class="line">res24: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(b -&gt; <span class="type">B</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> map3 = map - <span class="string">"a"</span></span><br><span class="line">map3: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(b -&gt; <span class="type">B</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; map</span><br><span class="line">res25: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(a -&gt; <span class="type">A</span>, b -&gt; <span class="type">B</span>)</span><br></pre></td></tr></table></figure><p>Scala的immutable collection并没有添加和删除元素的操作，其定义<code>+</code>（<code>List</code>使用<code>::</code>在头部添加）操作都是生成一个新的集合，而要删除一个元素一般使用 <code>-</code> 操作直接将<strong>Key</strong>从<code>map</code>中减掉即可。</p><p>（注：Scala中也<code>scala.collection.mutable._</code>集合，它定义了不可变集合的相应可变集合版本。一般情况下，除非一此性能优先的操作（其实Scala集合采用了共享存储的优化，生成一个新集合并不会生成所有元素的复本，它将会和老的集合共享大元素。因为Scala中变量默认都是不可变的），推荐还是采用不可变集合。因为它更直观、线程安全，你可以确定你的变量不会在其它地方被不小心的更改。）</p><h2>Class</h2><p>Scala里也有<code>class</code>关键字，不过它定义类的方式与Java有些区别。Scala中，类默认是<strong>public</strong>的，且类属性和方法默认也是<strong>public</strong>的。Scala中，每个类都有一个**“主构造函数”**，主构造函数类似函数参数一样写在类名后的小括号中。因为Scala没有像Java那样的“构造函数”，所以属性变量都会在类被创建后初始化。所以当你需要在构造函数里初始化某些属性或资源时，写在类中的属性变量就相当于构造初始化了。</p><p>在Scala中定义类非常简单：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">s"name：<span class="subst">$name</span>, age: <span class="subst">$age</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认，Scala主构造函数定义的属性是<strong>private</strong>的，可以显示指定：<code>val</code>或<code>var</code>来使其可见性为：<strong>public</strong>。</p><p>Scala中覆写一个方法必需添加：<code>override</code>关键字，这对于Java来说可以是一个修正。当标记了<code>override</code>关键字的方法在编译时，若编译器未能在父类中找到可覆写的方法时会报错。而在Java中，你只能通过<code>@Override</code>注解来实现类似功能，它的问题是它只是一个可选项，且编译器只提供警告。这样你还是很容易写出错误的“覆写”方法，你以后覆写了父类函数，但其实很有可能你是实现了一个新的方法，从而引入难以察觉的BUG。</p><p>实例化一个类的方式和Java一样，也是使用<code>new</code>关键字。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> me = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Leo"</span>, <span class="number">18</span>)</span><br><span class="line">me: <span class="type">Person</span> = name: <span class="type">Leo</span>, age: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">scala&gt; println(me)</span><br><span class="line">name: <span class="type">Leo</span>, age: <span class="number">18</span></span><br><span class="line"></span><br><span class="line">scala&gt; me.name</span><br><span class="line">&lt;console&gt;:<span class="number">20</span>: error: value name is not a member of <span class="type">Person</span></span><br><span class="line">       me.name</span><br><span class="line">          ^</span><br><span class="line"></span><br><span class="line">scala&gt; me.age</span><br><span class="line">res11: <span class="type">Int</span> = <span class="number">30</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/assets/img/scala.png&quot; alt=&quot;我是一只的图片&quot; width=&quot;20%&quot;&gt;&lt;h1&gt;安装Scala&lt;/h1&gt;&lt;p&gt;到Scala官方下载地址下载：&lt;a href=&quot;http://scala-lang.org/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://scala-lang.org/download/&lt;/a&gt;&lt;/p&gt;&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ wget -c http:&lt;span class=&quot;comment&quot;&gt;//downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ tar zxf &lt;span class=&quot;keyword&quot;&gt;scala&lt;/span&gt;-2.11.8.tgz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;keyword&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;scala&lt;/span&gt;-2.11.8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ./bin/&lt;span class=&quot;keyword&quot;&gt;scala&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Welcome to &lt;span class=&quot;keyword&quot;&gt;Scala&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt; 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_60).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; expressions to have them evaluated.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Type&lt;/span&gt; :&lt;span class=&quot;keyword&quot;&gt;help&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;more&lt;/span&gt; information.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;scala&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://lz5z.com/categories/Big-Data/"/>
    
    
      <category term="Spark" scheme="https://lz5z.com/tags/Spark/"/>
    
      <category term="scala" scheme="https://lz5z.com/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>Android 自学笔记</title>
    <link href="https://lz5z.com/Android%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://lz5z.com/Android自学笔记/</id>
    <published>2016-09-28T22:01:00.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<img src="/assets/img/android.png" alt="android"><h1>Android简介</h1><p>Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导及开发。</p><a id="more"></a><h2>Android的独特之处</h2><ol><li>基于Linux的免费开源平台：手机制造商对其钟爱有加，因为他们可以对这个平台进行定制，而无需支付版权费。开发人员也喜欢它，因为他们知道这个平台不受制于任何可能破产或被收购的厂商。</li><li>基于组件的架构：能够以不同于开发人员最初设想的方式使用应用的组成部分，甚至可以将内置组件替换为改进版本。</li><li>大量现成的服务：GPS、蓝牙、数据库、浏览器、地图。</li><li>自动管理应用的生命周期：多重安全保障能够将程序彼此隔离，从而提高了系统的稳定性。最终用户不必关心哪些应用处于活动状态，也无需关闭一些程序以便运行其他程序。Android针对电量和内存有限的设备进行了优化。</li><li>高品质图形和声音。</li><li>可移植性：所有程序都使用Java编写，并由Android的ART预先编译器或Dalvik虚拟机执行，因此代码可移植到ARM、x86和其他体系结构。支持各种输入方法，如键盘、游戏手柄、触摸、电视遥控、鼠标和跟踪球。可针对任何屏幕分辨率和朝向定制用户界面。</li></ol><h1>Android四大组件</h1><h2>Activity</h2><p>Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。</p><h2>Service</h2><p>Service 是一段长生命周期的，没有用户界面的程序，例如网络监视器或更新检查应用程序。</p><h2>Content Provider</h2><p>可以将Content Provider看作数据库服务器，它的任务是管理对持久数据的访问，例如 SQLite 数据库。Content Provider使一个应用程序的指定数据集提供给其他应用程序。</p><h2>BroadcastReceive</h2><p>Android应用程序可以过滤感兴趣的外部事件（电话呼入、网络可用等）并做出响应。BroadcastReceive没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager来通知用户。</p><hr><p>Android 应用程序是连同一个 AndroidManifest.xml 文件一起部署到设备的。AndroidManifest.xml 包含必要的配置信息，以便将它适当地安装到设备。它包括必需的类名和应用程序能够处理的事件类型，以及运行应用程序所需的许可。例如，如果应用程序需要访问网络 — 例如为了下载一个文件 — 那么 manifest 文件中必须显式地列出该许可。很多应用程序可能启用了这个特定的许可。这种声明式安全性有助于减少恶意应用程序损害设备的可能性。</p><h1>Android开发环境</h1><h2>所需软件</h2><ol><li><a href="http://www.oracle.com/index.html" target="_blank" rel="noopener">JDK</a></li><li><a href="http://developer.android.com/index.html" target="_blank" rel="noopener">Android Studio</a></li><li><a href="https://www.genymotion.com/download/" target="_blank" rel="noopener">Genymotion</a></li></ol><p>安装过程：next到底。</p><p>天朝可以看这个网站<a href="http://www.android-studio.org/" target="_blank" rel="noopener">http://www.android-studio.org/</a></p><p>Genymotion需要注册才能下载，如果本地没有VM VirtualBox，<br>请选择 **“With VirtualBox”**的下载。</p><h3>Genymotion和Android Studio关联</h3><ol><li>给Android Studio安装Genymotion插件：</li></ol><p><strong>“File – Settings – Plugins – Browse Repositories – Genymotion Download and install”</strong></p><p>重启Android Studio后，选择菜单栏“View–Toolbar”，让工具栏显示出来，可以看到工具栏多了个Genymotion Device Manager的图标：</p><p>点击这个图标，加载之前安装好的Genymotion文件夹，启动Genymotion模拟器。</p><p>启动后选择你所需要的Android版本和手机型号就可以了。<br>当然了，如果要在模拟器上运行程序，还要确保模拟器加载了Android SDK：</p><h2>Hello World</h2><p>终于到了鸡冻人心的Hello World环节</p><p>**“File – New – New Projct”**创建新的工程文件</p><p>输入应用程序的名字和 Company Domain</p><p>选择Empty Activity</p><p>点击创建</p><h2>目录文件解析</h2><ol><li>app/manifests AndroidManifest.xml配置文件目录</li><li>app/java 源码目录</li><li>app/res 资源文件目录</li><li>Gradle Scripts gradle编译相关的脚本</li></ol><h1>Activity</h1><p>Activity是一个应用程序组件，提供用户与程序交互的界面</p><h3>Activity创建</h3><ol><li>继承Android的Activity类</li><li>重写方法</li><li>设置显示布局</li><li>在AndroidManifest文件中，注册Activity</li></ol><h3>Activity生命周期</h3><p><a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="noopener">官方</a>文档：</p><ol><li>onCreate();创建</li><li>onStart();运行</li><li>onResume();获取焦点</li><li>onPause(); 失去焦点</li><li>onStop();暂停</li><li>onDestroy();销毁</li><li>onRestart(); 重启</li></ol><h2>Activity四种状态</h2><ol><li>Active/Running Activity处于界面顶端，获取焦点。</li><li>Paused Activity失去焦点，但是对用户可见。</li><li>Stopped Activity完全被遮挡，但保留所有的状态和成员信息。</li><li>Killed Activity被销毁</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/assets/img/android.png&quot; alt=&quot;android&quot;&gt;&lt;h1&gt;Android简介&lt;/h1&gt;&lt;p&gt;Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导及开发。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lz5z.com/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lz5z.com/tags/Android/"/>
    
      <category term="入门" scheme="https://lz5z.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python 定时任务的实现方式</title>
    <link href="https://lz5z.com/Python%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://lz5z.com/Python定时任务的实现方式/</id>
    <published>2016-09-27T19:26:58.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/img/python_timer.png" alt="python 定时任务"></p><h1>背景</h1><hr><p>目前所在的项目组需要经常执行一些定时任务，之前都是用 Node.JS 的 <a href="https://github.com/ncb000gt/node-cron" target="_blank" rel="noopener">cron</a>来实现 schedule job。可是这次需要连接不同的 DB，而且实现的逻辑也有些许不同，于是选择使用 Python 的定时器。</p><a id="more"></a><h1>Python 实现定时任务</h1><h2>循环 sleep</h2><p>这种方式最简单，在循环里面放入要执行的任务，然后 sleep 一段时间再执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 每n秒执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line">        time.sleep(n)</span><br><span class="line"><span class="comment"># 5s</span></span><br><span class="line">timer(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这个方法的缺点是，只能执行固定间隔时间的任务，如果有定时任务就无法完成，比如早上六点半喊我起床。并且 sleep 是一个阻塞函数，也就是说 sleep 这一段时间，啥都不能做。</p><h2>threading模块中的Timer</h2><p>threading 模块中的 Timer 是一个非阻塞函数，比 sleep 稍好一点，不过依然无法喊我起床。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"><span class="comment"># 打印时间函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTime</span><span class="params">(inc)</span>:</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line">    t = Timer(inc, printTime, (inc,))</span><br><span class="line">    t.start()</span><br><span class="line"><span class="comment"># 5s</span></span><br><span class="line">printTime(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>Timer 函数第一个参数是时间间隔（单位是秒），第二个参数是要调用的函数名，第三个参数是调用函数的参数(tuple)</p><h2>使用sched模块</h2><p>sched 模块是 Python 内置的模块，它是一个调度（延时处理机制），每次想要定时执行某任务都必须写入一个调度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 初始化sched模块的 scheduler 类</span></span><br><span class="line"><span class="comment"># 第一个参数是一个可以返回时间戳的函数，第二个参数可以在定时未到达之前阻塞。</span></span><br><span class="line">schedule = sched.scheduler(time.time, time.sleep)</span><br><span class="line"><span class="comment"># 被周期性调度触发的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTime</span><span class="params">(inc)</span>:</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line">    schedule.enter(inc, <span class="number">0</span>, printTime, (inc,))</span><br><span class="line"><span class="comment"># 默认参数60s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(inc=<span class="number">60</span>)</span>:</span></span><br><span class="line">    <span class="comment"># enter四个参数分别为：间隔事件、优先级（用于同时间到达的两个事件同时执行时定序）、被调用触发的函数，</span></span><br><span class="line">    <span class="comment"># 给该触发函数的参数（tuple形式）</span></span><br><span class="line">    schedule.enter(<span class="number">0</span>, <span class="number">0</span>, printTime, (inc,))</span><br><span class="line">    schedule.run()</span><br><span class="line"><span class="comment"># 10s 输出一次</span></span><br><span class="line">main(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>sched 使用步骤如下：</p><p>（1）生成调度器：<br>s = sched.scheduler(time.time,time.sleep)<br>第一个参数是一个可以返回时间戳的函数，第二个参数可以在定时未到达之前阻塞。</p><p>（2）加入调度事件<br>其实有 enter、enterabs 等等，我们以 enter 为例子。<br>s.enter(x1,x2,x3,x4)<br>四个参数分别为：间隔事件、优先级（用于同时间到达的两个事件同时执行时定序）、被调用触发的函数，给触发函数的参数（注意：一定要以 tuple 给，如果只有一个参数就(xx,)）</p><p>（3）运行<br>s.run()<br>注意 sched 模块不是循环的，一次调度被执行后就 Over 了，如果想再执行，请再次 enter</p><h1>APScheduler定时框架</h1><p>终于找到了可以每天定时喊我起床的方式了</p><p><a href="http://apscheduler.readthedocs.io/en/latest/userguide.html" target="_blank" rel="noopener">APScheduler</a>是一个 Python 定时任务框架，使用起来十分方便。提供了基于日期、固定时间间隔以及 crontab 类型的任务，并且可以持久化任务、并以 daemon 方式运行应用。</p><p>使用 APScheduler 需要安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install apscheduler</span></span><br></pre></td></tr></table></figure><p>首先来看一个周一到周五每天早上6点半喊我起床的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 输出时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line"><span class="comment"># BlockingScheduler</span></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(job, <span class="string">'cron'</span>, day_of_week=<span class="string">'1-5'</span>, hour=<span class="number">6</span>, minute=<span class="number">30</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure><p>代码中的 BlockingScheduler 是什么呢？</p><p>BlockingScheduler 是 APScheduler 中的调度器，APScheduler 中有两种常用的调度器，BlockingScheduler 和 BackgroundScheduler，当调度器是应用中唯一要运行的任务时，使用 BlockingSchedule，如果希望调度器在后台执行，使用 BackgroundScheduler。</p><blockquote><ol><li>BlockingScheduler: use when the scheduler is the only thing running in your process</li><li>BackgroundScheduler: use when you’re not using any of the frameworks below, and want the scheduler to run in the background inside your application</li><li>AsyncIOScheduler: use if your application uses the asyncio module</li><li>GeventScheduler: use if your application uses gevent</li><li>TornadoScheduler: use if you’re building a Tornado application</li><li>TwistedScheduler: use if you’re building a Twisted application</li><li>QtScheduler: use if you’re building a Qt application</li></ol></blockquote><h2>APScheduler四个组件</h2><p>APScheduler 四个组件分别为：触发器(trigger)，作业存储(job store)，执行器(executor)，调度器(scheduler)。</p><h3>触发器(trigger)</h3><p>包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。除了他们自己初始配置意外，触发器完全是无状态的<br>APScheduler 有三种内建的 trigger:</p><blockquote><p>date: 特定的时间点触发<br>interval: 固定时间间隔触发<br>cron: 在特定时间周期性地触发</p></blockquote><h3>作业存储(job store)</h3><p>存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。一个作业的数据讲在保存在持久化作业存储时被序列化，并在加载时被反序列化。调度器不能分享同一个作业存储。<br>APScheduler 默认使用 MemoryJobStore，可以修改使用 DB 存储方案</p><h3>执行器(executor)</h3><p>处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。<br>最常用的 executor 有两种：</p><blockquote><p>ProcessPoolExecutor<br>ThreadPoolExecutor</p></blockquote><h3>调度器(scheduler)</h3><p>通常在应用中只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。</p><h2>配置调度器</h2><p>APScheduler提供了许多不同的方式来配置调度器，你可以使用一个配置字典或者作为参数关键字的方式传入。你也可以先创建调度器，再配置和添加作业，这样你可以在不同的环境中得到更大的灵活性。</p><p>下面来看一个简单的 BlockingScheduler 例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line"><span class="comment"># 定义BlockingScheduler</span></span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line">sched.add_job(job, <span class="string">'interval'</span>, seconds=<span class="number">5</span>)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><p>上述代码创建了一个 BlockingScheduler，并使用默认内存存储和默认执行器。(默认选项分别是 MemoryJobStore 和 ThreadPoolExecutor，其中线程池的最大线程数为10)。配置完成后使用 start() 方法来启动。</p><p>如果想要显式设置 job store(使用mongo存储)和 executor 可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.memory <span class="keyword">import</span> MemoryJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.mongodb <span class="keyword">import</span> MongoDBJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.executors.pool <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"><span class="comment"># MongoDB 参数</span></span><br><span class="line">host = <span class="string">'127.0.0.1'</span></span><br><span class="line">port = <span class="number">27017</span></span><br><span class="line">client = MongoClient(host, port)</span><br><span class="line"><span class="comment"># 输出时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">()</span>:</span></span><br><span class="line">    print(datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))</span><br><span class="line"><span class="comment"># 存储方式</span></span><br><span class="line">jobstores = &#123;</span><br><span class="line">    <span class="string">'mongo'</span>: MongoDBJobStore(collection=<span class="string">'job'</span>, database=<span class="string">'test'</span>, client=client),</span><br><span class="line">    <span class="string">'default'</span>: MemoryJobStore()</span><br><span class="line">&#125;</span><br><span class="line">executors = &#123;</span><br><span class="line">    <span class="string">'default'</span>: ThreadPoolExecutor(<span class="number">10</span>),</span><br><span class="line">    <span class="string">'processpool'</span>: ProcessPoolExecutor(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    <span class="string">'coalesce'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'max_instances'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">scheduler = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)</span><br><span class="line">scheduler.add_job(job, <span class="string">'interval'</span>, seconds=<span class="number">5</span>, jobstore=<span class="string">'mongo'</span>)</span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure><p>在运行程序5秒后，第一次输出时间。<br>在 MongoDB 中可以看到 job 的状态</p><p><img src="/assets/img/python_timer_job.png" alt="job"></p><h2>对 job 的操作</h2><h3>添加 job</h3><p>添加job有两种方式：</p><ol><li>add_job()</li><li>scheduled_job()</li></ol><p>第二种方法只适用于应用运行期间不会改变的 job，而第一种方法返回一个<a href="http://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job" target="_blank" rel="noopener">apscheduler.job.Job</a> 的实例，可以用来改变或者移除 job。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="meta">@sched.scheduled_job('interval', id='my_job_id', seconds=5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><p>@sched.scheduled_job() 是 Python 的装饰器。</p><h3>移除 job</h3><p>移除 job 也有两种方法：</p><ol><li>remove_job()</li><li>job.remove()</li></ol><p>remove_job 使用 jobID 移除<br>job.remove() 使用 add_job() 返回的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job = scheduler.add_job(myfunc, <span class="string">'interval'</span>, minutes=<span class="number">2</span>)</span><br><span class="line">job.remove()</span><br><span class="line"><span class="comment"># id</span></span><br><span class="line">scheduler.add_job(myfunc, <span class="string">'interval'</span>, minutes=<span class="number">2</span>, id=<span class="string">'my_job_id'</span>)</span><br><span class="line">scheduler.remove_job(<span class="string">'my_job_id'</span>)</span><br></pre></td></tr></table></figure><h3>暂停和恢复 job</h3><p>暂停一个 job：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apscheduler.job.Job.pause()</span><br><span class="line">apscheduler.schedulers.base.BaseScheduler.pause_job()</span><br></pre></td></tr></table></figure><p>恢复一个 job：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apscheduler.job.Job.resume()</span><br><span class="line">apscheduler.schedulers.base.BaseScheduler.resume_job()</span><br></pre></td></tr></table></figure><p>希望你还记得 apscheduler.job.Job 是 add_job() 返回的实例</p><h3>获取 job 列表</h3><p>获得可调度 job 列表，可以使用<a href="http://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.get_jobs" target="_blank" rel="noopener">get_jobs()</a> 来完成，它会返回所有的 job 实例。</p><p>也可以使用<a href="http://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.print_jobs" target="_blank" rel="noopener">print_jobs()</a> 来输出所有格式化的 job 列表。</p><h3>修改 job</h3><p>除了 jobID 之外 job 的所有属性都可以修改，使用 apscheduler.job.Job.modify() 或者 modify_job() 修改一个 job 的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.modify(max_instances=<span class="number">6</span>, name=<span class="string">'Alternate name'</span>)</span><br><span class="line">modify_job(<span class="string">'my_job_id'</span>, trigger=<span class="string">'cron'</span>, minute=<span class="string">'*/5'</span>)</span><br></pre></td></tr></table></figure><h3>关闭 job</h3><p>默认情况下调度器会等待所有的 job 完成后，关闭所有的调度器和作业存储。将 wait 选项设置为 False 可以立即关闭。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scheduler.shutdown()</span><br><span class="line">scheduler.shutdown(wait=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h3>scheduler 事件</h3><p>scheduler 可以添加事件监听器，并在特殊的时间触发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_listener</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event.exception:</span><br><span class="line">        print(<span class="string">'The job crashed :('</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'The job worked :)'</span>)</span><br><span class="line"><span class="comment"># 添加监听器</span></span><br><span class="line">scheduler.add_listener(my_listener, EVENT_JOB_EXECUTED | EVENT_JOB_ERROR)</span><br></pre></td></tr></table></figure><h2>trigger 规则</h2><h3><a href="http://apscheduler.readthedocs.io/en/latest/modules/triggers/date.html" target="_blank" rel="noopener">date</a></h3><p>最基本的一种调度，作业只会执行一次。它的参数如下：</p><ul><li>run_date (datetime|str) – the date/time to run the job at</li><li>timezone (datetime.tzinfo|str) – time zone for run_date if it doesn’t have one already</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_job</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text)</span><br><span class="line"><span class="comment"># The job will be executed on November 6th, 2009</span></span><br><span class="line">sched.add_job(my_job, <span class="string">'date'</span>, run_date=date(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">6</span>), args=[<span class="string">'text'</span>])</span><br><span class="line">sched.add_job(my_job, <span class="string">'date'</span>, run_date=datetime(<span class="number">2009</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">5</span>), args=[<span class="string">'text'</span>])</span><br><span class="line">sched.add_job(my_job, <span class="string">'date'</span>, run_date=<span class="string">'2009-11-06 16:30:05'</span>, args=[<span class="string">'text'</span>])</span><br><span class="line"><span class="comment"># The 'date' trigger and datetime.now() as run_date are implicit</span></span><br><span class="line">sched.add_job(my_job, args=[<span class="string">'text'</span>])</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><h3><a href="http://apscheduler.readthedocs.io/en/latest/modules/triggers/cron.html" target="_blank" rel="noopener">cron</a></h3><ul><li>year (int|str) – 4-digit year</li><li>month (int|str) – month (1-12)</li><li>day (int|str) – day of the (1-31)</li><li>week (int|str) – ISO week (1-53)</li><li>day_of_week (int|str) – number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun)</li><li>hour (int|str) – hour (0-23)</li><li>minute (int|str) – minute (0-59)</li><li>second (int|str) – second (0-59)</li><li>start_date (datetime|str) – earliest possible date/time to trigger on (inclusive)</li><li>end_date (datetime|str) – latest possible date/time to trigger on (inclusive)</li><li>timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations (defaults to scheduler timezone)</li></ul><p>表达式:</p><p><img src="/assets/img/python_timer_expression.png" alt="python 定时任务"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="comment"># BlockingScheduler</span></span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="comment"># Schedules job_function to be run on the third Friday</span></span><br><span class="line"><span class="comment"># of June, July, August, November and December at 00:00, 01:00, 02:00 and 03:00</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'cron'</span>, month=<span class="string">'6-8,11-12'</span>, day=<span class="string">'3rd fri'</span>, hour=<span class="string">'0-3'</span>)</span><br><span class="line"><span class="comment"># Runs from Monday to Friday at 5:30 (am) until 2014-05-30 00:00:00</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'cron'</span>, day_of_week=<span class="string">'mon-fri'</span>, hour=<span class="number">5</span>, minute=<span class="number">30</span>, end_date=<span class="string">'2014-05-30'</span>)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><h3><a href="http://apscheduler.readthedocs.io/en/latest/modules/triggers/interval.html" target="_blank" rel="noopener">interval</a></h3><p>参数：</p><ul><li>weeks (int) – number of weeks to wait</li><li>days (int) – number of days to wait</li><li>hours (int) – number of hours to wait</li><li>minutes (int) – number of minutes to wait</li><li>seconds (int) – number of seconds to wait</li><li>start_date (datetime|str) – starting point for the interval calculation</li><li>end_date (datetime|str) – latest possible date/time to trigger on</li><li>timezone (datetime.tzinfo|str) – time zone to use for the date/time calculations</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job_function</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello World"</span>)</span><br><span class="line"><span class="comment"># BlockingScheduler</span></span><br><span class="line">sched = BlockingScheduler()</span><br><span class="line"><span class="comment"># Schedule job_function to be called every two hours</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'interval'</span>, hours=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># The same as before, but starts on 2010-10-10 at 9:30 and stops on 2014-06-15 at 11:00</span></span><br><span class="line">sched.add_job(job_function, <span class="string">'interval'</span>, hours=<span class="number">2</span>, start_date=<span class="string">'2010-10-10 09:30:00'</span>, end_date=<span class="string">'2014-06-15 11:00:00'</span>)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/img/python_timer.png&quot; alt=&quot;python 定时任务&quot;&gt;&lt;/p&gt;&lt;h1&gt;背景&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;目前所在的项目组需要经常执行一些定时任务，之前都是用 Node.JS 的 &lt;a href=&quot;https://github.com/ncb000gt/node-cron&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cron&lt;/a&gt;来实现 schedule job。可是这次需要连接不同的 DB，而且实现的逻辑也有些许不同，于是选择使用 Python 的定时器。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lz5z.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数式编程—数组方法</title>
    <link href="https://lz5z.com/JavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>https://lz5z.com/JavaScript函数式编程—数组方法/</id>
    <published>2016-09-23T10:59:11.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><hr><p>闲逛的时候发现一个有趣的网站，<a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">ECMAScript</a> 里面介绍了各种JS引擎和Node版本对JavaScript特性的支持，从ECMAScript5开始到未来2017将会有的特性。 ES5是JavaScript历史上最具革命的一个版本，开发者们开始摒弃对旧版本 IE 浏览器的支持，使用统一的风格编写JavaScript，并且新的ECMAScript规范也开始启动。目前几乎所有的浏览器环境和Node.JS环境都支持ES5。</p><a id="more"></a><p>本文将介绍在JavaScript函数式编程中最常使用的几个数组方法，这些我们都习以为常的方法，来自<a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">ES5</a><br>ES5中一共有10个数组方法。</p><p>从后面的全绿我们可以知道，ES5的标准以及普及，以上这些方法可以放心使用。<br>下面是JavaScript函数式编程最常见的三个方法：filter、 map、 reduce。</p><h1>Array.prototype.filter()</h1><p>filter方法用于对数组进行条件过滤</p><p>不用 filter() 时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"apple"</span>, <span class="string">"count"</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"orange"</span>, <span class="string">"count"</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"pear"</span>, <span class="string">"count"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"orange"</span>, <span class="string">"count"</span>: <span class="number">16</span>&#125;,</span><br><span class="line">];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i.name === <span class="string">"orange"</span> )&#123;</span><br><span class="line">        newArr.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Filter results:"</span>, newArr);</span><br></pre></td></tr></table></figure><p>使用filter()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"apple"</span>, <span class="string">"count"</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"orange"</span>, <span class="string">"count"</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"pear"</span>, <span class="string">"count"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>:<span class="string">"orange"</span>, <span class="string">"count"</span>: <span class="number">16</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.name === <span class="string">'orange'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Filter results:"</span>, newArr);</span><br></pre></td></tr></table></figure><h2>Polyfill（兼容旧版浏览器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.filter) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span>(<span class="params">fun<span class="regexp">/*, thisArg*/</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="keyword">void</span> <span class="number">0</span> || <span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> len = t.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fun !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> thisArg = <span class="built_in">arguments</span>.length &gt;= <span class="number">2</span> ? <span class="built_in">arguments</span>[<span class="number">1</span>] : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> t) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = t[i];</span><br><span class="line">        <span class="keyword">if</span> (fun.call(thisArg, val, i, t)) &#123;</span><br><span class="line">          res.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Array.prototype.map()</h1><p>你可以把map当做一个 <strong>for each</strong> 循环来使用，它对数组中的每一个元素操作后，返回新的数组。<br>下面是我们经常会写的循环代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newNums = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    newNums[i] = nums[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums); <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>我们可以使用ES5中加入的forEach()方法进行改进：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newNums = [];</span><br><span class="line"></span><br><span class="line">nums.forEach(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">  newNums[index] = num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums); <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>注意ES5还不支持Arrow Function <strong>()=&gt;{}</strong> 和 <strong>let</strong></p><p>不过这样改进以后似乎也没有省多少代码<br>下面我们看一下比较函数式编程的map方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newNums = nums.map(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNums); <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>似不似瞬间代码少了很多呢，下面我们来看下map的源码。</p><h2>Polyfill（兼容旧版浏览器）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.map) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> T, A, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">' this is null or not defined'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> O = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      T = thisArg;</span><br><span class="line">    &#125;</span><br><span class="line">    A = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      <span class="keyword">var</span> kValue, mappedValue;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        kValue = O[k];</span><br><span class="line">        mappedValue = callback.call(T, kValue, k, O);</span><br><span class="line">        A[k] = mappedValue;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Array.prototype.reduce()</h1><blockquote><p>arr.reduce(callback, initialValue)</p></blockquote><p>reduce函数传入两个参数: 第一个是回调函数，第二个是初始化值（可选）。<br>回调函数里面可以传入四个参数： previousValue， currentValue， currentIndex， array</p><p>先看一个求数组最大值的简单例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> maxCallback = <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> <span class="built_in">Math</span>.max(pre, cur);</span><br><span class="line"><span class="keyword">let</span> max = [<span class="number">2</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">22</span>].reduce(maxCallback);</span><br><span class="line"><span class="built_in">console</span>.log(max); <span class="comment">//33</span></span><br></pre></td></tr></table></figure><p>“max =” 右边的执行顺序是怎样的呢？</p><ol><li>pre = 2, cur = 33, Math.max(pre, cur) = 33</li><li>pre = 33, cur = 12, Math.max(pre, cur) = 33</li><li>pre = 33, cur = 22, Math.max(pre, cur) = 33<br>最后 max = 33</li></ol><p>如果initialValue不为null，则会将initialValue作为函数第一次计算的pre传入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> flattened = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;, [<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flattened); <span class="comment">// [ -1, 0, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><p>计算顺序为：</p><ol><li>pre = [-1], cur = [0 ,1], return [-1].concat([0, 1]) = [-1, 0, 1]</li><li>pre = [-1, 0, 1], cur = [2, 3], return [-1, 0, 1, 2, 3]</li><li>pre = [-1, 0, 1, 2, 3], cur = [4, 5], return [ -1, 0, 1, 2, 3, 4, 5 ]</li></ol><p>利用reduce函数可以简化代码，比如求和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>求最大值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> <span class="built_in">Math</span>.max(pre, cur));</span><br></pre></td></tr></table></figure><p>把数组转换为对象（数组去重）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">o, v</span>) =&gt;</span> &#123;</span><br><span class="line">    o[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><h2>Polyfill</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.reduce) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback <span class="regexp">/*, initialValue*/</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Array.prototype.reduce called on null or undefined'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="built_in">Object</span>(<span class="keyword">this</span>), len = t.length &gt;&gt;&gt; <span class="number">0</span>, k = <span class="number">0</span>, value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</span><br><span class="line">      value = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> t)) &#123;</span><br><span class="line">        k++; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (k &gt;= len) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Reduce of empty array with no initial value'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      value = t[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> t) &#123;</span><br><span class="line">        value = callback(value, t[k], k, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;闲逛的时候发现一个有趣的网站，&lt;a href=&quot;http://kangax.github.io/compat-table/es5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript&lt;/a&gt; 里面介绍了各种JS引擎和Node版本对JavaScript特性的支持，从ECMAScript5开始到未来2017将会有的特性。 ES5是JavaScript历史上最具革命的一个版本，开发者们开始摒弃对旧版本 IE 浏览器的支持，使用统一的风格编写JavaScript，并且新的ECMAScript规范也开始启动。目前几乎所有的浏览器环境和Node.JS环境都支持ES5。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop 环境搭建</title>
    <link href="https://lz5z.com/Hadoop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://lz5z.com/Hadoop环境搭建/</id>
    <published>2016-09-15T20:11:00.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>开发环境搭建</h1><h2>安装虚拟机</h2><p>使用的是<a href="http://www.vmware.com/products/workstation.html" target="_blank" rel="noopener">VMware Workstation</a></p><h2>安装操作系统</h2><p>ubuntu-16.04-desktop-amd64</p><p>安装虚拟机和操作系统的教程可以参考之前的Blog: <a href="https://lz5z.com/Ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/">Ubuntu系统初识</a></p><a id="more"></a><h2>下载Hadoop</h2><p>如果你在官网上下载比较慢的话可以去这个网站看下<br><a href="http://mirror.bit.edu.cn/apache/hadoop/common" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/hadoop/common/</a></p><p>我们选择最新的稳定版本2.7.3</p><p>下载速度非常快</p><h2>安装Hadoop</h2><p>首先解压hadoop文件到/usr/local 路径下，并且重命名为hadoop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf hadoop2.7.3.tar.gz /usr/<span class="built_in">local</span> hadoop</span></span><br></pre></td></tr></table></figure><p>修改文件权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R hadoop ./hadoop</span></span><br></pre></td></tr></table></figure><p>Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bin/hadoop version</span></span><br></pre></td></tr></table></figure><p>配置Hadoop环境变量（由于小白还用不惯vim, 暂时使用gedit命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sodu gedit ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>在里面加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export PATH=$&#123;HADOOP_HOME&#125;/bin:$&#123;HADOOP_HOME&#125;/sbin:$PATH</span><br></pre></td></tr></table></figure><p>然后输入以下命令是环境变量生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure><p>在Linux中，~目录表示主目录。比如你要到下载文件夹下，就可以输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/Downloads</span></span><br></pre></td></tr></table></figure><h2>安装SSH、配置SSH无密码登陆</h2><p>集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install openssh-server</span></span><br></pre></td></tr></table></figure><p>安装后，可以使用如下命令登陆本机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh localhost</span></span><br></pre></td></tr></table></figure><p>但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。</p><p>首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exit</span>                           <span class="comment"># 退出刚才的 ssh localhost</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh/                     <span class="comment"># 若没有该目录，请先执行一次ssh localhost</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa              <span class="comment"># 会有提示，都按回车就可以</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ./id_rsa.pub &gt;&gt; ./authorized_keys  <span class="comment"># 加入授权</span></span></span><br></pre></td></tr></table></figure><p>此时再用 ssh localhost 命令，无需输入密码就可以直接登陆了</p><h1>环境配置</h1><h2>Hadoop单机配置(非分布式)</h2><p>Hadoop 默认模式为非分布式模式，无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试。</p><p>现在我们可以执行例子来感受下 Hadoop 的运行。</p><p>官网上给了一个比较简单的例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir input </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp etc/hadoop/*.xml input  <span class="comment"># 将配置文件作为输入文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar grep input output <span class="string">'dfs[a-z.]+'</span> <span class="comment"># 查询配置文件中符合正规dfs* 字符出现的次数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat output/*   <span class="comment"># 查看运行结果</span></span></span><br></pre></td></tr></table></figure><h2>Hadoop伪分布式配置</h2><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。</p><p>使用以下配置文件</p><p>etc/hadoop/core-site.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.dev.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Allow the superuser oozie to impersonate any members of the group group1 and group2<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.dev.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>The superuser can connect only from host1 and host2 to impersonate a user<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>etc/hadoop/hdfs-site.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hadoop配置文件说明:</p><p>Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。</p><p>此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 /tmp/hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。</p><p>配置完成后，执行 NameNode 的格式化:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/hdfs namenode -format</span></span><br></pre></td></tr></table></figure><p>如果刚才有在环境变量中加入 <strong>export PATH=${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin:$PATH</strong>，关于Hadoop的所有命令均可以直接使用，而不需要加入路径信息。</p><p>上述命令可以写成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hdfs namenode -format</span></span><br></pre></td></tr></table></figure><p>接着开启 NameNode 和 DataNode 守护进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./sbin/start-dfs.sh  <span class="comment">#如果已经开启，请先使用stop-dfs.sh关闭</span></span></span><br></pre></td></tr></table></figure><p>成功启动后，可以访问 Web 界面 <a href="http://localhost:50070" target="_blank" rel="noopener">http://localhost:50070</a> 查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。</p><p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-1/92254301.jpg" alt=""></p><p>若要关闭 Hadoop，则运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./sbin/stop-dfs.sh</span></span><br></pre></td></tr></table></figure><p>下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行 ./sbin/start-dfs.sh 就可以</p><h2>启动YARN</h2><p>YARN 的全称是“Yet Another Resource Negotiator”， 也就是新一代的MapReduce 框架</p><p>YARN 是从 MapReduce 中分离出来的，负责资源管理与任务调度。YARN 运行于 MapReduce 之上，提供了高可用性、高扩展性。</p><p>首先修改配置文件 mapred-site.xml，在源文件中只找到了“mapred-site.xml.template” 文件，所以我们将其复制并重命名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp ./etc/hadoop/mapred-site.xml.template ./etc/hadoop/mapred-site.xml</span></span><br></pre></td></tr></table></figure><p>然后用个gedit进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gedit ./etc/hadoop/mapred-site.xml</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着修改配置文件 yarn-site.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就可以启动 YARN 了（需要先执行过 ./sbin/start-dfs.sh）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./sbin/start-yarn.sh      <span class="comment"># 启动YARN</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sbin/mr-jobhistory-daemon.sh start historyserver  <span class="comment"># 开启历史服务器，才能在Web中查看任务运行情况</span></span></span><br></pre></td></tr></table></figure><p>启动 YARN 之后可以通过 Web 界面查看任务的运行情况：<a href="http://localhost:8088/cluster" target="_blank" rel="noopener">http://localhost:8088/cluster</a></p><p><img src="http://7xrn7f.com1.z0.glb.clouddn.com/16-11-1/92785083.jpg" alt=""></p><p>但 YARN 主要是为集群提供更好的资源管理与任务调度，然而这在单机上体现不出价值，反而会使程序跑得稍慢些。因此在单机上是否开启 YARN 就看实际情况了</p><p>如果不想启动 YARN，务必把配置文件 mapred-site.xml 删除，需要用时再重新cp。<br>否则在该配置文件存在，而未开启 YARN 的情况下，运行程序会提示 “Retrying connect to server: 0.0.0.0/0.0.0.0:8032” 的错误，这也是为何该配置文件初始文件名为 mapred-site.xml.template。</p><p>关闭 YARN 的脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./sbin/stop-yarn.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./sbin/mr-jobhistory-daemon.sh stop historyserver</span></span><br></pre></td></tr></table></figure><h1>HBase</h1><h2>简介</h2><p>HBase是一个分布式，版本化，面向列的数据库，构建在 Apache Hadoop和 Apache ZooKeeper之上。</p><p>HBase <a href="http://abloz.com/hbase/book.html" target="_blank" rel="noopener">官方文档</a></p><h2>安装HBase</h2><p>下载解压到 /usr/local/hbase</p><p>配置HBase环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">HBASE_HOME</span>=/usr/local/hbase</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$&#123;HBASE_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p>修改配置文件 hbase-site.xml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HBASE_HOME</span>/conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gedit hbase-site.xml</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000/user/dev<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/dev/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改启动文件 <a href="http://hbase-env.sh" target="_blank" rel="noopener">hbase-env.sh</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/usr/local/jdk</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HBASE_CLASSPATH</span>=/usr/local/hbase/conf</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HBASE_MANAGES_ZK</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>一个分布式运行的Hbase依赖一个zookeeper集群。所有的节点和客户端都必须能够访问zookeeper。<br>默认的情况下Hbase会管理一个zookeep集群。这个集群会随着Hbase的启动而启动。<br>conf/hbase-env.sh里面的 “HBASE_MANAGES_ZK=true” 表示作用是让Hbase启动的时候同时也启动zookeeper。</p><p>启动HBase</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$HBASE_HOME</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/start-hbase.sh</span></span><br></pre></td></tr></table></figure><p>启动HBase之后可以通过 Web 页面查看运行状况： <a href="http://localhost:16010/master-status" target="_blank" rel="noopener">http://localhost:16010/master-status</a></p><h2>HBase shell操作</h2><p>用shell连接你的HBase</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./bin/hbase shell</span></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">hbase(main):001:0&gt;</span><br></pre></td></tr></table></figure><p>创建一个名为 test 的表，这个表只有一个 列族 为 cf。可以列出所有的表来检查创建情况，然后插入些值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; create 'test', 'cf'</span><br><span class="line">0 row(s) in 1.2200 seconds</span><br><span class="line">hbase(main):003:0&gt; list 'table'</span><br><span class="line">test</span><br><span class="line">1 row(s) in 0.0550 seconds</span><br><span class="line">hbase(main):004:0&gt; put 'test', 'row1', 'cf:a', 'value1'</span><br><span class="line">0 row(s) in 0.0560 seconds</span><br><span class="line">hbase(main):005:0&gt; put 'test', 'row2', 'cf:b', 'value2'</span><br><span class="line">0 row(s) in 0.0370 seconds</span><br><span class="line">hbase(main):006:0&gt; put 'test', 'row3', 'cf:c', 'value3'</span><br><span class="line">0 row(s) in 0.0450 seconds</span><br></pre></td></tr></table></figure><p>以上我们分别插入了3行。第一个行key为row1, 列为 cf:a， 值是 value1。HBase中的列是由 列族前缀和列的名字组成的，以冒号间隔。例如这一行的列名就是a.</p><p>检查插入情况.</p><p>Scan这个表，操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):007:0&gt; scan 'test'</span><br><span class="line">ROW        COLUMN+CELL</span><br><span class="line">row1       column=cf:a, timestamp=1288380727188, value=value1</span><br><span class="line">row2       column=cf:b, timestamp=1288380738440, value=value2</span><br><span class="line">row3       column=cf:c, timestamp=1288380747365, value=value3</span><br><span class="line">3 row(s) in 0.0590 seconds</span><br></pre></td></tr></table></figure><p>Get一行，操作如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):008:0&gt; get 'test', 'row1'</span><br><span class="line">COLUMN      CELL</span><br><span class="line">cf:a        timestamp=1288380727188, value=value1</span><br><span class="line">1 row(s) in 0.0400 seconds</span><br></pre></td></tr></table></figure><p>disable 再 drop 这张表，可以清除你刚刚的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):012:0&gt; disable 'test'</span><br><span class="line">0 row(s) in 1.0930 seconds</span><br><span class="line">hbase(main):013:0&gt; drop 'test'</span><br><span class="line">0 row(s) in 0.0770 seconds</span><br></pre></td></tr></table></figure><p>关闭shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):014:0&gt; exit</span><br></pre></td></tr></table></figure><h1>总结</h1><p>如果按照上诉方法搭建好Hadoop相关环境，在重启电脑后，可以用以下命令迅速启动所有程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hdfs namenode -format</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> start-dfs.sh  <span class="comment">#http://localhost:50070</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> start-yarn.sh  <span class="comment">#http://localhost:8088/cluster</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> start-hbase.sh  <span class="comment">#http://localhost:16010/master-status</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;开发环境搭建&lt;/h1&gt;&lt;h2&gt;安装虚拟机&lt;/h2&gt;&lt;p&gt;使用的是&lt;a href=&quot;http://www.vmware.com/products/workstation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VMware Workstation&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;安装操作系统&lt;/h2&gt;&lt;p&gt;ubuntu-16.04-desktop-amd64&lt;/p&gt;&lt;p&gt;安装虚拟机和操作系统的教程可以参考之前的Blog: &lt;a href=&quot;https://lz5z.com/Ubuntu%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AF%86/&quot;&gt;Ubuntu系统初识&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://lz5z.com/categories/Big-Data/"/>
    
    
      <category term="Big Data" scheme="https://lz5z.com/tags/Big-Data/"/>
    
      <category term="Hadoop" scheme="https://lz5z.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Express 路由</title>
    <link href="https://lz5z.com/Express%E8%B7%AF%E7%94%B1/"/>
    <id>https://lz5z.com/Express路由/</id>
    <published>2016-09-14T00:00:00.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>Routing</h1><hr><p>前面说到Express有两个核心概念：Middleware和Routing。什么是Routing呢，简单来说就是http请求与服务端应答逻辑之间的映射关系。</p><a id="more"></a><p>路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。</p><p>上篇由if else处理不同的get请求就是最原始的路由，但是如果项目稍微大一点，维护无数else将是开发者的噩梦。幸好Express有强大的路由机制，比如解析url，正则表达式匹配等等，给开发者带来小小便利。</p><h1>路由方法</h1><p>路由方法是http请求时Express对应的方法，主要有app.get()、app.put()、app.post()、app.delete()等。<br>比如，匹配起GET /和负责回应主页的方法homepageHandler，可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="title">homepageHandler</span>(<span class="params">request, response</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>而要匹配POST /reivew/new和负责添加新评论的方法addNewReview（假设它已经在别处定义好了）则可以是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/review/new'</span>, addNewReview);</span><br></pre></td></tr></table></figure><p>app.all()是一个特殊的方法，它的作用是对于一个路径上的所有请求加载中间件，在下面的例子中，来自 “/secret” 的请求，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'/secret'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Accessing the secret section ...'</span>);</span><br><span class="line">  next(); <span class="comment">// pass control to the next handler</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果处理某个HTTP方法+path对的逻辑很复杂的话，我们也可以把它拆分成middleware栈的形式，依次传给app.METHOD()方法，也就是app.METHOD(path, [middleware…], last_middleware)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">'short'</span>));</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.end(<span class="string">'Welcome to Homepage'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.end(<span class="string">'Welcome to About page'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'404: Page Not Found'</span>);</span><br><span class="line">    err.status = <span class="number">404</span>;</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">    res.status(err.status || <span class="number">500</span>);</span><br><span class="line">    res.end(err.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>以上就是定义routing的第一种方式。</p><h1>Router对象</h1><p>Express的Router对象，也就是之前提到的router-level middleware，可以从两个方面来理解：</p><p>可以等同于整个应用中的一个子应用，比如一个RESTful API；它有自己的middleware栈<br>抽象地来看，可以简单视为整个应用middleware栈中的一片</p><p>在开发Express应用的时候，我们可以想想，整个应用是不是可以分拆为许多子应用，例如像上面所提到的，可以有个子应用专门来负责和数据库沟通并返回JSON格式的信息，即一个RESTful API。那么，在代码里，我们就可以新建一个子应用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> apiRouter = express.Router();</span><br></pre></td></tr></table></figure><p>然后，像主应用一样，我们可以为这个子应用添加middleware和routing：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.get(<span class="string">'/id'</span>, ...);</span><br><span class="line">apiRouter.post(<span class="string">'/review/new'</span>, ...);</span><br><span class="line">apiRouter.put(...);</span><br><span class="line">apiRouter.delete(...);</span><br></pre></td></tr></table></figure><p>最后，把所有path以/api开头的HTTP请求都导入到这个子应用去：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/api'</span>, apiRouter);</span><br></pre></td></tr></table></figure><p>上面的用法跟middleware的设定是一模一样的，只不过这里添加的不是一个方法，而是一个Router对象。这也是Router对象称为router-level middleware的原因。</p><h1>响应方法</h1><p>下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.download" target="_blank" rel="noopener">res.download()</a></td><td style="text-align:left">提示下载文件。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.end" target="_blank" rel="noopener">res.end()</a></td><td style="text-align:left">终结响应处理流程。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.json" target="_blank" rel="noopener">res.json()</a></td><td style="text-align:left">发送一个 JSON 格式的响应。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.jsonp" target="_blank" rel="noopener">res.jsonp()</a></td><td style="text-align:left">发送一个支持 JSONP 的 JSON 格式的响应。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.redirect" target="_blank" rel="noopener">res.redirect()</a></td><td style="text-align:left">重定向请求。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.render" target="_blank" rel="noopener">res.render()</a></td><td style="text-align:left">渲染视图模板。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.send" target="_blank" rel="noopener">res.send()</a></td><td style="text-align:left">发送各种类型的响应。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.sendFile" target="_blank" rel="noopener">res.sendFile</a></td><td style="text-align:left">以八位字节流的形式发送文件。</td></tr><tr><td style="text-align:left"><a href="http://www.expressjs.com.cn/4x/api.html#res.sendStatus" target="_blank" rel="noopener">res.sendStatus()</a></td><td style="text-align:left">设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</td></tr></tbody></table><h1>参数化的path</h1><p>假如有两篇文章的请求地址分别为 a/article 和 b/article, 服务器对这两篇文章的Get请求处理逻辑是相同的，Express如何做routing呢？换言之，Express如何把HTTP方法+一类path和相关的逻辑对应起来呢？</p><p>最简单的方法就是将这一类path中不同的那一部分看作一个参数，给它取个名字，并在其前加上一个引号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/:name/article'</span>, handleArticleRequest);</span><br></pre></td></tr></table></figure><p>这样就把所有的形如GET+/xxxxxxx/article的请求和这段负责回复博客的逻辑handleArticleRequest对应了起来。其中:name表示path的这一部分是一个参数，Express会自动把这部分的值存在对应的req.params.name这个对象里，以便这段逻辑使用。假如handleArticleRequest是一个方法，那么它大概会是这么个结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleArticleRequest</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = req.params.name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，当path含有query部分的时候，Express也会自动把query的部分存到req.query这个对象里面。假如说一个path含有query为?p1=v1&amp;p2=v2，那么在处理它的逻辑里，我们可以通过req.query.p1和req.query.p2来访问相应的值（都会是string对象）。</p><h1>结语</h1><p>以上就是对Express的routing机制的一点简单的介绍。更详细的内容参见 <a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="noopener">官网</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Routing&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;前面说到Express有两个核心概念：Middleware和Routing。什么是Routing呢，简单来说就是http请求与服务端应答逻辑之间的映射关系。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="Express" scheme="https://lz5z.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Express 中间件</title>
    <link href="https://lz5z.com/Express%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://lz5z.com/Express中间件/</id>
    <published>2016-09-12T13:39:18.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><hr><p>去年刚入职不久参与公司Mean技术栈的培训，其中有share过Express的东西，由于当时没有参与过实际项目，对Express理解并不深刻。后来有幸参与ShuttleBus项目，在实际使用中对Express有了些许了解，这里就把自己的想法写出来。</p><p>Express是一个非常轻量的Web开发框架，它有两个核心概念：Middleware和Routing，也是Express模块化、组织清晰的关键。</p><p>本篇先来讲讲Middleware。</p><a id="more"></a><h1>Middleware中间件</h1><p>Express是什么意思呢，特快列车，或者快递服务，在生活中通常会指快递。想象一下一个快递从生产到消费者手中会经过怎么样的流程？这个快递在工厂加工，然后发货，中途可能经过公路运输，海路运输，航空运输，最后到达收件人手中。如果把Http中的请求（request）比作货物，那层层加工和运输就是 <strong>中间件</strong>，每个流程都是先获取货物，然后处理或者传递，到达终点的时候结束整个流程。不同的是中间件在处理request的过程中，可能会对其进行修改，但是如果你的快递发货后被掉包，你肯定怒不可遏了。</p><blockquote><p><a href="http://www.expressjs.com.cn/guide/using-middleware.html" target="_blank" rel="noopener">中间件（Middleware）</a><br>是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。</p></blockquote><h1>Sample</h1><p>假如我们有这样一个需求，前端向server发送一个请求，server收到请求后返回给前端一句欢迎语，并且打印一段log。</p><p>提取一下发现有server两个功能点：</p><ol><li>server返回前端欢迎语</li><li>server打印log</li></ol><p>下面我们将这两个功能点抽象为两个Middleware</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印log的Middleware</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMid</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(request.method + <span class="string">': '</span> + request.url);</span><br><span class="line">    next(); <span class="comment">// 调用下一个middleware</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回欢迎语的middleware</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">welcomeMid</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.end(<span class="string">'Welcome to Home Page!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.url === <span class="string">'/about'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response.end(<span class="string">'Welcome to About Page!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    response.end(<span class="string">'404, Page Not Found!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次调用Middleware</span></span><br><span class="line">app.use(logger);</span><br><span class="line">app.use(responser);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>logMid中间件由于后面要执行下一个中间件，因此手动调用了next()方法，表示将控制权向下传递；而welcomeMid却没有调用，因为它是最后一个中间件，所以可以省略next的调用。</p><p>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起，直到请求超时。</p><h1>Middleware 功能</h1><p>从上面的Sample可以看出，中间件可以有以下功能：</p><ol><li>执行任何代码。可能与请求有关也可能无关（如上的logMid）</li><li>修改request和response对象</li><li>终结请求-响应循环，比如调用response.end()</li><li>调用下一个Middleware</li></ol><h1>Express 中间件分类</h1><h2>应用级中间件</h2><p>应用级中间件绑定到 app 对象（express实例）使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，应用的每个请求都会执行该中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time:'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它</span></span><br><span class="line">app.use(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request Type:'</span>, req.method);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'USER'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个请求装载一组中间件栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息</span></span><br><span class="line">app.use(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request URL:'</span>, req.originalUrl);</span><br><span class="line">  next();</span><br><span class="line">&#125;, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request Type:'</span>, req.method);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。第二个路由永远不会被调用，因为第一个路由已经终止了请求-响应循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ID:'</span>, req.params.id);</span><br><span class="line">  next();</span><br><span class="line">&#125;, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'User Info'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 /user/:id， 打印出用户 id</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.end(req.params.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这两个路由均对应指向 /user/:id的get请求，但是第二个路由永远不会执行，因为第一个路由已经终止了请求-响应循环。<br>如果在中间栈中跳过剩余的中间件，可以手动调用next(‘route’)将控制权交给下一个中间件。 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 user id 为 0, 跳到下一个路由</span></span><br><span class="line">  <span class="keyword">if</span> (req.params.id == <span class="number">0</span>) next(<span class="string">'route'</span>);</span><br><span class="line">  <span class="comment">// 否则将控制权交给栈中下一个中间件</span></span><br><span class="line">  <span class="keyword">else</span> next(); <span class="comment">//</span></span><br><span class="line">&#125;, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 渲染常规页面</span></span><br><span class="line">  res.render(<span class="string">'regular'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 /user/:id， 渲染一个特殊页面</span></span><br><span class="line">app.get(<span class="string">'/user/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'special'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>路由级中间件</h2><p>路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var router</span> = express.Router();</span><br></pre></td></tr></table></figure><p>路由级使用 router.use() 或 router.VERB() 加载。<br>上述在应用级创建的中间件系统，可通过如下代码改写为路由级：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件</span></span><br><span class="line">router.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time:'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息</span></span><br><span class="line">router.use(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request URL:'</span>, req.originalUrl);</span><br><span class="line">  next();</span><br><span class="line">&#125;, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request Type:'</span>, req.method);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个中间件栈，处理指向 /user/:id 的 GET 请求</span></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果 user id 为 0, 跳到下一个路由</span></span><br><span class="line">  <span class="keyword">if</span> (req.params.id == <span class="number">0</span>) next(<span class="string">'route'</span>);</span><br><span class="line">  <span class="comment">// 负责将控制权交给栈中下一个中间件</span></span><br><span class="line">  <span class="keyword">else</span> next(); <span class="comment">//</span></span><br><span class="line">&#125;, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 渲染常规页面</span></span><br><span class="line">  res.render(<span class="string">'regular'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 /user/:id， 渲染一个特殊页面</span></span><br><span class="line">router.get(<span class="string">'/user/:id'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params.id);</span><br><span class="line">  res.render(<span class="string">'special'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由挂载至应用</span></span><br><span class="line">app.use(<span class="string">'/'</span>, router);</span><br></pre></td></tr></table></figure><h2>错误处理中间件</h2><p>错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>错误处理中间件一般定义在其他 app.use() 和路由调用后，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> methodOverride = <span class="built_in">require</span>(<span class="string">'method-override'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyParser());</span><br><span class="line">app.use(methodOverride());</span><br><span class="line">app.use(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为不同的错误定义不同的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> methodOverride = <span class="built_in">require</span>(<span class="string">'method-override'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//logErrors 将请求和错误信息写入标准错误输出、日志或类似服务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logErrors</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  next(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clientErrorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.xhr) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(&#123; <span class="attr">error</span>: <span class="string">'Something blew up!'</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//errorHandler 能捕获所有错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  res.status(<span class="number">500</span>);</span><br><span class="line">  res.render(<span class="string">'error'</span>, &#123; <span class="attr">error</span>: err &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(bodyParser());</span><br><span class="line">app.use(methodOverride());</span><br><span class="line">app.use(logErrors);</span><br><span class="line">app.use(clientErrorHandler);</span><br><span class="line">app.use(errorHandler);</span><br></pre></td></tr></table></figure><p>如果向 next() 传入参数（除了 ‘route’ 字符串，传入route参数则直接跳入下一个中间件），Express 会认为当前请求有错误的输出，因此会直接进入错误处理中间件，跳过后续其他非错误处理和路由/中间件函数。这点也Promise的catch十分相似，只有Promise链中有一个函数reject了，就跳过所有reject后的函数，直奔catch函数。</p><ol><li>next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。</li><li>next(‘route’)会跳过当前中间件栈中剩余的中间件，直接进入下一个中间件。</li><li>Express中处理错误的middleware只会处理通过next(err)方式报出的错误，而不会处理throw出的错误</li><li>即使某个处理错误的middleware是整个栈的最后一个，在定义时也必须写四个参数(err, req, res, next)，以免混淆</li></ol><p>Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。</p><p>如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在 <strong>生产环境</strong>中反馈到客户端。</p><h2>内置中间件</h2><p>从 4.x 版本开始，除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。</p><h3>express.static(root, [options])</h3><p>express.static是处理静态文件的中间件，参数 root 指提供静态资源的根目录，<br>可选的 options 参数拥有如下属性。</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:center">描述</th><th style="text-align:center">类型</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">dotfiles</td><td style="text-align:center">是否对外输出文件名以点（.）开头的文件。</td><td style="text-align:center">可选值为 “allow”、“deny” 和 “ignore”</td><td style="text-align:left">String “ignore”</td></tr><tr><td style="text-align:left">etag</td><td style="text-align:center">是否启用 etag 生成</td><td style="text-align:center">Boolean</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">extensions</td><td style="text-align:center">设置文件扩展名备份选项</td><td style="text-align:center">Array</td><td style="text-align:left">[]</td></tr><tr><td style="text-align:left">index</td><td style="text-align:center">发送目录索引文件，设置为 false 禁用目录索引。</td><td style="text-align:center">Mixed</td><td style="text-align:left">“index.html”</td></tr><tr><td style="text-align:left">lastModified</td><td style="text-align:center">设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。</td><td style="text-align:center">Boolean</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">maxAge</td><td style="text-align:center">以毫秒或者其字符串格式设置 Cache-Control 头的 max-age 属性。</td><td style="text-align:center">Number</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">redirect</td><td style="text-align:center">当路径为目录时，重定向至 “/”。</td><td style="text-align:center">Boolean</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">setHeaders</td><td style="text-align:center">设置 HTTP 头以提供文件的函数。</td><td style="text-align:center">Function</td><td style="text-align:left">无</td></tr></tbody></table><p>下面来实践一个这个中间件的用法，假如有一张图片 avatar.png放在public文件夹下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  dotfiles: <span class="string">'ignore'</span>,</span><br><span class="line">  etag: <span class="literal">false</span>,</span><br><span class="line">  extensions: [<span class="string">'htm'</span>, <span class="string">'html'</span>],</span><br><span class="line">  index: <span class="literal">false</span>,</span><br><span class="line">  maxAge: <span class="string">'1d'</span>,</span><br><span class="line">  redirect: <span class="literal">false</span>,</span><br><span class="line">  setHeaders: <span class="function"><span class="keyword">function</span> (<span class="params">res, path, stat</span>) </span>&#123;</span><br><span class="line">    res.set(<span class="string">'x-timestamp'</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>, options));</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>启动服务后就可以通过 <a href="http://localhost:3000/avatar.png" target="_blank" rel="noopener">http://localhost:3000/avatar.png</a> 访问图片了。</p><h2>第三方中间件</h2><p>通过使用第三方中间件从而为 Express 应用增加更多功能。</p><p>安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。</p><p>下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser</p><blockquote><p>$ npm install cookie-parser</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载用于解析 cookie 的中间件</span></span><br><span class="line">app.use(cookieParser());</span><br></pre></td></tr></table></figure><p>请参考 <a href="http://www.expressjs.com.cn/resources/middleware.html" target="_blank" rel="noopener"><strong>第三方中间件</strong></a> 获取 Express 中经常用到的第三方中间件列表</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;去年刚入职不久参与公司Mean技术栈的培训，其中有share过Express的东西，由于当时没有参与过实际项目，对Express理解并不深刻。后来有幸参与ShuttleBus项目，在实际使用中对Express有了些许了解，这里就把自己的想法写出来。&lt;/p&gt;&lt;p&gt;Express是一个非常轻量的Web开发框架，它有两个核心概念：Middleware和Routing，也是Express模块化、组织清晰的关键。&lt;/p&gt;&lt;p&gt;本篇先来讲讲Middleware。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://lz5z.com/categories/JavaScript/"/>
    
    
      <category term="Node" scheme="https://lz5z.com/tags/Node/"/>
    
      <category term="Express" scheme="https://lz5z.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Apache Hadoop 入门</title>
    <link href="https://lz5z.com/Apache%20Hadoop%E5%85%A5%E9%97%A8/"/>
    <id>https://lz5z.com/Apache Hadoop入门/</id>
    <published>2016-09-07T21:08:23.000Z</published>
    <updated>2018-05-21T15:12:03.120Z</updated>
    
    <content type="html"><![CDATA[<h1>学习背景</h1><p>很早就想学习大数据相关的知识，无奈一直没有契机，而且没有实际项目的学习其实比较困难，所以无从下手。这次借机ITA技术学习，正巧项目组已经开始探索大数据相关知识，所以想靠自学摸索一下。</p><a id="more"></a><h1>Apache Hadoop 简介</h1><hr><p>Apache Hadoop 是一个由 Apache 基金会所开发的分布式系统基础架构。可以让用户在不了解分布式底层细节的情况下，开发出可靠、可扩展的分布式计算应用。</p><p>Apache Hadoop 它主要有以下几个优点：</p><ol><li>高可靠性。Hadoop 按位存储和处理数据的能力值得人们信赖。</li><li>高扩展性。Hadoop 是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。</li><li>高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</li><li>高容错性。Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。</li><li>低成本。Hadoop 是开源的，项目的软件成本因此会大大降低。</li></ol><p>Hadoop的核心就是HDFS和MapReduce，而两者只是理论基础，不是具体可使用的高级应用，Hadoop旗下有很多经典子项目，比如HBase、Hive等，这些都是基于HDFS和MapReduce发展出来的。要想了解Hadoop，就必须知道HDFS和MapReduce是什么。</p><h1>Apache Hadoop 核心组件</h1><p>Apache Hadoop 包含以下模块：</p><ol><li>Hadoop Common：常见实用工具，用来支持其他 Hadoop 模块。</li><li>Hadoop Distributed File System（HDFS）：分布式文件系统，它提供对应用程序数据的高吞吐量访问。</li><li>Hadoop YARN：一个作业调度和集群资源管理框架。</li><li>Hadoop MapReduce：基于 YARN 的大型数</li></ol><p>其他与 Apache Hadoop 的相关项目包括：</p><ol><li>Ambari：一个基于Web 的工具，用于配置、管理和监控的 Apache Hadoop 集群，其中包括支持 Hadoop HDFS、Hadoop MapReduce、Hive、HCatalog、HBase、ZooKeeper、Oozie、Pig 和 Sqoop。Ambari 还提供了仪表盘查看集群的健康，如热图，并能够以用户友好的方式来查看的 MapReduce、Pig 和 Hive 应用，方便诊断其性能。</li><li>Avro：数据序列化系统。</li><li>Cassandra：可扩展的、无单点故障的多主数据库。</li><li>Chukwa：数据采集系统，用于管理大型分布式系统。</li><li>HBase：一个可扩展的分布式数据库，支持结构化数据的大表存储。</li><li>Hive：数据仓库基础设施，提供数据汇总以及特定的查询。</li><li>Mahout：一种可扩展的机器学习和数据挖掘库。</li><li>Pig：一个高层次的数据流并行计算语言和执行框架。</li><li>Spark：Hadoop 数据的快速和通用计算引擎。Spark 提供了简单和强大的编程模型用以支持广泛的应用，其中包括 ETL、机器学习、流处理和图形计算。(有关 Spark 的内容，会在后面章节讲述)</li><li>TEZ：通用的数据流编程框架，建立在 Hadoop YARN 之上。它提供了一个强大而灵活的引擎来执行任意 DAG 任务，以实现批量和交互式数据的处理。TEZ 正在被 Hive、Pig 和 Hadoop 生态系统中其他框架所采用，也可以通过其他商业软件（例如 ETL 工具），以取代的 Hadoop MapReduce 作为底层执行引擎。</li><li>ZooKeeper：一个高性能的分布式应用程序协调服务。</li></ol><h2>HDFS</h2><p>HDFS（Hadoop Distributed File System，Hadoop分布式文件系统），HDFS将大文件分块存储在不同的计算机上，在文件读写的时候可以从不同计算资源的多个文件块区读取多个文件。</p><h3>HDFS的关键元素</h3><p>Block：将一个文件进行分块，通常是64M。<br>NameNode：保存整个文件系统的目录信息、文件信息及分块信息，这是由唯一一台主机专门保存，当然这台主机如果出错，NameNode就失效了。在Hadoop2.0 开始支持activity-standy模式----如果主NameNode失效，启动备用主机运行NameNode。<br>DataNode：分布在普通的计算机上，用于存储Block块文件。</p><h3>HDFS原理</h3><p>HDFS体系结构中有两类节点，一类是NameNode，又叫&quot;元数据节点&quot;；另一类是DataNode，又叫&quot;数据节点&quot;。这两类节点分别承担Master和Worker具体任务的执行节点。</p><p>1）元数据节点用来管理文件系统的命名空间<br>其将所有的文件和文件夹的元数据保存在一个文件系统树中。</p><p>这些信息也会在硬盘上保存成以下文件：命名空间镜像(namespace image)及修改日志(edit log)</p><p>其还保存了一个文件包括哪些数据块，分布在哪些数据节点上。然而这些信息并不存储在硬盘上，而是在系统启动的时候从数据节点收集而成的。</p><p>2）数据节点是文件系统中真正存储数据的地方。<br>客户端(client)或者元数据信息(namenode)可以向数据节点请求写入或者读出数据块。</p><p>其周期性的向元数据节点回报其存储的数据块信息。</p><p>3）从元数据节点（secondary namenode）</p><p>从元数据节点并不是元数据节点出现问题时候的备用节点，它和元数据节点负责不同的事情。</p><p>其主要功能就是周期性将元数据节点的命名空间镜像文件和修改日志合并，以防日志文件过大。这点在下面会相信叙述。</p><p>合并过后的命名空间镜像文件也在从元数据节点保存了一份，以防元数据节点失败的时候，可以恢复。</p><h3>HDFS设计特点</h3><ol><li>大数据文件，非常适合上T级别的大文件或者一堆大数据文件的存储，如果文件只有几个G甚至更小就没啥意思了。</li><li>文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算器上，它的意义在于读取文件时可以同时从多个主机取不同区块的文件，多主机读取比单主机读取效率要高得多得都。</li><li>流式数据访问，一次写入多次读写，这种模式跟传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化也只能在文件末添加内容。</li><li>廉价硬件，HDFS可以应用在普通PC机上，这种机制能够让给一些公司用几十台廉价的计算机就可以撑起一个大数据集群。</li><li>硬件故障，HDFS认为所有计算机都可能会出问题，为了防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其它某几个主机上，如果其中一台主机失效，可以迅速找另一块副本取文件。</li></ol><h2>MapReduce</h2><p>Mapreduce是一个计算框架，既然是做计算的框架，那么表现形式就是有个输入（input），mapreduce操作这个输入（input），通过本身定义好的计算模型，得到一个输出（output），这个输出就是我们所需要的结果。</p><p>我们要学习的就是这个计算模型的运行规则。在运行一个mapreduce计算任务时候，任务过程被分为两个阶段：map阶段和reduce阶段，每个阶段都是用键值对（key/value）作为输入（input）和输出（output）。而程序员要做的就是定义好这两个阶段的函数：map函数和reduce函数。</p><h3>Mapreduce运行机制</h3><p>Mapreduce运行机制按照时间顺序包括：输入分片（input split）、map阶段、combiner阶段、shuffle阶段和reduce阶段。</p><ol><li><p>输入分片（input split）：在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split），每个输入分片（input split）针对一个map任务，输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据的位置的数组，输入分片（input split）往往和hdfs的block（块）关系很密切，假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split），换句话说我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点。</p></li><li><p>map阶段：就是程序员编写好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行；</p></li><li><p>combiner阶段：combiner阶段是程序员可以选择的。Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作，例如单词频率做统计，map计算时候如果碰到一个hadoop的单词就会记录为1，但是这篇文章里hadoop可能会出现n多次，那么map输出文件冗余就会很多，因此在reduce计算前对相同的key做一个合并操作，那么文件会变小，这样就提高了宽带的传输效率，毕竟hadoop计算力宽带资源往往是计算的瓶颈也是最为宝贵的资源，但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入，例如：如果计算只是求总数，最大值，最小值可以使用combiner，但是做平均值计算使用combiner的话，最终的reduce计算结果就会出错。</p></li><li><p>shuffle阶段：将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。</p></li><li><p>reduce阶段：和map函数一样也是程序员编写的，最终结果是存储在hdfs上的。</p></li></ol><h1>结语</h1><p>这篇文章仅仅是一些入门的概念，接下来会有安装和一些小Demo。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;学习背景&lt;/h1&gt;&lt;p&gt;很早就想学习大数据相关的知识，无奈一直没有契机，而且没有实际项目的学习其实比较困难，所以无从下手。这次借机ITA技术学习，正巧项目组已经开始探索大数据相关知识，所以想靠自学摸索一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Big Data" scheme="https://lz5z.com/categories/Big-Data/"/>
    
    
      <category term="Big Data" scheme="https://lz5z.com/tags/Big-Data/"/>
    
      <category term="Hadoop" scheme="https://lz5z.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB3.2 存储策略</title>
    <link href="https://lz5z.com/MongoDB%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5/"/>
    <id>https://lz5z.com/MongoDB存储策略/</id>
    <published>2016-09-02T16:46:42.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<img src="/assets/img/MongoDB-Logo.png" alt="我是一只的图片" width="20%"><h1>MongoDB存储策略</h1><hr><p>MongoDB在3.2 版本更新后，正式将WiredTiger引擎设为默认引擎。</p><p>本文是MongoDB存储策略的一个简单翻译加讲解，存储引擎部分只介绍 <strong>wiredTiger</strong>，只有企业版支持的inMemory和落后于wiredTiger的mmapv1你可以参考<a href="https://docs.mongodb.com/manual/reference/configuration-options/" target="_blank" rel="noopener">官方文档</a>。<br>官方给出<a href="https://docs.mongodb.com/manual/reference/configuration-options/" target="_blank" rel="noopener">存储策略</a>如下：</p><a id="more"></a><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">storage:</span></span><br><span class="line"><span class="symbol">   dbPath:</span> <span class="params">&lt;string&gt;</span></span><br><span class="line"><span class="symbol">   indexBuildRetry:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">   repairPath:</span> <span class="params">&lt;string&gt;</span></span><br><span class="line"><span class="symbol">   journal:</span></span><br><span class="line"><span class="symbol">      enabled:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">      commitIntervalMs:</span> <span class="params">&lt;num&gt;</span></span><br><span class="line"><span class="symbol">   directoryPerDB:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">   syncPeriodSecs:</span> <span class="params">&lt;int&gt;</span></span><br><span class="line"><span class="symbol">   engine:</span> <span class="params">&lt;string&gt;</span></span><br><span class="line"><span class="symbol">   mmapv1:</span></span><br><span class="line"><span class="symbol">      preallocDataFiles:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">      nsSize:</span> <span class="params">&lt;int&gt;</span></span><br><span class="line"><span class="symbol">      quota:</span></span><br><span class="line"><span class="symbol">         enforced:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">         maxFilesPerDB:</span> <span class="params">&lt;int&gt;</span></span><br><span class="line"><span class="symbol">      smallFiles:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">      journal:</span></span><br><span class="line"><span class="symbol">         debugFlags:</span> <span class="params">&lt;int&gt;</span></span><br><span class="line"><span class="symbol">         commitIntervalMs:</span> <span class="params">&lt;num&gt;</span></span><br><span class="line"><span class="symbol">   wiredTiger:</span></span><br><span class="line"><span class="symbol">      engineConfig:</span></span><br><span class="line"><span class="symbol">         cacheSizeGB:</span> <span class="params">&lt;number&gt;</span></span><br><span class="line"><span class="symbol">         journalCompressor:</span> <span class="params">&lt;string&gt;</span></span><br><span class="line"><span class="symbol">         directoryForIndexes:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">      collectionConfig:</span></span><br><span class="line"><span class="symbol">         blockCompressor:</span> <span class="params">&lt;string&gt;</span></span><br><span class="line"><span class="symbol">      indexConfig:</span></span><br><span class="line"><span class="symbol">         prefixCompression:</span> <span class="params">&lt;boolean&gt;</span></span><br><span class="line"><span class="symbol">   inMemory:</span></span><br><span class="line"><span class="symbol">      engineConfig:</span></span><br><span class="line"><span class="symbol">         inMemorySizeGB:</span> <span class="params">&lt;number&gt;</span></span><br></pre></td></tr></table></figure><h2>storage.dbPath</h2><p>类型： 字符串<br>默认值: linux/OSX: /data/db; windows: \data\db</p><blockquote><p>The directory where the mongod instance stores its data.<br>If you installed MongoDB using a package management system, check the /etc/mongod.conf file provided by your packages to see the directory is specified.<br>The storage.dbPath setting is available only for mongod.<br>The Linux package init scripts do not expect storage.dbPath to change from the defaults. If you use the Linux packages and change storage.dbPath, you will have to use your own init scripts and disable the built-in scripts.</p></blockquote><p><strong>dbPath是MongoDB存储数据的磁盘位置</strong></p><h2>storage.indexBuildRetry</h2><p>类型： boolean<br>默认值： True</p><blockquote><p>Specifies whether mongod rebuilds incomplete indexes on the next start up. This applies in cases where mongod restarts after it has shut down or stopped in the middle of an index build. In such cases, mongod always removes any incomplete indexes, and then, by default, attempts to rebuild them. To stop mongod from rebuilding indexes, set this option to false.<br>The storage.indexBuildRetry setting is available only for mongod.<br>Not available for mongod instances that use the in-memory storage engine.</p></blockquote><p><strong>这个参数指的是：数据库在索引建立过程中停止，重启后是否重新建立索引。如果索引构建失败，mongod重启后将会删除尚未完成的索引，但是否重建由此参数决定。 设置这个参数的目的是： 如果你创建index的时候，MongoDB突然关闭（可能是因为意外，也可能是你不想建了手动关闭），这时候MongoDB会帮你把未完成的index删除，如果你不想启动MongoDB后重新创建这个index，可以将参数设置为false。虽然创建后也可以删除，但是毕竟数据量大了，创建index会耗费大量资源，对产品的影响不容小觑。</strong></p><p><strong>后面两句的意思是这个参数只对mongod进程有效，使用inMemory存储引擎无效。后面一样就不翻译了。</strong></p><h2>storage.repairPath</h2><p>类型： 字符串<br>默认值： dbPath下面 <code>A _tmp_repairDatabase_&lt;num&gt;</code></p><blockquote><p>The working directory that MongoDB will use during the --repair operation. When --repair completes, the storage.repairPath directory is empty, and dbPath contains the repaired files.<br>The storage.repairPath setting is available only for mongod.<br>Not available for mongod instances that use the in-memory storage engine.</p></blockquote><p><strong>这个参数是设置MongoDB修复的时候生成的临时文件的位置，配合<code>--repair</code>参数使用，当repair完成后，会把repairPath目录清空。</strong></p><h2>storage.journal.enabled</h2><p>类型： boolean<br>默认值： 64-bit 操作系统为True，32-bit 为False</p><blockquote><p>Enable or disable the durability journal to ensure data files remain valid and recoverable. This option applies only when you specify the --dbpath option. The mongod enables journaling by default on 64-bit builds of versions after 2.0.<br>The storage.journal.enabled setting is available only for mongod.<br>Not available for mongod instances that use the in-memory storage engine.</p></blockquote><p><strong>开启journal日志用于保证MongoDB数据有效性和故障恢复，这个建议开启。</strong></p><h2>storage.journal.commitIntervalMs</h2><p>类型：number<br>默认值： MMAPv1：30； WiredTiger：100</p><blockquote><p>The maximum amount of time in milliseconds that the mongod process allows between journal operations. Values can range from 1 to 500 milliseconds. Lower values increase the durability of the journal, at the expense of disk performance. The default journal commit interval is 100 milliseconds.<br>On MMAPv1, if the journal is on a different block device (e.g. physical volume, RAID device, or LVM volume) than the data files, the default journal commit interval is 30 milliseconds. Additionally, on MMAPv1, when a write operation with j:true is pending, mongod will reduce commitIntervalMs to a third of the set value.<br>On WiredTiger, the default journal commit interval is 100 milliseconds. Additionally, a write with j:true will cause an immediate sync of the journal.<br>The storage.journal.commitIntervalMs setting is available only for mongod.<br>Not available for mongod instances that use the in-memory storage engine.</p></blockquote><p><strong>这个参数指mongod进程提交journal日志的时间间隔，阈值为1-500毫秒，这个值越小，数据丢失的可能性越低，磁盘消耗越大，性能越低。使用MMAPv1时默认值为30ms，使用WiredTiger时，默认值为100ms。如果在客户端进行写操作的时候，希望立即同步，可以传递参数 <code>j:true</code>, 写操作会立即fsync到磁盘。</strong></p><h2>storage.directoryPerDB</h2><p>类型：boolean<br>默认值：False</p><blockquote><p>When true, MongoDB uses a separate directory to store data for each database. The directories are under the storage.dbPath directory, and each subdirectory name corresponds to the database name.</p></blockquote><p><strong>如果为真的话，会将不同DB的数据存储在不同的目录中，路径为storage.dbPath的子目录，目录名为DB的名称。</strong></p><h2>storage.syncPeriodSecs</h2><p>类型： number<br>默认值： 60</p><blockquote><p>The amount of time that can pass before MongoDB flushes data to the data files via an fsync operation.<br>Do not set this value on production systems. In almost every situation, you should use the default setting.<br>WARNING:<br>If you set storage.syncPeriodSecs to 0, MongoDB will not sync the memory mapped files to disk.<br>The mongod process writes data very quickly to the journal and lazily to the data files. storage.syncPeriodSecs has no effect on the journal files or journaling.<br>The serverStatus command reports the background flush thread’s status via the backgroundFlushing field.</p></blockquote><p><strong>MongoDB 通过fsync操作将数据flush到磁盘，这个参数指同步的时间间隔。默认值是60秒。官方给出的建议是在产品环境中，不要设置这个参数的值，使用默认值最好了。<br>如果你把参数值设为0，MongoDB就不会把内存中的数据同步到磁盘了。</strong></p><p><strong>mongod进程将变更的数据立马写入journal，然后过一段时间再写入磁盘，可以提高磁盘效率。这个参数对journal文件存储没有影响。</strong></p><h2>storage.engine</h2><p>默认值：wiredTiger</p><p>MongoDB一共有三种存储引擎： mmapv1, wiredTiger, inMemory。 inMemory只有在MongoDB企业版中才能使用。</p><blockquote><p>If you attempt to start a mongod with a storage.dbPath that contains data files produced by a storage engine other than the one specified by storage.engine, mongod will refuse to start.</p></blockquote><p><strong>启动MongoDB的时候，可以在dbPath中指定存储引擎，如果数据库已经有数据文件，则MongDB会根据文件判断存储引擎的类型。如果启动的时候指定的存储引擎与已有的存储引擎不一致，会导致启动失败。</strong></p><h1>wiredTiger引擎选项</h1><h2>storage.wiredTiger.engineConfig.cacheSizeGB</h2><blockquote><p>The maximum size of the internal cache that WiredTiger will use for all data.<br>With WiredTiger, MongoDB utilizes both the WiredTiger internal cache and the filesystem cache.<br>Changed in version 3.2: Starting in MongoDB 3.2, the WiredTiger internal cache, by default, will use the larger of either:</p></blockquote><ol><li>60% of RAM minus 1 GB, or</li><li>1 GB.</li></ol><blockquote><p>For systems with up to 10 GB of RAM, the new default setting is less than or equal to the 3.0 default setting (For MongoDB 3.0, the WiredTiger internal cache uses either 1 GB or half of the installed physical RAM, whichever is larger).<br>For systems with more than 10 GB of RAM, the new default setting is greater than the 3.0 setting.</p></blockquote><p><strong>这个参数限制WiredTiger使用的最大内部缓存的大小。通过WiredTiger，MongoDB充分利用了WiredTiger的内部缓存和文件系统的缓存。这个默认值是MongoDB计算出来了，如果你的内存的比较大，会使用（60%的内存 - 1G，或者1G， 以数值比较大的为准），也就是至少1G。</strong></p><p><strong>在MongoDB3.0中，WiredTiger缓存使用1G或者安装物理内存的一半，以较大者为准。所以如果你的内存小于10G，3.2的默认值为小于或等于3.0的默认值。如果你的内存大于10G，3.2版本将会使用比3.0版本更大的内存。</strong></p><blockquote><p>Via the filesystem cache, MongoDB automatically uses all free memory that is not used by the WiredTiger cache or by other processes. Data in the filesystem cache is compressed.<br>Avoid increasing the WiredTiger internal cache size above its default value.</p></blockquote><p><strong>通过文件系统缓存，MongoDB自动使用除了WiredTiger和其他进程使用的内存以外的全部内存，（看到这里我顿时觉得说MongoDB是纯内存数据库一点也不为过，说它是贵族数据库也毫不夸张）。也就是说，只要你数据量比较大，不管怎么样，它都会把你内存吃光，要么是WiredTiger存储引擎使用，要么是操作系统的文件系统（文件系统也是为MongoDB服务）。不过数据在文件系统里面是经过压缩的。感觉MongoDB为了快无所不尽其极啊。</strong></p><p><strong>官方建议避免设置WiredTiger缓存大于其默认值。</strong></p><blockquote><p>NOTE<br>The storage.wiredTiger.engineConfig.cacheSizeGB limits the size of the WiredTiger internal cache. The operating system will use the available free memory for filesystem cache, which allows the compressed MongoDB data files to stay in memory. In addition, the operating system will use any free RAM to buffer file system blocks and file system cache.</p></blockquote><p><strong>这里是说这个参数限制了WiredTiger内部缓存的大小，操作系统会利用剩余的内存作文件系统缓存用了存储压缩过的MongoDB数据文件。此外，操作系统将使用任何可用的内存缓存文件系统块和文件缓存。不知道官方文档为什么要再啰嗦一遍，不是我的锅。</strong></p><blockquote><p>The default WiredTiger internal cache size value assumes that there is a single mongod instance per machine. If a single machine contains multiple MongoDB instances, then you should decrease the setting to accommodate the other mongod instances.</p></blockquote><p><strong>刚才所说的默认值是假设每台电脑上只有一个mongod实例，如果你有部署多个MongDB实例，请合理配置参数。</strong></p><blockquote><p>If you run mongod in a container (e.g. lxc, cgroups, Docker, etc.) that does not have access to all of the RAM available in a system, you must set storage.wiredTiger.engineConfig.cacheSizeGB to a value less than the amount of RAM available in the container. The exact amount depends on the other processes running in the container.</p></blockquote><p><strong>如果你把mongod运行在一个容器中，比如现在最热门的Docker，因为容器并不能获取系统中全部内存，所以你要把这个参数设置的小于容器所拥有的内存，当然还要考虑容器中其它的进程。</strong></p><h2>storage.wiredTiger.engineConfig.journalCompressor</h2><p>默认值： snappy</p><p><strong>这个参数是指wiredTiger使用的压缩算法，如果你对此没有了解的话，就不要动了。有三个值可选：none；snappy；zlib。第一个表示不压缩。</strong></p><h2>storage.wiredTiger.engineConfig.directoryForIndexes</h2><p>类型： boolean<br>默认值： false</p><blockquote><p>When storage.wiredTiger.engineConfig.directoryForIndexes is true, mongod stores indexes and collections in separate subdirectories under the data (i.e. storage.dbPath) directory. Specifically, mongod stores the indexes in a subdirectory named index and the collection data in a subdirectory named collection.<br>By using a symbolic link, you can specify a different location for the indexes. Specifically, when mongod instance is not running, move the index subdirectory to the destination and create a symbolic link named index under the data directory to the new destination.</p></blockquote><p><strong>是否将索引和collections数据分别存储在storage.dbPath单独的目录中。即index数据保存“index”子目录，collections数据保存在“collection”子目录。默认值为false，仅对mongod有效。</strong></p><h2>storage.wiredTiger.collectionConfig.blockCompressor</h2><p>默认值： snappy</p><blockquote><p>The default type of compression to use to compress collection data. You can override this on a per-collection basis when creating collections.<br>storage.wiredTiger.collectionConfig.blockCompressor affects all collections created. If you change the value of storage.wiredTiger.collectionConfig.blockCompressor on an existing MongoDB deployment, all new collections will use the specified compressor. Existing collections will continue to use the compressor specified when they were created, or the default compressor at that time.</p></blockquote><p><strong>collection数据压缩算法，可选值“none”、“snappy”、“zlib”。你可以在创建collection时可以指定值，以覆盖此配置项。如果mongod中已经存在数据，修改此值不会带来问题，旧数据仍然使用原来的算法解压，新数据文件将会采用新的解压缩算法。</strong></p><h2>storage.wiredTiger.indexConfig.prefixCompression</h2><p>默认值：true</p><blockquote><p>Enables or disables prefix compression for index data.<br>Specify true for storage.wiredTiger.indexConfig.prefixCompression to enable prefix compression for index data, or false to disable prefix compression for index data.<br>The storage.wiredTiger.indexConfig.prefixCompression setting affects all indexes created. If you change the value of storage.wiredTiger.indexConfig.prefixCompression on an existing MongoDB deployment, all new indexes will use prefix compression. Existing indexes are not affected.</p></blockquote><p>**是否对索引数据使用“前缀压缩”（prefix compression，一种算法）。前缀压缩，对那些经过排序的值存储，有很大帮助，可以有效的减少索引数据的内存使用量。默认值为true。如果你在已经存在数据的MOngoDB数据库中修改这个值，新创建的数据都会受到影响，而已有的index不会受到影响。**</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/assets/img/MongoDB-Logo.png&quot; alt=&quot;我是一只的图片&quot; width=&quot;20%&quot;&gt;&lt;h1&gt;MongoDB存储策略&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;MongoDB在3.2 版本更新后，正式将WiredTiger引擎设为默认引擎。&lt;/p&gt;&lt;p&gt;本文是MongoDB存储策略的一个简单翻译加讲解，存储引擎部分只介绍 &lt;strong&gt;wiredTiger&lt;/strong&gt;，只有企业版支持的inMemory和落后于wiredTiger的mmapv1你可以参考&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;br&gt;官方给出&lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;存储策略&lt;/a&gt;如下：&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="https://lz5z.com/categories/MongoDB/"/>
    
    
      <category term="MongDB" scheme="https://lz5z.com/tags/MongDB/"/>
    
      <category term="配置文件" scheme="https://lz5z.com/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python 基础知识学习</title>
    <link href="https://lz5z.com/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lz5z.com/Python基础知识学习/</id>
    <published>2016-08-31T22:38:42.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<img src="/assets/img/Python_logo.png" alt="我是一只的图片"><h1>Python 数据类型</h1><hr><p>这里只列举一些Python与Java和JavaScript不一样的地方，如果你有任何语言基础，相信看完这篇文章就可以轻松写Python程序。</p><a id="more"></a><h2>字符串</h2><p>Py字符串可以用单引号 <strong>‘…’</strong>，双引号**&quot;…&quot;**，三引号 <strong>‘’’…’’’</strong> 表示, 可以把单引号放在双引号里面。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"I'm OK"</span>) </span><br><span class="line">I<span class="string">'m OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print('</span>I\<span class="string">'m OK'</span>) <span class="comment">#使用转义字符</span></span><br><span class="line">I<span class="string">'m OK</span></span><br></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’…‘表示’…'内部的字符串默认不转义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'\\\\'</span>)</span><br><span class="line">\\</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'\\\\'</span>)</span><br><span class="line">\\\\</span><br></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’'的格式表示多行内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''Hello</span></span><br><span class="line"><span class="string"><span class="meta">... </span>World!</span></span><br><span class="line"><span class="string"><span class="meta">... </span>I'm Leo!'''</span>)</span><br><span class="line"></span><br><span class="line">Hello</span><br><span class="line">World!</span><br><span class="line">I<span class="string">'m Leo!</span></span><br></pre></td></tr></table></figure><p>注意这里的 **’**没有使用转义字符也能打印出来，不过安全起见，可以写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'''Hello</span></span><br><span class="line"><span class="string"><span class="meta">... </span>World!</span></span><br><span class="line"><span class="string"><span class="meta">... </span>I'm Leo!'''</span>)</span><br><span class="line"></span><br><span class="line">Hello</span><br><span class="line">World!</span><br><span class="line">I<span class="string">'m Leo!</span></span><br></pre></td></tr></table></figure><p>表示既能识别换行，又能默认不转义。这个用处大大地，可以做一些多行文本的处理，如果有保留内容样式的需求，也能够很好地满足。</p><h3>字符串格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用%实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></span><br><span class="line"><span class="string">'Hello, world'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s, %d time'</span> % (<span class="string">'world'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">'Hello, world, 3 time'</span></span><br></pre></td></tr></table></figure><p>在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p><p>常见的占位符有：<br>%d——整数<br>%f——浮点数<br>%s——字符串<br>%x——十六进制整数</p><p>格式化整数和浮点数还可以指定是否补0和整数与小数的位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2d - %02d'</span> % (<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="string">' 2 - 01'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2.f'</span> % <span class="number">3.14</span></span><br><span class="line"><span class="string">' 3'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%.2f'</span> % <span class="number">3.1415</span></span><br><span class="line"><span class="string">'3.14'</span></span><br></pre></td></tr></table></figure><p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Age: %s. Gender: %s'</span> % (<span class="number">25</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="string">'Age: 25. Gender: True'</span></span><br></pre></td></tr></table></figure><p>如果字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span></span><br><span class="line"><span class="string">'growth rate: 7 %'</span></span><br></pre></td></tr></table></figure><h2>布尔值</h2><p>布尔值与JavaScript和Java的区别就是 <strong>True</strong> 和 <strong>False</strong> 开头大写，除此之外，逻辑运算是用 and, or和not进行运算。暂时只知道这点区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'teenager'</span>)</span><br><span class="line">...</span><br><span class="line">teenager</span><br></pre></td></tr></table></figure><h2>空值</h2><p>Py里面的空值用 <strong>None</strong> 表示，逻辑运算时，None相当于False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">None</span>==<span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span>(<span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Leo'</span>)</span><br><span class="line">...</span><br><span class="line">Leo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h2>变量</h2><p>Python中变量名必须是大小写英文、数字和 _ 的组合，且不能用数字开头。<br>Py定义一个变量异常简单，只需要写变量名 =XX 即可。由于Py是动态语言，所以变量的数据类型可以随意切换。</p><h2>常量</h2><p>在Java中一般使用final关键字定义常量, final常量一般在声明的同时赋初值，也可以在构造函数中赋初值，为了节省内存空间，我们常将变量声明为静态的(static)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI=<span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure><p>在JavaScript中，ES6标准也增加了对常量的支持，使用const关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>Python中没有真正意义的常量，不过如果你见到全部用大写字母表示的值，最好谨慎一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.14159265359</span></span><br></pre></td></tr></table></figure><h2>计算</h2><p>Py中有两种除法，一种是浮点除法，一种是整除。<br>浮点除法 <strong>/</strong> 无论是否整除结果都是浮点数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span>/<span class="number">3</span></span><br><span class="line"><span class="number">3.3333333333333335</span></span><br></pre></td></tr></table></figure><p>还有一种除法是//，称为地板除，两个整数的除法永远是整数，就像Java一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span>//<span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2>数据类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'12.34'</span>)</span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">100</span>)</span><br><span class="line"><span class="string">'100'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2>list</h2><p>list是一种有序的集合，可以随时添加和删除其中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>students=[<span class="number">1</span>,<span class="string">'xiao'</span>,<span class="keyword">True</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(students)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students[<span class="number">3</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><p>当索引超出了范围时，Python会报一个IndexError错误<br>如果要取最后一个元素，除了计算索引位置(len()-1)外，还可以用-1做索引，直接获取最后一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>students[<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>常用操作有： append(), insert(index, value), pop(), pop(index),</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>students.append(<span class="string">'Leo'</span>) <span class="comment">#追加一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students</span><br><span class="line">[<span class="number">1</span>, <span class="string">'xiao'</span>, <span class="keyword">True</span>, <span class="string">'Leo'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students.insert(<span class="number">2</span>, <span class="keyword">False</span>) <span class="comment">#插入一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students</span><br><span class="line">[<span class="number">1</span>, <span class="string">'xiao'</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="string">'Leo'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students.pop() <span class="comment">#删除末尾元素</span></span><br><span class="line"><span class="string">'Leo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>students</span><br><span class="line">[<span class="number">1</span>, <span class="string">'xiao'</span>, <span class="keyword">False</span>, <span class="keyword">True</span>]</span><br></pre></td></tr></table></figure><h2>tuple</h2><p>中文名叫做元组，tuple也是有序列表，tuple初始化后就不能修改，使用起来更加安全。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names=(<span class="string">'Jack'</span>, <span class="string">'Lucy'</span>, <span class="string">'Leo'</span>) <span class="comment">#tuple定义的时候元素就必须确定下来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names </span><br><span class="line">(<span class="string">'Jack'</span>, <span class="string">'Lucy'</span>, <span class="string">'Leo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names=(<span class="keyword">True</span>,) <span class="comment">#如果只有一个元素, 要与小括号进行区分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>names</span><br><span class="line">(<span class="keyword">True</span>,)          <span class="comment">#Python在显示只有1个元素的tuple时，也会加一个逗号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=() <span class="comment">#定义一个空的tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">()</span><br></pre></td></tr></table></figure><p>值得注意的是tuple所谓的不变，指的是每个元素的指向不变，如果指向的的对象发生了改变，tuple也是可变的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</span><br></pre></td></tr></table></figure><h1>条件判断</h1><h2>写一个sample就什么都明白了</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">16</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure><p>elif 是else if的缩写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    print(<span class="string">'True'</span>)</span><br></pre></td></tr></table></figure><p>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False</p><h2>input</h2><p>使用input可以获取用户的输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age=input()</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age</span><br><span class="line"><span class="string">'21'</span></span><br></pre></td></tr></table></figure><p>不过可以看出input获取的值为字符串，所以可以使用int(age)进行数据类型转换</p><h1>循环</h1><h2>for in循环</h2><p>for…in循环依次把list或tuple中的每个元素迭代出来, 并且代入变量，然后执行缩进块的语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>range() 可以生产一个整数序列, 通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数,<br>range(2, 4)生产序列从2开始，小于4的整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">3</span>)</span><br><span class="line">range(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">3</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2>while循环</h2><p>while循环与Java和JS几乎没有什么区别，只是格式有点不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h1>dict和set</h1><h2>dict</h2><p>Python中的dict就是字典，相当于JavaScript和Java中的对象或者map。<br>总体来说，Python dict的使用方法与JavaScript对象相似。<br>我们首先来看一下如何定义一个Python字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages=&#123;<span class="string">'Leo'</span>:<span class="number">20</span>,<span class="string">'Jack'</span>:<span class="number">25</span>,<span class="string">'Lucy'</span>:<span class="number">34</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages</span><br><span class="line">&#123;<span class="string">'Leo'</span>: <span class="number">20</span>, <span class="string">'Lucy'</span>: <span class="number">34</span>, <span class="string">'Jack'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages[<span class="string">'Leo'</span>]</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p>dict的优点是查找速度快，想象一下，你通过字典去查一个字，是不是先通过拼音或者偏旁找到这个字所在的页数，然后直接翻到这一页。所以无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。这就是dict的优势所在。</p><p>如果key不存在Python会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages[<span class="string">'Pig'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'Pig'</span></span><br></pre></td></tr></table></figure><p>可以通过in判断key是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Leo'</span> <span class="keyword">in</span> ages</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>通过get获取key对应的value，如果key不存在，返回None。也可以自己指定key不存在时候的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages.get(<span class="string">'Lucy'</span>)</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages.get(<span class="string">'Lu'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ages.get(<span class="string">'Lu'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>所以，dict是用空间来换取时间的一种方法。</p><h2>set</h2><p>set是一个没有重复元素的集合，这点和Java、JavaScript一样。用法也非常相近</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>Python中的set可以做交集和并集,这点就比较强大了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h1>函数</h1><h2>内置函数</h2><p>Python提供了很多内置函数，并且有详细的文档可以参考，地址：<br><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a><br>后面会写一个内置函数讲解的的blog，敬请期待</p><h2>定义函数</h2><p>Python使用def定义一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><ol><li>函数如果没有return语句，默认返回None</li><li>return None = return</li><li>通过from …(文件名) import …(函数名)导入函数</li><li>函数中还可以使用pass，表示什么都不做</li><li>函数可以返回多值（tuple）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    add = x + y</span><br><span class="line"><span class="meta">... </span>    sub = x - y</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> add,sub</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, a2 = (<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, a2</span><br><span class="line">(<span class="number">5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2>参数</h2><p>Python函数的参数相较Java和JavaScript强大很多，除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</p><h3>默认参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">power(<span class="number">5</span>) <span class="comment">#25</span></span><br><span class="line"></span><br><span class="line">power(<span class="number">5</span>, <span class="number">2</span>) <span class="comment">#25</span></span><br><span class="line"></span><br><span class="line">power(<span class="number">5</span>, n=<span class="number">3</span>) <span class="comment"># 125</span></span><br></pre></td></tr></table></figure><p>定义默认参数要牢记一点：默认参数必须指向不变对象！<br>这是为什么呢？我们举一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(lang=[])</span>:</span></span><br><span class="line">  lang.append(<span class="string">'python'</span>)</span><br><span class="line">  <span class="keyword">return</span> lang</span><br></pre></td></tr></table></figure><p>当老实调用时，结果如你所愿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(test([<span class="string">'js'</span>,<span class="string">'go'</span>]))  <span class="comment">#['js', 'go', 'python']</span></span><br><span class="line">print(test([<span class="string">'c'</span>,<span class="string">'java'</span>]))  <span class="comment">#['c', 'java', 'python']</span></span><br></pre></td></tr></table></figure><p>但是如果多次使用默认参数调用时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(test())  <span class="comment">#['python']</span></span><br><span class="line">print(test())  <span class="comment">#['python', 'python']</span></span><br></pre></td></tr></table></figure><p>分析：<br>函数在定义的时候，默认参数lang的值就已经声明了，即空的 [],也就是说 默认参数 指向对象 [],在多次调用默认参数的情况下，就改变了默认参数指向对象的数据，默认参数 指向对象的数据变了，下次再调用时，默认参数已经变了，而不再是你希望的空的[]</p><p>为了便于理解等同下面这段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(lang=temp)</span>:</span></span><br><span class="line">  lang.append(<span class="string">'python'</span>)</span><br><span class="line">  <span class="keyword">return</span> lang</span><br></pre></td></tr></table></figure><p>重新修改代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(lang=None)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> lang <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    lang = []</span><br><span class="line">  lang.append(<span class="string">'python'</span>)</span><br><span class="line">  <span class="keyword">return</span> lang</span><br></pre></td></tr></table></figure><p>总结：<br>定义函数默认参数时，函数默认参数必须指向不变对象，建议使用 None，str 这些不可变对象处理</p><h3>可变参数</h3><p>可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</p><p>假如要定义一个求和函数，传入参数个数不可知，用一般的方式定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum +n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>但是调用的时候，需要先组装出一个list或tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#6</span></span><br><span class="line">sum((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">#6</span></span><br></pre></td></tr></table></figure><p>使用可变参数定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>调用的时候就可以传入任意参数了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#6</span></span><br></pre></td></tr></table></figure><h3>关键字参数</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure><p>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数,也可以传入任意个数的关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Leo'</span>, <span class="number">18</span>)  <span class="comment">#name: Leo age: 18 other: &#123;&#125;</span></span><br><span class="line">person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)  <span class="comment">#name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;</span></span><br><span class="line">person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)   <span class="comment">#name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/assets/img/Python_logo.png&quot; alt=&quot;我是一只的图片&quot;&gt;&lt;h1&gt;Python 数据类型&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;这里只列举一些Python与Java和JavaScript不一样的地方，如果你有任何语言基础，相信看完这篇文章就可以轻松写Python程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lz5z.com/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lz5z.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring Without Repeating Characters</title>
    <link href="https://lz5z.com/leetcode/3/"/>
    <id>https://lz5z.com/leetcode/3/</id>
    <published>2016-08-18T09:43:59.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>Longest Substring Without Repeating Characters</h1><hr><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Example:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given <span class="string">"abcabcbb"</span>, <span class="keyword">the</span> answer is <span class="string">"abc"</span>, which <span class="keyword">the</span> <span class="built_in">length</span> is <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"bbbbb"</span>, <span class="keyword">the</span> answer is <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">Given <span class="string">"pwwkew"</span>, <span class="keyword">the</span> answer is <span class="string">"wke"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">3.</span> Note that <span class="keyword">the</span> answer must be <span class="keyword">a</span> substring, <span class="string">"pwke"</span> is <span class="keyword">a</span> subsequence <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">a</span> substring.</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2>题目大意</h2><p>这题求一个字符串里面没有重复字母的最长子串</p><h2>Solution1： 双重循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> mSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">if</span> (max &gt; s.length - i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &lt; s.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mSet.has(s[j])) &#123; <span class="comment">//找不到重复元素的时候，记录元素和元素个数</span></span><br><span class="line">                mSet.add(s[j]);</span><br><span class="line">                max = <span class="built_in">Math</span>.max(max, mSet.size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//找到重复元素时，清空记录元素（注意要留下当前元素）</span></span><br><span class="line">                mSet.clear();</span><br><span class="line">                mSet.add(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(max);</span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先把字符串变成数组，然后从第一个元素开始，定义一个指针j，j依次向后搜索，找不到重复元素的时候，记录元素和元素个数，当找到重复元素时，清空记录元素（注意要留下当前元素）。<br>遍历数组完成后，再从第二个元素开始遍历。注意如果已经得到的最长子串大于剩余元素个数的时候，就跳出循环。<br>复杂度是 <strong>O(n^2)</strong> 可能会超时，所以强烈不推荐。</p><h2>Solution2 超强大神版</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dict = &#123;&#125;; <span class="comment">// 字典里面存放每个元素以及元素所在的位置</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dict[s[i]] &gt; start)</span><br><span class="line">            start = dict[s[i]];</span><br><span class="line">        dict[s[i]] = i;</span><br><span class="line">        maxLen = <span class="built_in">Math</span>.max(maxLen, i - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在leetcode的答案中找到了一个大神写的c++算法，简直不能再D，因此改成JavaScript版。</p><p>解析：首先定义一个字典存放每个元素以及元素的位置，当有重复的元素出现时，更改元素位置，并且比较当前元素位置与上次出现位置的距离。</p><hr><p>刚刚入门算法，大神莫喷，欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Longest Substring Without Repeating Characters&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;&lt;p&gt;Example:&lt;/p&gt;&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given &lt;span class=&quot;string&quot;&gt;&quot;abcabcbb&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; answer is &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, which &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt; is &lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given &lt;span class=&quot;string&quot;&gt;&quot;bbbbb&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; answer is &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given &lt;span class=&quot;string&quot;&gt;&quot;pwwkew&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; answer is &lt;span class=&quot;string&quot;&gt;&quot;wke&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; Note that &lt;span class=&quot;keyword&quot;&gt;the&lt;/span&gt; answer must be &lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt; substring, &lt;span class=&quot;string&quot;&gt;&quot;pwke&quot;&lt;/span&gt; is &lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt; subsequence &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt; substring.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://lz5z.com/categories/Algorithm/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="leetcode" scheme="https://lz5z.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Add Two Numbers</title>
    <link href="https://lz5z.com/leetcode/2/"/>
    <id>https://lz5z.com/leetcode/2/</id>
    <published>2016-08-17T13:49:50.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>Add Two Numbers</h1><hr><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit.</p><p>Add the two numbers and return it as a linked list.</p><p>Example:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2>题目大意</h2><p>这题大概意思是给两个链表，链表里面每个值都是一个个位数，然后按照顺序把对应的每个数相加，但是进位的时候向后面进位。如上面的4 + 6 = 10，就把进位的1加到（3 + 4）的结果中。</p><h2>Solution1： 初步解决方案</h2><p>按照测试驱动开发的思想，首先尝试构造两个简单的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l1 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">l1.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l2 = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">l2.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Input: (<span class="number">3</span> -&gt; <span class="number">4</span>) + (<span class="number">7</span> -&gt; <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">Output: <span class="number">0</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p>根据题意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> l3, n, v1, v2, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || p !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 === <span class="literal">null</span>) &#123;</span><br><span class="line">            v1 = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v1 = l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 === <span class="literal">null</span>) &#123;</span><br><span class="line">            v2 = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v2 = l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        n = (v1 + v2 + p) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (l3) &#123;</span><br><span class="line">            node.next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l3 = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">            node = l3;</span><br><span class="line">        &#125;</span><br><span class="line">        p = ~~((v1 + v2 + p) / <span class="number">10</span>); <span class="comment">// ~~是取整的意思， 相较于Math.floor()更快</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>怎么理解这个while循环呢，第一次进入的时候，l1、l2 都有值，所以v1、v2的值就是l1和l2的val，l3的第一个元素就是（3 + 7 + 0）% 10 = 0；<br>第二次进入循环的时候l1和l2已经变成了它们的next，p为1，l3的第二个元素是 （4 + 5 + 1） % 10 = 0；<br>第三次进入循环的时候l1和l2分别是链表的第三个元素null，p为1， 所以l3的第三个元素是 （0 + 0 + 1）% 10 = 1；<br>第四次由于p === 0，l1和l2都是null，所以无法进入循环，循环终止；<br>最终程序返回l3。</p><h2>Solution2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = l1.val + l2.val,</span><br><span class="line">        next1 = l1.next,</span><br><span class="line">        next2 = l2.next;</span><br><span class="line">    <span class="keyword">var</span> l3 = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>),</span><br><span class="line">        node = l3;</span><br><span class="line">    sum = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span> (next1 || next2 || sum !== <span class="number">0</span>) &#123;</span><br><span class="line">        sum += (next1 ? next1.val : <span class="number">0</span>) + (next2 ? next2.val : <span class="number">0</span>);</span><br><span class="line">        node.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        node = node.next;</span><br><span class="line">        next1 = next1 ? next1.next : <span class="literal">null</span>;</span><br><span class="line">        next2 = next2 ? next2.next : <span class="literal">null</span>;</span><br><span class="line">        sum = <span class="built_in">Math</span>.floor(sum / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>刚刚入门算法，大神莫喷，欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Add Two Numbers&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit.&lt;/p&gt;&lt;p&gt;Add the two numbers and return it as a linked list.&lt;/p&gt;&lt;p&gt;Example:&lt;/p&gt;&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) + (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://lz5z.com/categories/Algorithm/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="leetcode" scheme="https://lz5z.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum</title>
    <link href="https://lz5z.com/leetcode/1/"/>
    <id>https://lz5z.com/leetcode/1/</id>
    <published>2016-08-11T15:26:42.000Z</published>
    <updated>2018-05-21T15:12:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1>Two Sum</h1><hr><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution.</p><p>Example:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line">return [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2>题目大意</h2><p>这题大概意思是给一个数字数组和一个目标值，如果数组里面有两个元素的和为这个目标值，返回这两个值的索引。<br>你可以假设每个输入都有解决方案，其实就是让你少写一些无用的判断。<br>值得注意的是<strong>two numbers</strong>， 所以可以忽略target为某一个值两倍的情况。</p><h2>Solution1： 暴力破解法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i, j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法想必大家都能想到，简单粗暴，复杂度是 <strong>O(n^2)</strong></p><h2>Solution2 index判断法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> res = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> m.get(res) === <span class="string">'number'</span>) &#123; <span class="comment">// 为什么不直接用 if(m.get(res))呢， 因为 如果m.get(res)为0的话，返回false</span></span><br><span class="line">            <span class="keyword">return</span> [m.get(res), i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> m.get(nums[i]) === <span class="string">'undefined'</span>) &#123; <span class="comment">// 去重，假如有相同的值，返回最小的index</span></span><br><span class="line">m.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法是将数组中的元素当做 key 存入一个 Map （使用原生js对象也可以），然后通过检验是否存在一个 key = target - nums[i] 判断，时间复杂度是 <strong>O(n)</strong></p><hr><p>刚刚入门算法，大神莫喷，欢迎指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Two Sum&lt;/h1&gt;&lt;hr&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;&lt;p&gt;Example:&lt;/p&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given nums = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;], target = &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Because nums[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] + nums[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://lz5z.com/categories/Algorithm/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="leetcode" scheme="https://lz5z.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>记一次艰难的 bug 寻找</title>
    <link href="https://lz5z.com/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%89%B0%E9%9A%BE%E7%9A%84bug%E5%AF%BB%E6%89%BE/"/>
    <id>https://lz5z.com/记一次艰难的bug寻找/</id>
    <published>2016-07-14T13:54:48.000Z</published>
    <updated>2018-05-21T15:12:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>最近从公司SOP项目转到Data Analysis「DA」项目，开始从事Mean堆栈的开发，一些新的坑也要从头踩起。昨天就遇到了一个深坑，特此记录下来。</p><a id="more"></a><h2>坑</h2><p>拿到之前同事写的代码，看懂流程以后就开始写功能了。我要做的事情是把之前同事写的生成Excel的内容导入到Oracle中，那就尽量调用之前的代码吧。<br>由于数据量比较大，所以采用Schedule Job的方式，每过一段时间执行一次，将200条BL数据（实际插入2k+的数据）导入DB。100w+的数据筛选后大概需要两天的时间全部导入。</p><p>有一段代码是执行一个Promise.all函数，执行完以后进入下一个Promise，在正常执行了很久以后，有一段时间突然变得很慢。于是我就停下job，重启一次发现又能正常执行了，可是总是过一段时间就变得非常慢，看log又看不出端倪，停下来重跑就又正常，这样好难找到原因，即使debug也不一定能重现。</p><p>只能耐着性子一句代码一句地看，这样Promise.all里面调用了4个的函数，每个函数里面又至少有几十个函数，所幸的是4个函数里面调用的函数都是类似的，只是改变了一些变量和常数。</p><p>就这么看了几个小时，这个时候非常想知道JavaScript有没有什么性能分析的工具，可以查看某一段代码执行花费的时间。在Google和百度搜了都没有找到合适的工具，要急死我了。</p><p>苦心人天不负，终于在一个计算时间的函数里面看到了端倪。这个函数是一个计算时间差的函数，中间要排除节假日和下班时间，然后计算真正工作时间花费了多久。</p><p>之前同事的逻辑是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (endTime &gt; current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (currnt是工作时间)&#123;</span><br><span class="line">        total += <span class="number">1</span> 分钟</span><br><span class="line">    &#125;</span><br><span class="line">    current = current + <span class="number">1</span>分钟</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为节假日和周末都是以天都单位的，可是上下班时间是以分钟为单位的，所以同事选择了每分钟逐渐递加，然后判断是否为工作时间。这样的计算逻辑是没有问题的，不过非常耗费时间，因为节假日不是工作时间，但是还需要每分钟逐渐递加去比较判断。而我在数据库里面发现了一些奇怪的数据，有几百条数据不均匀的分布在数据库中，它们的endTime比startTime大了1-2年。所以在计算这些数据的时候 /(ㄒoㄒ)/~~</p><p>咨询资深的同事后，得知这些问题数据是历史残留–系统迁移导致，暂时没有办法解决，而且这些数据还是正确的数据。</p><p>为什么重新跑以后就又没有问题了呢，因为在我跑数据的过程中新的数据不断产生，我之前导数据又没有排序，所以每次都是处理最新产生的数据，自然不容易找到问题啦。</p><p>这下太开心了，有一句经典的话说是 <strong>发现问题比解决问题更难</strong>，既然发现了问题，解决起来应该easy啦。</p><p>于是改写之前的逻辑，把逐分钟递增改成逐天增加，首先构造一个工作日的对象，里面存着每天的上下班时间和这天总工作时间，然后构造一个节假日对象，存每个节日的年、月、日。<br>循环的时候，首先判断当天是否为节假日，如果为节假日则直接进入下一天，如果不是节假日就计算当天工作的时间，最后将所有工作时间加起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;间隔days; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (current是工作日) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current是start date)&#123;</span><br><span class="line">            total += (startTime - 下班时间)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current是end date) &#123;</span><br><span class="line">            total += (endTime - 上班时间)</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            total += 当天工作时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照TDD（测试驱动开发的思想），想到每一个case都是先写测试用例，然后完善代码，终于完成13个测试用例的同时把代码写完。</p><h1>总结</h1><p>虽然耗费了我一整个上午加不休息的中午，但是我几乎把之前相关的代码都看懂了，所以让我对整个项目的了解也加深了不少，而且排查问题的过程中我增强了自己导数据的逻辑——添加了排序功能，这样更方便我找到问题数据，相信会对以后的开发提供很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;背景&lt;/h1&gt;&lt;p&gt;最近从公司SOP项目转到Data Analysis「DA」项目，开始从事Mean堆栈的开发，一些新的坑也要从头踩起。昨天就遇到了一个深坑，特此记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://lz5z.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="https://lz5z.com/tags/JavaScript/"/>
    
      <category term="bug" scheme="https://lz5z.com/tags/bug/"/>
    
      <category term="Mean" scheme="https://lz5z.com/tags/Mean/"/>
    
  </entry>
  
</feed>
