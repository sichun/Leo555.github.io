{"title":"lizhen's blog","description":"Lizhen's personal static blog.","language":"","link":"https://lz5z.com","pubDate":"Thu, 17 May 2018 19:24:09 GMT","lastBuildDate":"Mon, 21 May 2018 15:12:55 GMT","generator":"hexo-generator-json-feed","webMaster":"lizhen","items":[{"title":"Web 性能优化-首屏和白屏时间","link":"https://lz5z.com/Web性能优化-首屏和白屏时间/","description":"什么是首屏和白屏时间？白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成影响白屏时间的因素：网络，服务端性能，前端页面结构设计。影响首屏时间的因素：白屏时间，资源下载执行时间。以百度为例，将 chrome 网速调为 Fast 3G，然后打开 Performance 工具，点击 “Start profiling and reload page” 按钮，查看 Screenshots 如下图：","pubDate":"Thu, 17 May 2018 19:24:09 GMT","guid":"https://lz5z.com/Web性能优化-首屏和白屏时间/","category":"性能"},{"title":"Web 性能优化-缓存-HTTP 缓存","link":"https://lz5z.com/Web性能优化-HTTP缓存/","description":"浏览器缓存HTTP 缓存通常要配合客户端（浏览器）使用才能发挥效果，所以又被称之为浏览器缓存，是 Web 性能优化的一大利器。这里有一个 demo 展现 HTTP 缓存的效果，你可以 clone 到本地，通过 npm run dev 来查看效果。缓存类型浏览器缓存分为强缓存和协商缓存。(1) 强缓存：浏览器在加载资源的时候，根据资源的 HTTP Header 判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。(2) 协商缓存：当强缓存没有命中的时候，浏览器向服务器发送请求，服务器端依据资源的另外一些 HTTP Header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 304，浏览器从缓存中加载这个资源；若未命中请求，服务端返回 200 并将资源返回客户端，浏览器更新本地缓存数据。","pubDate":"Wed, 16 May 2018 16:39:55 GMT","guid":"https://lz5z.com/Web性能优化-HTTP缓存/","category":"性能"},{"title":"Web 性能优化-缓存-DNS 缓存","link":"https://lz5z.com/Web性能优化-DNS缓存/","description":"缓存梗概缓存技术几乎存在于网络技术发展的各个角落，从数据库到服务器，从服务器到网络，再从网络到客户端，缓存随处可见。跟前端有关的缓存技术主要有：DNS 缓存，HTTP 缓存，浏览器缓存，HTML5 缓存（localhost/manifest）和 service worker 中的 cache api。DNS 缓存当用户在浏览器中输入网址的地址后，浏览器要做的第一件事就是解析 DNS：(1) 浏览器检查缓存中是否有域名对应的 IP，如果有就结束 DNS 解析过程。浏览器中的 DNS 缓存有时间和大小双重限制，时间一般为几分钟到几个小时不等。DNS 缓存时间过长会导致如果 IP 地址发生变化，无法解析到正确的 IP 地址；时间过短会导致浏览器重复解析域名。(2) 如果浏览器缓存中没有对应的 IP 地址，浏览器会继续查找操作系统缓存中是否有域名对应的 DNS 解析结果。我们可以通过在操作系统中设置 hosts 文件来设置 IP 与域名的关系。","pubDate":"Wed, 16 May 2018 13:32:17 GMT","guid":"https://lz5z.com/Web性能优化-DNS缓存/","category":"性能"},{"title":"前端模块化-CommonJS,AMD,CMD,ES6","link":"https://lz5z.com/JavaScript模块化-CommonJS-AMD-CMD-ES6/","description":"模块化解决什么问题随着 JavaScript 工程越来越大，团队协作不可避免，为了更好地对代码进行管理和测试，模块化的概念逐渐引入前端。模块化可以降低协同开发的成本，减少代码量，同时也是“高内聚，低耦合”的基础。模块化主要解决两个问题：命名冲突文件依赖：比如 bootstrap 需要引入 jquery，jquery 文件的位置必须要 bootstrap.js 之前引入。","pubDate":"Sun, 06 May 2018 23:03:17 GMT","guid":"https://lz5z.com/JavaScript模块化-CommonJS-AMD-CMD-ES6/","category":"JavaScript"},{"title":"Web 性能优化-CSS3 硬件加速(GPU 加速)","link":"https://lz5z.com/Web性能优化-CSS3硬件加速/","description":"CSS3 硬件加速简介上一篇文章学习了重绘和回流对页面性能的影响，是从比较宏观的角度去优化 Web 性能，本篇文章从每一帧的微观角度进行分析，来学习 CSS3 硬件加速的知识。CSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。由于 GPU 中的 transform 等 CSS 属性不会触发 repaint，所以能大大提高网页的性能。我做了一个页面，左边元素的动画通过 left/top 操作位置实现，右边元素的动画通过 transform: translate 实现，你可以打开 chrome 的 “Paint flashing” 查看，绿色部分是正在 repaint 的内容。查看地址从 demo 中可以看到左边的图形在运动时外层有一圈绿色的边框，表示元素不停地 repaint，并且可以看到其运动过程中有丢帧现象，具体表现为运动不连贯，有轻微闪动。","pubDate":"Thu, 03 May 2018 20:10:40 GMT","guid":"https://lz5z.com/Web性能优化-CSS3硬件加速/","category":"性能"},{"title":"Web 性能优化-页面重绘和回流（重排）","link":"https://lz5z.com/Web性能优化-页面重绘和回流/","description":"前言早在五年前，Google 就提出了 1s 完成终端页面的首屏渲染的标准。常见的优化网络请求的方法有：DNS Lookup，减少重定向，避免 JS、CSS 阻塞，并行请求，代码压缩，缓存，按需加载，前端模块化…","pubDate":"Wed, 02 May 2018 21:46:24 GMT","guid":"https://lz5z.com/Web性能优化-页面重绘和回流/","category":"性能"},{"title":"JavaScript 垃圾回收","link":"https://lz5z.com/JavaScript垃圾回收/","description":"垃圾回收JavaScript 具有自动垃圾回收机制，这种垃圾回收机制原理其实很简单：找出那些不再继续使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时间间隔周期性地执行这一操作。局部变量只有在函数执行的过程中存在，在这个过程中，会为局部变量在栈（或者堆）内存上分配空间，然后在函数中使用这些变量，直至函数执行结束。垃圾回收器必须追踪哪个变量有用哪个没用，对于不再有用的变量打上标记，以备将来回收其占用的内存，用于标识无用变量的策略主要有标记清除法和引用计数法。","pubDate":"Wed, 25 Apr 2018 18:01:21 GMT","guid":"https://lz5z.com/JavaScript垃圾回收/","category":"JavaScript"},{"title":"JavaScript 常见的内存泄漏","link":"https://lz5z.com/JavaScript-Memory-Leaks/","description":"什么是内存泄漏JavaScript 是一种垃圾回收语言，垃圾回收语言通过周期性地检查之前被分配的内存是否可以从应用的其它部分访问来帮助开发者管理内存。内存泄露是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。","pubDate":"Mon, 23 Apr 2018 22:07:24 GMT","guid":"https://lz5z.com/JavaScript-Memory-Leaks/","category":"JavaScript"},{"title":"Vim 学习","link":"https://lz5z.com/vim-study/","description":"本文的内容来自 vimtutor(v1.7)，在 Unix 系统下输入 “vimtutor” 即可进入教学模型。这里记录下来学习点滴，方便以后查看。Vim 简介Vim 是一款由 Vi 派生出来的命令行编辑器，具有语法高亮、代码折叠、多语言支持、多视图等强大的功能，并且支持插件扩展和调用脚本语言。Vim 有多种模式，其中最常用的为插入和执行模式，仅仅通过键盘来在这些模式之中切换，大大提高了程序开发效率。Vim 使用移动光标123456要移动光标使用 h、j、k、l 键 ^ k &lt; h l &gt; j v","pubDate":"Thu, 19 Apr 2018 13:09:32 GMT","guid":"https://lz5z.com/vim-study/","category":"Tools"},{"title":"使用 requestAnimationFrame 实现动画","link":"https://lz5z.com/requestAnimationFrame/","description":"如何实现一个动画我们来实现一个最简单的需求，将一个元素从屏幕左边均匀地移动到屏幕右边。下面是效果:.animate-warpper{width:100%;height:70px}@keyframes move_animation{0%{left:0}100%{left:calc(100% - 60px)}}.animate-div{width:60px;height:40px;position:absolute;left:0;border-radius:5px;background:#92B901;transform:translateZ(0);-webkit-transform:translateZ(0);animation:move_animation 5s linear 2s infinite alternate}","pubDate":"Sat, 14 Apr 2018 18:24:28 GMT","guid":"https://lz5z.com/requestAnimationFrame/","category":"JavaScript"},{"title":"JavaScript 循环与异步","link":"https://lz5z.com/JavaScript-Loop-Async/","description":"JS 中的循环与异步JS 中有多种方式实现循环：for; for in; for of; while; do while; forEach; map 等等。假如循环里面的内容是异步并且 await 的，那异步代码究竟是像 Promise.all一样将循环中的代码一起执行，还是每次等待上一次循环执行完毕再执行呢？首先看结论forEach 和 map, some, every 循环是并行执行的，相当于 Promise.all，其它 for, for in, for of, while, do while 都是串行执行的。先定义异步函数 foo 和可遍历数组 arr：123456789const arr = Array.from(&#123; length: 5 &#125;, (v, k) =&gt; k)const foo = i =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve('') &#125;, 1000) &#125;)&#125;","pubDate":"Wed, 11 Apr 2018 14:03:53 GMT","guid":"https://lz5z.com/JavaScript-Loop-Async/","category":"JavaScript"},{"title":"正则表达式格式化查询参数","link":"https://lz5z.com/QueryStringFormat-RegExp/","description":"记录一下，通过一行正则表达式和 replace 方法简单实现正则表达式格式化查询参数。123456789101112131415161718const url = 'https://lz5z.com/000/?a=123&amp;b=456&amp;c=%E4%B8%AD%E6%96%87'/** * 格式化查询字符串(正则实现) * @param url url地址 * @return &#123;Object&#125; 格式化的json对象 */function formatUrl(url) &#123; const reg = /(?:[?&amp;]+)([^&amp;]+)=([^&amp;]+)/g let data = &#123;&#125; function fn(str, key, value) &#123; data[decodeURIComponent(key)] = decodeURIComponent(value) &#125; url.replace(reg, fn) return data&#125;console.log(formatUrl(url)) // &#123; a: '123', b: '456', c: '中文' &#125;下次面试官问你的时候，你能答上来吗？😉😉😉","pubDate":"Mon, 26 Mar 2018 23:05:05 GMT","guid":"https://lz5z.com/QueryStringFormat-RegExp/","category":"JavaScript"},{"title":"JavaScript 深拷贝和浅拷贝","link":"https://lz5z.com/JavaScript深拷贝和浅拷贝/","description":"在 JavaScript 引用数据类型中，变量保存的是一个指向堆内存的指针，当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。12345let obj1 = &#123; x: 1, y: 2 &#125;let obj2 = obj1obj2.x = 2console.log(obj1) // &#123; x: 2, y: 2 &#125;console.log(obj2) // &#123; x: 2, y: 2 &#125;以上的拷贝方式就是浅拷贝，当 obj2 的值改变时，obj1 的值也随之发生改变。","pubDate":"Sat, 10 Mar 2018 22:02:49 GMT","guid":"https://lz5z.com/JavaScript深拷贝和浅拷贝/","category":"JavaScript"},{"title":"Shell 学习","link":"https://lz5z.com/shell-study/","description":"Shell 变量变量默认都是字符串类型变量名和等号之间不能有空格命名：只能使用英文字母，数字和下划线，首个字符不能以数字开头查看变量 set 命令，删除变量 unset variable_nameset -u 调用未声明变量报错（默认无提示）变量叠加1234x=123x=\"$x\"456x=$&#123;x&#125;789echo $x # 123456789","pubDate":"Wed, 07 Mar 2018 22:51:37 GMT","guid":"https://lz5z.com/shell-study/","category":"Linux"},{"title":"HTTP/2 学习","link":"https://lz5z.com/http2-study/","description":"HTTP/2.0 简介HTTP/2 标准于 2015 年发布，目前大部分主流浏览器均已提供支持。HTTP/2 没有改变 HTTP 的应用语义，其请求方法、状态码、URI 等核心概念与 HTTP/1.1 保持一致。HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。HTTP/2 的前身是 SPDY 协议。HTTP/2 中 TLS 为可选，但是大厂商如 chrome 和 firefox 表示只会实现基于 TLS 的 HTTP/2。所以要部署 HTTP/2，首先要升级 HTTPS。HTTP/2 通过以下举措，减少网络延迟，提供浏览器加载速度：对 HTTP 头字段进行数据压缩(即 HPACK 算法)；HTTP/2 服务端推送(Server Push)；请求管线化；修复 HTTP/1. 0版本以来未修复的队头阻塞问题；对数据传输采用多路复用，让多个请求合并在同一 TCP 连接内。","pubDate":"Wed, 07 Mar 2018 21:35:06 GMT","guid":"https://lz5z.com/http2-study/","category":"网络"},{"title":"再见2017，你好2018","link":"https://lz5z.com/GoodBye2017-Hello2018/","description":"2017好久没有更新博客了。2017年过得真快，转眼已经快触不到2017的尾巴了，如果算农历年的话，留给它的时间也已经不多了。2017年对于我来说发生的最重要的事情就是跳槽了，从 OOCL 离职，到入职 WPS 正好一年了。这一年可以说是我职业发展最为重要的一年，以后应该都会在这个方向前行了。这一年差不多是我从门外汉逐步入门的过程，虽然之前也有一两年的工作经验，但大多时候是打酱油，在一个大的项目中缝缝补补。而经过 WPS 一年的训练，如今我可以写一些小的项目，也完全看懂了部门的大项目的整个架构。第二件事就是今年八月份买了人生第一辆小车车-日产骐达。这辆小车车如今已经是我们家中第三重要的成员了，给生活提升了极大的幸福感。尤其是搬家的时候，身心俱疲，但是当进入小车的一瞬间，知道自己无论如何有落脚的地方，就觉得很安心。","pubDate":"Sun, 11 Feb 2018 20:11:42 GMT","guid":"https://lz5z.com/GoodBye2017-Hello2018/","category":"杂记"},{"title":"webpack 打包加速实战","link":"https://lz5z.com/webpack打包加速实战/","description":"webpack 打包优化最近项目不算忙，抽时间重构了一下项目的打包，先说一下成就。在我的开发电脑上：OS: macOS High SierraCPU: 2.6 GHz Intel Core i5内存: 8G 1600 DDR3硬盘: 1 TB SATA磁盘代码全量编译时间从 4 分 51 秒优化到 2 分 08 - 20 秒左右。在项目编译电脑上：OS: Ubuntu 16.04.3 LTSCPU: Intel® Core™ i5-7500 CPU @ 3.40GHz内存: 64G 2133 DDR4硬盘: 1 TB SSD代码全量编译时间从 4 分 08 秒优化到 1 分 10 - 20 秒左右。","pubDate":"Sat, 13 Jan 2018 09:05:31 GMT","guid":"https://lz5z.com/webpack打包加速实战/","category":"JavaScript"},{"title":"常用命令","link":"https://lz5z.com/常用命令/","description":"记录一些常用的系统或者软件命令kill portlinux12345# 查看端口占用$ lsof -i :8080# 结束进程$ sudo kill -9 [pid]windows1234567891011# 查看端口占用$ netstat -aon | findstr 8080# 查看 pid 进程$ tasklist | findstr 19516# 结束进程$ taskkill /pid 19516 /F# 或者使用进程名字$ taskkill -F -IM node.exe","pubDate":"Wed, 20 Dec 2017 08:56:26 GMT","guid":"https://lz5z.com/常用命令/","category":"杂记"},{"title":"CSS 伪元素技巧","link":"https://lz5z.com/CSS伪元素技巧/","description":"伪元素技巧在 CSS 伪元素基本用法一文中讲述了伪元素的基础功能，本章学习一些进阶功能，看看伪元素能实现哪些方便好用的功能。清除浮动如果一个元素内部的子元素全部都是浮动的话，那么这个元素会出现高度塌陷，这个时候就需要清除浮动。高度塌陷的负面作用主要有：不能正确显示背景，边框不能撑开，margin 和 padding 不能正确显示。假设有代码如下：","pubDate":"Fri, 08 Dec 2017 20:08:00 GMT","guid":"https://lz5z.com/CSS伪元素技巧/","category":"CSS"},{"title":"CSS 伪元素基本用法","link":"https://lz5z.com/CSS伪元素基本用法/","description":"伪元素CSS 中可以利用伪元素给 DOM 元素添加特殊的样式。比如说，我们可以通过 :before 在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。CSS3 规范中要求使用双冒号(::)添加伪元素，用以区分伪元素和伪类，比如 ::before 是伪元素，:hover 是伪类。但是大部分伪元素依然支持单冒号的形式，::before 写成 :before 也可以，为了向后兼容，一般推荐使用单冒号的形式。支持单双冒号的伪元素有： :before/::before，:after/::after，:first-letter/::first-letter，:first-line/::first-line。仅支持双冒号的伪元素有： ::selection，::placeholder，::backdrop。","pubDate":"Fri, 08 Dec 2017 18:06:19 GMT","guid":"https://lz5z.com/CSS伪元素基本用法/","category":"CSS"},{"title":"HTML meta 标签","link":"https://lz5z.com/html-meta/","description":"引言最近做的一个关于电影的网站 IMDB Top250，想对其进行 SEO 优化，用到 meta 信息的时候，很多知识都是 『似乎』、『好像』、『可能』 的感觉，回想自己一直没有系统的学习过 meta 相关的知识，这些东西虽然简单，但是很多时候能发挥出意想不到的效果，尤其对于 SEO 有非常重要的作用。meta 简介meta 标签位于文档的头部，可提供有关页面的元信息（meta-information）。 meta 标签本身不包含任何内容，通过其属性定义了与文档相关联的内容。meta 标签一共有五个属性值： charset、content、http-equiv、name、scheme。 其中 http-equiv 和 name必须与 content 配合组成键值对使用， charset 为 HTML5 属性， scheme 属性 HTML5 不支持。","pubDate":"Sat, 02 Dec 2017 15:22:13 GMT","guid":"https://lz5z.com/html-meta/","category":"HTML"},{"title":"迁移 github pages 到 coding.net","link":"https://lz5z.com/迁移Blog到Coding/","description":"由于众所周知的原因，github 在国内时不时不能访问，虽然有各种办法可以跨越屏障，但是你不能用预测未来会发生哪些事情，于是决定将博客迁移到国内，coding 是一个不错的选择，主要有以下几个优点。国内速度更快自带 SSL，且免费五个免费的私人仓库功能较全: pages, webIDE, CI 等经过一段时间迭代，产品经得起考验","pubDate":"Fri, 27 Oct 2017 15:37:59 GMT","guid":"https://lz5z.com/迁移Blog到Coding/","category":"杂记"},{"title":"解决 webpack 打包后 z-index 重新计算的问题","link":"https://lz5z.com/解决webpack打包后z-index重新计算的问题/","description":"背景与 PC 端共同开发一个页面，页面由 PC 端提供，内部 iframe 则由我们前端提供。开发时候遇到了一个问题，webpack 打包后 css 的 z-index 值与原始值不符，导致 iframe 里面的 toast 被外面 z-index 较小的 dialog 覆盖。更改 toast 的 z-index，发现没起作用，页面上的 z-index 依然是之前的值，而不是 css 中赋予的值。给 z-index 加上 !important 后依然无效，查资料发现是 OptimizeCssAssetsPlugin 调用 cssProcessor cssnano 对 z-index 进行了重新计算导致的。这本来是 webpack 插件的一个善举（让 z-index 数值更加合理），但是具体情况来看，这里显然不需要这个 “善举”。","pubDate":"Tue, 24 Oct 2017 13:18:37 GMT","guid":"https://lz5z.com/解决webpack打包后z-index重新计算的问题/","category":"JavaScript"},{"title":"Linux 文件权限","link":"https://lz5z.com/Linux文件权限/","description":"linux 文件属性linux 中用户相对于文件有三种身份：owner、group、others，每种身份各有 read、write、execute 三种权限。使用 ls -l 命令可以查看与文件权限相关的信息：1234$ ls -ldrwxr-xr-x 2 lizhen staff 68 10 10 19:14 foo-rw-r--r-- 1 lizhen staff 0 10 10 19:14 test.txtlrwxr-xr-x 1 lizhen staff 62 7 10 10:01 subl -&gt; /Applications/Sublime Text.app/Contents/SharedSupport/bin/subl其中第一个字符表示文件类型：d 表示文件为一个目录，- 表示文件为普通文件，l 表示链接， b 表示设备文件。接下来的字符中，以三个为一组，且均为 r(read)、 w(write)、 x(execute) 三个参数的组合，首先三个字符表示文件所有者权限，后面三个字符表示用户组权限，最后三个表示其他人对文件的权限。这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]。后面的字段分别代表：硬链接个数，所有者，所在组，文件或者目录大小，最后访问/修改时间，文件或者目录名。","pubDate":"Tue, 10 Oct 2017 19:06:38 GMT","guid":"https://lz5z.com/Linux文件权限/","category":"Linux"},{"title":"ES2016 和 ES2017 学习","link":"https://lz5z.com/ES2016和ES2017学习/","description":"ES6 发布之后，TC-39 小组每年发布一次 ECMAScript 语言新特性，这个 repository tc39/ecma262 中记录着最新版的提议。新版本的 ECMAScript 使用年份来表示版本，所以 ES6 被称为 ES2015， ES7 被称为 ES2016，所以标准起见，以后我们也称之为 ES2016 和 ES2017。ECMAScript 2016ES2016 只有两个新特性Array.prototype.includes求冥运算(Exponentiation Operator)","pubDate":"Tue, 12 Sep 2017 16:26:44 GMT","guid":"https://lz5z.com/ES2016和ES2017学习/","category":"JavaScript"}]}